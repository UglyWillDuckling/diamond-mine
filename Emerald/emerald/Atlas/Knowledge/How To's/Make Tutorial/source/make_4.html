<!-- This HTML file has been created by texi2html 1.30
     from /mit/gnu/src/make-3.72/make.texinfo on 6 November 1994 -->

<TITLE>GNU Make - Writing Rules</TITLE>
<P>Go to the <A HREF="make_3.html">previous</A>, <A HREF="make_5.html">next</A> section.<P>
<A NAME="IDX96"></A>
<A NAME="IDX97"></A>
<A NAME="IDX98"></A>
<A NAME="IDX99"></A>
<H1><A NAME="SEC19" HREF="make_toc.html#SEC19">Writing Rules</A></H1>
<P>
A <DFN>rule</DFN> appears in the makefile and says when and how to remake
certain files, called the rule's <DFN>targets</DFN> (most often only one per rule).
It lists the other files that are the <DFN>dependencies</DFN> of the target, and
<DFN>commands</DFN> to use to create or update the target.
<A NAME="IDX100"></A>
<A NAME="IDX101"></A>
<P>
The order of rules is not significant, except for determining the
<DFN>default goal</DFN>: the target for <CODE>make</CODE> to consider, if you do
not otherwise specify one.  The default goal is the target of the first
rule in the first makefile.  If the first rule has multiple targets,
only the first target is taken as the default.  There are two
exceptions: a target starting with a period is not a default unless it
contains one or more slashes, <SAMP>`/'</SAMP>, as well; and, a target that
defines a pattern rule has no effect on the default goal.
(See section <A HREF="make_10.html#SEC91">Defining and Redefining Pattern Rules</A>.)
<P>
Therefore, we usually write the makefile so that the first rule is the
one for compiling the entire program or all the programs described by
the makefile (often with a target called <SAMP>`all'</SAMP>).
See section <A HREF="make_9.html#SEC80">Arguments to Specify the Goals</A>.
<P>
<H2><A NAME="SEC20" HREF="make_toc.html#SEC20">Rule Syntax</A></H2>
<A NAME="IDX102"></A>
<A NAME="IDX103"></A>
<P>
In general, a rule looks like this:
<P>
<PRE>
<VAR>targets</VAR> : <VAR>dependencies</VAR>
        <VAR>command</VAR>
        ...
</PRE>
<P>
or like this:
<P>
<PRE>
<VAR>targets</VAR> : <VAR>dependencies</VAR> ; <VAR>command</VAR>
        <VAR>command</VAR>
        ...
</PRE>
<A NAME="IDX104"></A>
<A NAME="IDX105"></A>
<P>
The <VAR>targets</VAR> are file names, separated by spaces.  Wildcard
characters may be used (see section <A HREF="make_4.html#SEC21">Using Wildcard Characters in File Names</A>) and a name of the form <TT>`<VAR>a'</TT>(<VAR>m</VAR>)</VAR>
represents member <VAR>m</VAR> in archive file <VAR>a</VAR> 
(see section <A HREF="make_11.html#SEC102">Archive Members as Targets</A>).  
Usually there is only one
target per rule, but occasionally there is a reason to have more
(see section <A HREF="make_4.html#SEC35">Multiple Targets in a Rule</A>).<A NAME="IDX106"></A>
<A NAME="IDX107"></A>
<P>
The <VAR>command</VAR> lines start with a tab character.  The first command may
appear on the line after the dependencies, with a tab character, or may
appear on the same line, with a semicolon.  Either way, the effect is the
same.  See section <A HREF="make_5.html#SEC42">Writing the Commands in Rules</A>.
<A NAME="IDX108"></A>
<A NAME="IDX109"></A>
<A NAME="IDX110"></A>
<P>
Because dollar signs are used to start variable references, if you really
want a dollar sign in a rule you must write two of them, <SAMP>`$$'</SAMP>
(see section <A HREF="make_6.html#SEC55">How to Use Variables</A>).  
You may split a long line by inserting a backslash
followed by a newline, but this is not required, as <CODE>make</CODE> places no
limit on the length of a line in a makefile.
<P>
A rule tells <CODE>make</CODE> two things: when the targets are out of date,
and how to update them when necessary.
<A NAME="IDX111"></A>
<A NAME="IDX112"></A>
<P>
The criterion for being out of date is specified in terms of the
<VAR>dependencies</VAR>, which consist of file names separated by spaces.
(Wildcards and archive members (see section <A HREF="make_11.html#SEC101">Using <CODE>make</CODE> to Update Archive Files</A>) are allowed here too.)
A target is out of date if it does not exist or if it is older than any
of the dependencies (by comparison of last-modification times).  The
idea is that the contents of the target file are computed based on
information in the dependencies, so if any of the dependencies changes,
the contents of the existing target file are no longer necessarily
valid.
<P>
How to update is specified by <VAR>commands</VAR>.  These are lines to be
executed by the shell (normally <SAMP>`sh'</SAMP>), but with some extra features
(see section <A HREF="make_5.html#SEC42">Writing the Commands in Rules</A>).
<P>
<A NAME="IDX113"></A>
<A NAME="IDX114"></A>
<A NAME="IDX115"></A>
<H2><A NAME="SEC21" HREF="make_toc.html#SEC21">Using Wildcard Characters in File Names</A></H2>
<A NAME="IDX116"></A>
<A NAME="IDX117"></A>
<A NAME="IDX118"></A>
<P>
A single file name can specify many files using <DFN>wildcard characters</DFN>.
The wildcard characters in <CODE>make</CODE> are <SAMP>`*'</SAMP>, <SAMP>`?'</SAMP> and
<SAMP>`[...]'</SAMP>, the same as in the Bourne shell.  For example, <TT>`*.c'</TT>
specifies a list of all the files (in the working directory) whose names
end in <SAMP>`.c'</SAMP>.<A NAME="IDX119"></A>
<A NAME="IDX120"></A>
<A NAME="IDX121"></A>
<P>
The character <SAMP>`~'</SAMP> at the beginning of a file name also has special
significance.  If alone, or followed by a slash, it represents your home
directory.  For example <TT>`~/bin'</TT> expands to <TT>`/home/you/bin'</TT>.
If the <SAMP>`~'</SAMP> is followed by a word, the string represents the home
directory of the user named by that word.  For example <TT>`~john/bin'</TT>
expands to <TT>`/home/john/bin'</TT>.<P>
Wildcard expansion happens automatically in targets, in dependencies,
and in commands (where the shell does the expansion).  In other
contexts, wildcard expansion happens only if you request it explicitly
with the <CODE>wildcard</CODE> function.
<P>
The special significance of a wildcard character can be turned off by
preceding it with a backslash.  Thus, <TT>`foo\*bar'</TT> would refer to a
specific file whose name consists of <SAMP>`foo'</SAMP>, an asterisk, and
<SAMP>`bar'</SAMP>.<P>
<H3><A NAME="SEC22" HREF="make_toc.html#SEC22">Wildcard Examples</A></H3>
<P>
Wildcards can be used in the commands of a rule, where they are expanded
by the shell.  For example, here is a rule to delete all the object files:
<P>
<PRE>
clean:
        rm -f *.o
<A NAME="IDX122"></A>
</PRE>
<P>
Wildcards are also useful in the dependencies of a rule.  With the
following rule in the makefile, <SAMP>`make print'</SAMP> will print all the
<SAMP>`.c'</SAMP> files that have changed since the last time you printed them:
<P>
<PRE>
print: *.c
        lpr -p $?
        touch print
</PRE>
<A NAME="IDX123"></A>
<A NAME="IDX124"></A>
<A NAME="IDX125"></A>
<P>
This rule uses <TT>`print'</TT> as an empty target file; see section <A HREF="make_4.html#SEC33">Empty Target Files to Record Events</A>.  (The automatic variable
<SAMP>`$?'</SAMP> is used to print only those files that have changed; see
section <A HREF="make_10.html#SEC94">Automatic Variables</A>.)<P>
Wildcard expansion does not happen when you define a variable.  Thus, if
you write this:
<P>
<PRE>
objects = *.o
</PRE>
<P>
then the value of the variable <CODE>objects</CODE> is the actual string
<SAMP>`*.o'</SAMP>.  However, if you use the value of <CODE>objects</CODE> in a target,
dependency or command, wildcard expansion will take place at that time.
To set <CODE>objects</CODE> to the expansion, instead use:
<P>
<PRE>
objects := $(wildcard *.o)
</PRE>
<P>
See section <A HREF="make_4.html#SEC24">The Function <CODE>wildcard</CODE></A>.
<P>
<A NAME="IDX126"></A>
<A NAME="IDX127"></A>
<A NAME="IDX128"></A>
<A NAME="IDX129"></A>
<A NAME="IDX130"></A>
<H3><A NAME="SEC23" HREF="make_toc.html#SEC23">Pitfalls of Using Wildcards</A></H3>
<P>
Now here is an example of a naive way of using wildcard expansion, that
does not do what you would intend.  Suppose you would like to say that the
executable file <TT>`foo'</TT> is made from all the object files in the
directory, and you write this:
<P>
<PRE>
objects = *.o

foo : $(objects)
        cc -o foo $(CFLAGS) $(objects)
</PRE>
<P>
The value of <CODE>objects</CODE> is the actual string <SAMP>`*.o'</SAMP>.  Wildcard
expansion happens in the rule for <TT>`foo'</TT>, so that each <EM>existing</EM>
<SAMP>`.o'</SAMP> file becomes a dependency of <TT>`foo'</TT> and will be recompiled if
necessary.
<P>
But what if you delete all the <SAMP>`.o'</SAMP> files?  When a wildcard matches
no files, it is left as it is, so then <TT>`foo'</TT> will depend on the
oddly-named file <TT>`*.o'</TT>.  Since no such file is likely to exist,
<CODE>make</CODE> will give you an error saying it cannot figure out how to
make <TT>`*.o'</TT>.  This is not what you want!
<P>
Actually it is possible to obtain the desired result with wildcard
expansion, but you need more sophisticated techniques, including the
<CODE>wildcard</CODE> function and string substitution.
These are described in the following section.
<P>
<A NAME="IDX131"></A>
<H3><A NAME="SEC24" HREF="make_toc.html#SEC24">The Function <CODE>wildcard</CODE></A></H3>
<P>
Wildcard expansion happens automatically in rules.  But wildcard expansion
does not normally take place when a variable is set, or inside the
arguments of a function.  If you want to do wildcard expansion in such
places, you need to use the <CODE>wildcard</CODE> function, like this:
<P>
<PRE>
$(wildcard <VAR>pattern</VAR>...)
</PRE>
<P>
This string, used anywhere in a makefile, is replaced by a
space-separated list of names of existing files that match one of the
given file name patterns.  If no existing file name matches a pattern,
then that pattern is omitted from the output of the <CODE>wildcard</CODE>
function.  Note that this is different from how unmatched wildcards
behave in rules, where they are used verbatim rather than ignored
(see section <A HREF="make_4.html#SEC23">Pitfalls of Using Wildcards</A>).
<P>
One use of the <CODE>wildcard</CODE> function is to get a list of all the C source
files in a directory, like this:
<P>
<PRE>
$(wildcard *.c)
</PRE>
<P>
We can change the list of C source files into a list of object files by
replacing the <SAMP>`.o'</SAMP> suffix with <SAMP>`.c'</SAMP> in the result, like this:
<P>
<PRE>
$(patsubst %.c,%.o,$(wildcard *.c))
</PRE>
<P>
(Here we have used another function, <CODE>patsubst</CODE>.
See section <A HREF="make_8.html#SEC73">Functions for String Substitution and Analysis</A>.)<P>
Thus, a makefile to compile all C source files in the directory and then
link them together could be written as follows:
<P>
<PRE>
objects := $(patsubst %.c,%.o,$(wildcard *.c))

foo : $(objects)
        cc -o foo $(objects)
</PRE>
<P>
(This takes advantage of the implicit rule for compiling C programs, so
there is no need to write explicit rules for compiling the files.
See section <A HREF="make_6.html#SEC57">The Two Flavors of Variables</A>, for an explanation of
<SAMP>`:='</SAMP>, which is a variant of <SAMP>`='</SAMP>.)
<P>
<A NAME="IDX132"></A>
<A NAME="IDX133"></A>
<A NAME="IDX134"></A>
<A NAME="IDX135"></A>
<A NAME="IDX136"></A>
<H2><A NAME="SEC25" HREF="make_toc.html#SEC25">Searching Directories for Dependencies</A></H2>
<P>
For large systems, it is often desirable to put sources in a separate
directory from the binaries.  The <DFN>directory search</DFN> features of
<CODE>make</CODE> facilitate this by searching several directories
automatically to find a dependency.  When you redistribute the files
among directories, you do not need to change the individual rules,
just the search paths.
<P>
<A NAME="IDX137"></A>
<H3><A NAME="SEC26" HREF="make_toc.html#SEC26"><CODE>VPATH</CODE>: Search Path for All Dependencies</A></H3>
<P>
The value of the <CODE>make</CODE> variable <CODE>VPATH</CODE> specifies a list of
directories that <CODE>make</CODE> should search.  Most often, the
directories are expected to contain dependency files that are not in the
current directory; however, <CODE>VPATH</CODE> specifies a search list that
<CODE>make</CODE> applies for all files, including files which are targets of
rules.
<P>
Thus, if a file that is listed as a target or dependency does not exist
in the current directory, <CODE>make</CODE> searches the directories listed in
<CODE>VPATH</CODE> for a file with that name.  If a file is found in one of
them, that file becomes the dependency.  Rules may then specify the
names of source files in the dependencies as if they all existed in the
current directory.  See section <A HREF="make_4.html#SEC28">Writing Shell Commands with Directory Search</A>.
<P>
In the <CODE>VPATH</CODE> variable, directory names are separated by colons or
blanks.  The order in which directories are listed is the order followed
by <CODE>make</CODE> in its search.
<P>
For example,
<P>
<PRE>
VPATH = src:../headers
</PRE>
<P>
specifies a path containing two directories, <TT>`src'</TT> and
<TT>`../headers'</TT>, which <CODE>make</CODE> searches in that order.
<P>
With this value of <CODE>VPATH</CODE>, the following rule,
<P>
<PRE>
foo.o : foo.c
</PRE>
<P>
is interpreted as if it were written like this:
<P>
<PRE>
foo.o : src/foo.c
</PRE>
<P>
assuming the file <TT>`foo.c'</TT> does not exist in the current directory but
is found in the directory <TT>`src'</TT>.
<P>
<A NAME="IDX138"></A>
<H3><A NAME="SEC27" HREF="make_toc.html#SEC27">The <CODE>vpath</CODE> Directive</A></H3>
<P>
Similar to the <CODE>VPATH</CODE> variable but more selective is the <CODE>vpath</CODE>
directive (note lower case), which allows you to specify a search path for a particular class
of file names, those that match a particular pattern.  Thus you can supply
certain search directories for one class of file names and other directories
(or none) for other file names.
<P>
There are three forms of the <CODE>vpath</CODE> directive:
<P>
<DL COMPACT>
<DT><CODE>vpath <VAR>pattern</VAR> <VAR>directories</VAR></CODE>
<DD>Specify the search path <VAR>directories</VAR> for file names that match
<VAR>pattern</VAR>.  
<P>
The search path, <VAR>directories</VAR>, is a list of directories to be
searched, separated by colons or blanks, just like the search path used
in the <CODE>VPATH</CODE> variable.
<P>
<DT><CODE>vpath <VAR>pattern</VAR></CODE>
<DD>Clear out the search path associated with <VAR>pattern</VAR>.
<P>
<DT><CODE>vpath</CODE>
<DD><P>
Clear all search paths previously specified with <CODE>vpath</CODE> directives.
</DL>
<P>
A <CODE>vpath</CODE> pattern is a string containing a <SAMP>`%'</SAMP> character.  The
string must match the file name of a dependency that is being searched
for, the <SAMP>`%'</SAMP> character matching any sequence of zero or more
characters (as in pattern rules; see section <A HREF="make_10.html#SEC91">Defining and Redefining Pattern Rules</A>).  For example, <CODE>%.h</CODE> matches files that
end in <CODE>.h</CODE>.  (If there is no <SAMP>`%'</SAMP>, the pattern must match the
dependency exactly, which is not useful very often.)
<A NAME="IDX139"></A>
<A NAME="IDX140"></A>
<A NAME="IDX141"></A>
<A NAME="IDX142"></A>
<A NAME="IDX143"></A>
<P>
<SAMP>`%'</SAMP> characters in a <CODE>vpath</CODE> directive's pattern can be quoted
with preceding backslashes (<SAMP>`\'</SAMP>).  Backslashes that would otherwise
quote <SAMP>`%'</SAMP> characters can be quoted with more backslashes.
Backslashes that quote <SAMP>`%'</SAMP> characters or other backslashes are
removed from the pattern before it is compared to file names.  Backslashes
that are not in danger of quoting <SAMP>`%'</SAMP> characters go unmolested.<P>
When a dependency fails to exist in the current directory, if the
<VAR>pattern</VAR> in a <CODE>vpath</CODE> directive matches the name of the
dependency file, then the <VAR>directories</VAR> in that directive are searched
just like (and before) the directories in the <CODE>VPATH</CODE> variable.  
<P>
For example,
<P>
<PRE>
vpath %.h ../headers
</PRE>
<P>
tells <CODE>make</CODE> to look for any dependency whose name ends in <TT>`.h'</TT>
in the directory <TT>`../headers'</TT> if the file is not found in the current
directory.
<P>
If several <CODE>vpath</CODE> patterns match the dependency file's name, then
<CODE>make</CODE> processes each matching <CODE>vpath</CODE> directive one by one,
searching all the directories mentioned in each directive.  <CODE>make</CODE>
handles multiple <CODE>vpath</CODE> directives in the order in which they
appear in the makefile; multiple directives with the same pattern are
independent of each other.
<P>
Thus, 
<P>
<PRE>
vpath %.c foo
vpath %   blish
vpath %.c bar
</PRE>
<P>
will look for a file ending in <SAMP>`.c'</SAMP> in <TT>`foo'</TT>, then
<TT>`blish'</TT>, then <TT>`bar'</TT>, while
<P>
<PRE>
vpath %.c foo:bar
vpath %   blish
</PRE>
<P>
will look for a file ending in <SAMP>`.c'</SAMP> in <TT>`foo'</TT>, then
<TT>`bar'</TT>, then <TT>`blish'</TT>.
<P>
<A NAME="IDX144"></A>
<A NAME="IDX145"></A>
<H3><A NAME="SEC28" HREF="make_toc.html#SEC28">Writing Shell Commands with Directory Search</A></H3>
<P>
When a dependency is found in another directory through directory search,
this cannot change the commands of the rule; they will execute as written.
Therefore, you must write the commands with care so that they will look for
the dependency in the directory where <CODE>make</CODE> finds it.
<P>
This is done with the <DFN>automatic variables</DFN> such as <SAMP>`$^'</SAMP>
(see section <A HREF="make_10.html#SEC94">Automatic Variables</A>).  
For instance, the value of <SAMP>`$^'</SAMP> is a
list of all the dependencies of the rule, including the names of
the directories in which they were found, and the value of
<SAMP>`$@'</SAMP> is the target.  Thus:<P>
<PRE>
foo.o : foo.c
        cc -c $(CFLAGS) $^ -o $@
</PRE>
<P>
(The variable <CODE>CFLAGS</CODE> exists so you can specify flags for C
compilation by implicit rules; we use it here for consistency so it will
affect all C compilations uniformly;
see section <A HREF="make_10.html#SEC89">Variables Used by Implicit Rules</A>.)
<P>
Often the dependencies include header files as well, which you do not
want to mention in the commands.  The automatic variable <SAMP>`$&#60;'</SAMP> is
just the first dependency:
<P>
<PRE>
VPATH = src:../headers
foo.o : foo.c defs.h hack.h
        cc -c $(CFLAGS) $&#60; -o $@
</PRE>
<P>
<A NAME="IDX146"></A>
<A NAME="IDX147"></A>
<A NAME="IDX148"></A>
<A NAME="IDX149"></A>
<A NAME="IDX150"></A>
<A NAME="IDX151"></A>
<A NAME="IDX152"></A>
<H3><A NAME="SEC29" HREF="make_toc.html#SEC29">Directory Search and Implicit Rules</A></H3>
<P>
The search through the directories specified in <CODE>VPATH</CODE> or with
<CODE>vpath</CODE> also happens during consideration of implicit rules
(see section <A HREF="make_10.html#SEC86">Using Implicit Rules</A>).
<P>
For example, when a file <TT>`foo.o'</TT> has no explicit rule, <CODE>make</CODE>
considers implicit rules, such as the built-in rule to compile
<TT>`foo.c'</TT> if that file exists.  If such a file is lacking in the
current directory, the appropriate directories are searched for it.  If
<TT>`foo.c'</TT> exists (or is mentioned in the makefile) in any of the
directories, the implicit rule for C compilation is applied.
<P>
The commands of implicit rules normally use automatic variables as a
matter of necessity; consequently they will use the file names found by
directory search with no extra effort.
<P>
<A NAME="IDX153"></A>
<A NAME="IDX154"></A>
<A NAME="IDX155"></A>
<A NAME="IDX156"></A>
<A NAME="IDX157"></A>
<A NAME="IDX158"></A>
<H3><A NAME="SEC30" HREF="make_toc.html#SEC30">Directory Search for Link Libraries</A></H3>
<P>
Directory search applies in a special way to libraries used with the
linker.  This special feature comes into play when you write a dependency
whose name is of the form <SAMP>`-l<VAR>name</VAR>'</SAMP>.  (You can tell something
strange is going on here because the dependency is normally the name of a
file, and the <EM>file name</EM> of the library looks like
<TT>`lib<VAR>name</VAR>.a'</TT>, not like <SAMP>`-l<VAR>name</VAR>'</SAMP>.)<P>
When a dependency's name has the form <SAMP>`-l<VAR>name</VAR>'</SAMP>, <CODE>make</CODE>
handles it specially by searching for the file <TT>`lib<VAR>name</VAR>.a'</TT> in
the current directory, in directories specified by matching <CODE>vpath</CODE>
search paths and the <CODE>VPATH</CODE> search path, and then in the
directories <TT>`/lib'</TT>, <TT>`/usr/lib'</TT>, and <TT>`<VAR>prefix</VAR>/lib'</TT>
(normally <TT>`/usr/local/lib'</TT>).
<P>
For example,
<P>
<PRE>
foo : foo.c -lcurses
        cc $^ -o $@
</PRE>
<P>
would cause the command <SAMP>`cc foo.c /usr/lib/libcurses.a -o foo'</SAMP> to
be executed when <TT>`foo'</TT> is older than <TT>`foo.c'</TT> or than
<TT>`/usr/lib/libcurses.a'</TT>.<P>
<A NAME="IDX159"></A>
<A NAME="IDX160"></A>
<A NAME="IDX161"></A>
<H2><A NAME="SEC31" HREF="make_toc.html#SEC31">Phony Targets</A></H2>
<P>
A phony target is one that is not really the name of a file.  It is just a
name for some commands to be executed when you make an explicit request.
There are two reasons to use a phony target: to avoid a conflict with
a file of the same name, and to improve performance.
<P>
If you write a rule whose commands will not create the target file, the
commands will be executed every time the target comes up for remaking.
Here is an example:
<P>
<PRE>
clean:
        rm *.o temp
</PRE>
<P>
Because the <CODE>rm</CODE> command does not create a file named <TT>`clean'</TT>,
probably no such file will ever exist.  Therefore, the <CODE>rm</CODE> command
will be executed every time you say <SAMP>`make clean'</SAMP>.
<A NAME="IDX162"></A>
<A NAME="IDX163"></A>
<P>
The phony target will cease to work if anything ever does create a file
named <TT>`clean'</TT> in this directory.  Since it has no dependencies, the
file <TT>`clean'</TT> would inevitably be considered up to date, and its
commands would not be executed.  To avoid this problem, you can explicitly
declare the target to be phony, using the special target <CODE>.PHONY</CODE>
(see section <A HREF="make_4.html#SEC34">Special Built-in Target Names</A>) as follows:
<P>
<PRE>
.PHONY : clean
</PRE>
<P>
Once this is done, <SAMP>`make clean'</SAMP> will run the commands regardless of
whether there is a file named <TT>`clean'</TT>.
<P>
Since it knows that phony targets do not name actual files that could be
remade from other files, <CODE>make</CODE> skips the implicit rule search for
phony targets (see section <A HREF="make_10.html#SEC86">Using Implicit Rules</A>).  This is why declaring a target
phony is good for performance, even if you are not worried about the
actual file existing.
<P>
Thus, you first write the line that states that <CODE>clean</CODE> is a
phony target, then you write the rule, like this:
<P>
<PRE>
.PHONY: clean
clean:
        rm *.o temp
</PRE>
<P>
A phony target should not be a dependency of a real target file; if it
is, its commands are run every time <CODE>make</CODE> goes to update that
file.  As long as a phony target is never a dependency of a real
target, the phony target commands will be executed only when the phony
target is a specified goal (see section <A HREF="make_9.html#SEC80">Arguments to Specify the Goals</A>).
<P>
Phony targets can have dependencies.  When one directory contains multiple
programs, it is most convenient to describe all of the programs in one
makefile <TT>`./Makefile'</TT>.  Since the target remade by default will be the
first one in the makefile, it is common to make this a phony target named
<SAMP>`all'</SAMP> and give it, as dependencies, all the individual programs.  For
example:
<P>
<PRE>
all : prog1 prog2 prog3
.PHONY : all

prog1 : prog1.o utils.o
        cc -o prog1 prog1.o utils.o

prog2 : prog2.o
        cc -o prog2 prog2.o

prog3 : prog3.o sort.o utils.o
        cc -o prog3 prog3.o sort.o utils.o
</PRE>
<P>
Now you can say just <SAMP>`make'</SAMP> to remake all three programs, or specify
as arguments the ones to remake (as in <SAMP>`make prog1 prog3'</SAMP>).
<P>
When one phony target is a dependency of another, it serves as a subroutine
of the other.  For example, here <SAMP>`make cleanall'</SAMP> will delete the
object files, the difference files, and the file <TT>`program'</TT>:
<P>
<PRE>
.PHONY: cleanall cleanobj cleandiff

cleanall : cleanobj cleandiff
        rm program

cleanobj :
        rm *.o

cleandiff :
        rm *.diff
</PRE>
<P>
<A NAME="IDX164"></A>
<A NAME="IDX165"></A>
<A NAME="IDX166"></A>
<A NAME="IDX167"></A>
<H2><A NAME="SEC32" HREF="make_toc.html#SEC32">Rules without Commands or Dependencies</A></H2>
<P>
If a rule has no dependencies or commands, and the target of the rule
is a nonexistent file, then <CODE>make</CODE> imagines this target to have
been updated whenever its rule is run.  This implies that all targets
depending on this one will always have their commands run.
<P>
An example will illustrate this:
<P>
<PRE>
clean: FORCE
        rm $(objects)
FORCE:
</PRE>
<P>
Here the target <SAMP>`FORCE'</SAMP> satisfies the special conditions, so the
target <TT>`clean'</TT> that depends on it is forced to run its commands.
There is nothing special about the name <SAMP>`FORCE'</SAMP>, but that is one name
commonly used this way.
<P>
As you can see, using <SAMP>`FORCE'</SAMP> this way has the same results as using
<SAMP>`.PHONY: clean'</SAMP>.  
<P>
Using <SAMP>`.PHONY'</SAMP> is more explicit and more efficient.  However,
other versions of <CODE>make</CODE> do not support <SAMP>`.PHONY'</SAMP>; thus
<SAMP>`FORCE'</SAMP> appears in many makefiles.  See section <A HREF="make_4.html#SEC31">Phony Targets</A>.
<P>
<A NAME="IDX168"></A>
<A NAME="IDX169"></A>
<A NAME="IDX170"></A>
<H2><A NAME="SEC33" HREF="make_toc.html#SEC33">Empty Target Files to Record Events</A></H2>
<P>
The <DFN>empty target</DFN> is a variant of the phony target; it is used to hold
commands for an action that you request explicitly from time to time.
Unlike a phony target, this target file can really exist; but the file's
contents do not matter, and usually are empty.
<P>
The purpose of the empty target file is to record, with its
last-modification time, when the rule's commands were last executed.  It
does so because one of the commands is a <CODE>touch</CODE> command to update the
target file.
<P>
The empty target file must have some dependencies.  When you ask to remake
the empty target, the commands are executed if any dependency is more
recent than the target; in other words, if a dependency has changed since
the last time you remade the target.  Here is an example:
<P>
<PRE>
print: foo.c bar.c
        lpr -p $?
        touch print
<A NAME="IDX171"></A>
<A NAME="IDX172"></A>
<A NAME="IDX173"></A>
</PRE>
<P>
With this rule, <SAMP>`make print'</SAMP> will execute the <CODE>lpr</CODE> command if
either source file has changed since the last <SAMP>`make print'</SAMP>.  The
automatic variable <SAMP>`$?'</SAMP> is used to print only those files that have
changed (see section <A HREF="make_10.html#SEC94">Automatic Variables</A>).
<P>
<A NAME="IDX174"></A>
<A NAME="IDX175"></A>
<A NAME="IDX176"></A>
<H2><A NAME="SEC34" HREF="make_toc.html#SEC34">Special Built-in Target Names</A></H2>
<P>
Certain names have special meanings if they appear as targets.
<P>
<A NAME="IDX177"></A>
<DL COMPACT>
<DT><CODE>.PHONY</CODE>
<DD><P>
The dependencies of the special target <CODE>.PHONY</CODE> are considered to
be phony targets.  When it is time to consider such a target,
<CODE>make</CODE> will run its commands unconditionally, regardless of
whether a file with that name exists or what its last-modification
time is.  See section <A HREF="make_4.html#SEC31">Phony Targets</A>.
<A NAME="IDX178"></A>
<P>
<DT><CODE>.SUFFIXES</CODE>
<DD><P>
The dependencies of the special target <CODE>.SUFFIXES</CODE> are the list
of suffixes to be used in checking for suffix rules.  
See section <A HREF="make_10.html#SEC99">Old-Fashioned Suffix Rules</A>.
<A NAME="IDX179"></A>
<P>
<DT><CODE>.DEFAULT</CODE>
<DD><P>
The commands specified for <CODE>.DEFAULT</CODE> are used for any target for
which no rules are found (either explicit rules or implicit rules).
See section <A HREF="make_10.html#SEC98">Defining Last-Resort Default Rules</A>.  If <CODE>.DEFAULT</CODE> commands are specified, every
file mentioned as a dependency, but not as a target in a rule, will have
these commands executed on its behalf.  See section <A HREF="make_10.html#SEC100">Implicit Rule Search Algorithm</A>.
<A NAME="IDX180"></A>
<P>
<A NAME="IDX181"></A>
<A NAME="IDX182"></A>
<DT><CODE>.PRECIOUS</CODE>
<DD><P>
The targets which <CODE>.PRECIOUS</CODE> depends on are given the following
special treatment: if <CODE>make</CODE> is killed or interrupted during the
execution of their commands, the target is not deleted.
See section <A HREF="make_5.html#SEC47">Interrupting or Killing <CODE>make</CODE></A>.
Also, if the target is an intermediate file, it will not be deleted
after it is no longer needed, as is normally done.
See section <A HREF="make_10.html#SEC90">Chains of Implicit Rules</A>.
<P>
You can also list the target pattern of an implicit rule (such as
<SAMP>`%.o'</SAMP>) as a dependency file of the special target <CODE>.PRECIOUS</CODE>
to preserve intermediate files created by rules whose target patterns
match that file's name.
<A NAME="IDX183"></A>
<P>
<DT><CODE>.IGNORE</CODE>
<DD><P>
If you specify dependencies for <CODE>.IGNORE</CODE>, then <CODE>make</CODE> will
ignore errors in execution of the commands run for those particular
files.  The commands for <CODE>.IGNORE</CODE> are not meaningful.
<P>
If mentioned as a target with no dependencies, <CODE>.IGNORE</CODE> says to
ignore errors in execution of commands for all files.  This usage of
<SAMP>`.IGNORE'</SAMP> is supported only for historical compatibility.  Since
this affects every command in the makefile, it is not very useful; we
recommend you use the more selective ways to ignore errors in specific
commands.  See section <A HREF="make_5.html#SEC46">Errors in Commands</A>.
<A NAME="IDX184"></A>
<P>
<DT><CODE>.SILENT</CODE>
<DD><P>
If you specify dependencies for <CODE>.SILENT</CODE>, then <CODE>make</CODE> will
not the print commands to remake those particular files before executing
them.  The commands for <CODE>.SILENT</CODE> are not meaningful.
<P>
If mentioned as a target with no dependencies, <CODE>.SILENT</CODE> says not
to print any commands before executing them.  This usage of
<SAMP>`.SILENT'</SAMP> is supported only for historical compatibility.  We
recommend you use the more selective ways to silence specific commands.
See section <A HREF="make_5.html#SEC43">Command Echoing</A>.  If you want to silence all commands
for a particular run of <CODE>make</CODE>, use the <SAMP>`-s'</SAMP> or
<SAMP>`--silent'</SAMP> option (see section <A HREF="make_9.html#SEC85">Summary of Options</A>).
<A NAME="IDX185"></A>
<P>
<DT><CODE>.EXPORT_ALL_VARIABLES</CODE>
<DD><P>
Simply by being mentioned as a target, this tells <CODE>make</CODE> to
export all variables to child processes by default.
See section <A HREF="make_5.html#SEC50">Communicating Variables to a Sub-<CODE>make</CODE></A>}.
</DL>
<P>
Any defined implicit rule suffix also counts as a special target if it
appears as a target, and so does the concatenation of two suffixes, such
as <SAMP>`.c.o'</SAMP>.  These targets are suffix rules, an obsolete way of
defining implicit rules (but a way still widely used).  In principle, any
target name could be special in this way if you break it in two and add
both pieces to the suffix list.  In practice, suffixes normally begin with
<SAMP>`.'</SAMP>, so these special target names also begin with <SAMP>`.'</SAMP>.
See section <A HREF="make_10.html#SEC99">Old-Fashioned Suffix Rules</A>.
<P>
<A NAME="IDX186"></A>
<A NAME="IDX187"></A>
<A NAME="IDX188"></A>
<A NAME="IDX189"></A>
<H2><A NAME="SEC35" HREF="make_toc.html#SEC35">Multiple Targets in a Rule</A></H2>
<P>
A rule with multiple targets is equivalent to writing many rules, each with
one target, and all identical aside from that.  The same commands apply to
all the targets, but their effects may vary because you can substitute the
actual target name into the command using <SAMP>`$@'</SAMP>.  The rule contributes
the same dependencies to all the targets also.
<P>
This is useful in two cases.
<P>
<UL>
<LI>
You want just dependencies, no commands.  For example:
<P>
<PRE>
kbd.o command.o files.o: command.h
</PRE>
<P>
gives an additional dependency to each of the three object files
mentioned.
<P>
<LI>
Similar commands work for all the targets.  The commands do not need
to be absolutely identical, since the automatic variable <SAMP>`$@'</SAMP>
can be used to substitute the particular target to be remade into the
commands (see section <A HREF="make_10.html#SEC94">Automatic Variables</A>).  For example:
<P>
<PRE>
bigoutput littleoutput : text.g
        generate text.g -$(subst output,,$@) &#62; $@
<A NAME="IDX190"></A>
</PRE>
<P>
is equivalent to
<P>
<PRE>
bigoutput : text.g
        generate text.g -big &#62; bigoutput
littleoutput : text.g
        generate text.g -little &#62; littleoutput
</PRE>
<P>
Here we assume the hypothetical program <CODE>generate</CODE> makes two
types of output, one if given <SAMP>`-big'</SAMP> and one if given
<SAMP>`-little'</SAMP>.
See section <A HREF="make_8.html#SEC73">Functions for String Substitution and Analysis</A>,
for an explanation of the <CODE>subst</CODE> function.
</UL>
<P>
Suppose you would like to vary the dependencies according to the target,
much as the variable <SAMP>`$@'</SAMP> allows you to vary the commands.
You cannot do this with multiple targets in an ordinary rule, but you can
do it with a <DFN>static pattern rule</DFN>.
See section <A HREF="make_4.html#SEC37">Static Pattern Rules</A>.
<P>
<A NAME="IDX191"></A>
<A NAME="IDX192"></A>
<A NAME="IDX193"></A>
<A NAME="IDX194"></A>
<H2><A NAME="SEC36" HREF="make_toc.html#SEC36">Multiple Rules for One Target</A></H2>
<P>
One file can be the target of several rules.  All the dependencies
mentioned in all the rules are merged into one list of dependencies for
the target.  If the target is older than any dependency from any rule,
the commands are executed.
<P>
There can only be one set of commands to be executed for a file.
If more than one rule gives commands for the same file, 
<CODE>make</CODE> uses the last set given and prints an error message.
(As a special case, if the file's name begins with a dot, no
error message is printed.  This odd behavior is only for
compatibility with other implementations of <CODE>make</CODE>.)  
There is no reason to
write your makefiles this way; that is why <CODE>make</CODE> gives you
an error message.<P>
An extra rule with just dependencies can be used to give a few extra
dependencies to many files at once.  For example, one usually has a
variable named <CODE>objects</CODE> containing a list of all the compiler output
files in the system being made.  An easy way to say that all of them must
be recompiled if <TT>`config.h'</TT> changes is to write the following:
<P>
<PRE>
objects = foo.o bar.o
foo.o : defs.h
bar.o : defs.h test.h
$(objects) : config.h
</PRE>
<P>
This could be inserted or taken out without changing the rules that really
specify how to make the object files, making it a convenient form to use if
you wish to add the additional dependency intermittently.
<P>
Another wrinkle is that the additional dependencies could be specified with
a variable that you set with a command argument to <CODE>make</CODE>
(see section <A HREF="make_9.html#SEC83">Overriding Variables</A>).  For example,
<P>
<PRE>
extradeps=
$(objects) : $(extradeps)
</PRE>
<P>
means that the command <SAMP>`make extradeps=foo.h'</SAMP> will consider
<TT>`foo.h'</TT> as a dependency of each object file, but plain <SAMP>`make'</SAMP>
will not.
<P>
If none of the explicit rules for a target has commands, then <CODE>make</CODE>
searches for an applicable implicit rule to find some commands
see section <A HREF="make_10.html#SEC86">Using Implicit Rules</A>).
<P>
<A NAME="IDX195"></A>
<A NAME="IDX196"></A>
<A NAME="IDX197"></A>
<A NAME="IDX198"></A>
<A NAME="IDX199"></A>
<H2><A NAME="SEC37" HREF="make_toc.html#SEC37">Static Pattern Rules</A></H2>
<P>
<DFN>Static pattern rules</DFN> are rules which specify multiple targets and
construct the dependency names for each target based on the target name.
They are more general than ordinary rules with multiple targets because the
targets do not have to have identical dependencies.  Their dependencies must
be <EM>analogous</EM>, but not necessarily <EM>identical</EM>.
<P>
<A NAME="IDX200"></A>
<A NAME="IDX201"></A>
<H3><A NAME="SEC38" HREF="make_toc.html#SEC38">Syntax of Static Pattern Rules</A></H3>
<P>
Here is the syntax of a static pattern rule:
<P>
<PRE>
<VAR>targets</VAR> ...: <VAR>target-pattern</VAR>: <VAR>dep-patterns</VAR> ...
        <VAR>commands</VAR>
        ...
</PRE>
<P>
The <VAR>targets</VAR> list specifies the targets that the rule applies to.
The targets can contain wildcard characters, just like the targets of
ordinary rules (see section <A HREF="make_4.html#SEC21">Using Wildcard Characters in File Names</A>).
<A NAME="IDX202"></A>
<A NAME="IDX203"></A>
<P>
The <VAR>target-pattern</VAR> and <VAR>dep-patterns</VAR> say how to compute the
dependencies of each target.  Each target is matched against the
<VAR>target-pattern</VAR> to extract a part of the target name, called the
<DFN>stem</DFN>.  This stem is substituted into each of the <VAR>dep-patterns</VAR>
to make the dependency names (one from each <VAR>dep-pattern</VAR>).
<P>
Each pattern normally contains the character <SAMP>`%'</SAMP> just once.  When the
<VAR>target-pattern</VAR> matches a target, the <SAMP>`%'</SAMP> can match any part of
the target name; this part is called the <DFN>stem</DFN>.  The rest of the
pattern must match exactly.  For example, the target <TT>`foo.o'</TT> matches
the pattern <SAMP>`%.o'</SAMP>, with <SAMP>`foo'</SAMP> as the stem.  The targets
<TT>`foo.c'</TT> and <TT>`foo.out'</TT> do not match that pattern.<A NAME="IDX204"></A>
<P>
The dependency names for each target are made by substituting the stem
for the <SAMP>`%'</SAMP> in each dependency pattern.  For example, if one
dependency pattern is <TT>`%.c'</TT>, then substitution of the stem
<SAMP>`foo'</SAMP> gives the dependency name <TT>`foo.c'</TT>.  It is legitimate
to write a dependency pattern that does not contain <SAMP>`%'</SAMP>; then this
dependency is the same for all targets.
<A NAME="IDX205"></A>
<A NAME="IDX206"></A>
<A NAME="IDX207"></A>
<A NAME="IDX208"></A>
<A NAME="IDX209"></A>
<P>
<SAMP>`%'</SAMP> characters in pattern rules can be quoted with preceding
backslashes (<SAMP>`\'</SAMP>).  Backslashes that would otherwise quote <SAMP>`%'</SAMP>
characters can be quoted with more backslashes.  Backslashes that quote
<SAMP>`%'</SAMP> characters or other backslashes are removed from the pattern
before it is compared to file names or has a stem substituted into it.
Backslashes that are not in danger of quoting <SAMP>`%'</SAMP> characters go
unmolested.  For example, the pattern <TT>`the\%weird\\%pattern\\'</TT> has
<SAMP>`the%weird\'</SAMP> preceding the operative <SAMP>`%'</SAMP> character, and
<SAMP>`pattern\\'</SAMP> following it.  The final two backslashes are left alone
because they cannot affect any <SAMP>`%'</SAMP> character.<P>
Here is an example, which compiles each of <TT>`foo.o'</TT> and <TT>`bar.o'</TT>
from the corresponding <TT>`.c'</TT> file:
<P>
<PRE>
objects = foo.o bar.o

$(objects): %.o: %.c
        $(CC) -c $(CFLAGS) $&#60; -o $@
</PRE>
<P>
Here <SAMP>`$&#60;'</SAMP> is the automatic variable that holds the name of the
dependency and <SAMP>`$@'</SAMP> is the automatic variable that holds the name
of the target; see section <A HREF="make_10.html#SEC94">Automatic Variables</A>.
<P>
Each target specified must match the target pattern; a warning is issued
for each target that does not.  If you have a list of files, only some of
which will match the pattern, you can use the <CODE>filter</CODE> function to
remove nonmatching file names (see section <A HREF="make_8.html#SEC73">Functions for String Substitution and Analysis</A>):
<P>
<PRE>
files = foo.elc bar.o lose.o

$(filter %.o,$(files)): %.o: %.c
        $(CC) -c $(CFLAGS) $&#60; -o $@
$(filter %.elc,$(files)): %.elc: %.el
        emacs -f batch-byte-compile $&#60;
</PRE>
<P>
In this example the result of <SAMP>`$(filter %.o,$(files))'</SAMP> is
<TT>`bar.o lose.o'</TT>, and the first static pattern rule causes each of
these object files to be updated by compiling the corresponding C source
file.  The result of <SAMP>`$(filter %.elc,$(files))'</SAMP> is
<TT>`foo.elc'</TT>, so that file is made from <TT>`foo.el'</TT>.<P>
Another example shows how to use <CODE>$*</CODE> in static pattern rules:
<A NAME="IDX210"></A>
<P>
<PRE>
bigoutput littleoutput : %output : text.g
        generate text.g -$* &#62; $@
</PRE>
<P>
When the <CODE>generate</CODE> command is run, <CODE>$*</CODE> will expand to the
stem, either <SAMP>`big'</SAMP> or <SAMP>`little'</SAMP>.
<P>
<A NAME="IDX211"></A>
<A NAME="IDX212"></A>
<H3><A NAME="SEC39" HREF="make_toc.html#SEC39">Static Pattern Rules versus Implicit Rules</A></H3>
<P>
A static pattern rule has much in common with an implicit rule defined as a
pattern rule (see section <A HREF="make_10.html#SEC91">Defining and Redefining Pattern Rules</A>).
Both have a pattern for the target and patterns for constructing the
names of dependencies.  The difference is in how <CODE>make</CODE> decides
<EM>when</EM> the rule applies.
<P>
An implicit rule <EM>can</EM> apply to any target that matches its pattern,
but it <EM>does</EM> apply only when the target has no commands otherwise
specified, and only when the dependencies can be found.  If more than one
implicit rule appears applicable, only one applies; the choice depends on
the order of rules.
<P>
By contrast, a static pattern rule applies to the precise list of targets
that you specify in the rule.  It cannot apply to any other target and it
invariably does apply to each of the targets specified.  If two conflicting
rules apply, and both have commands, that's an error.
<P>
The static pattern rule can be better than an implicit rule for these
reasons:
<P>
<UL>
<LI>
You may wish to override the usual implicit rule for a few
files whose names cannot be categorized syntactically but
can be given in an explicit list.
<P>
<LI>
If you cannot be sure of the precise contents of the directories
you are using, you may not be sure which other irrelevant files
might lead <CODE>make</CODE> to use the wrong implicit rule.  The choice
might depend on the order in which the implicit rule search is done.
With static pattern rules, there is no uncertainty: each rule applies
to precisely the targets specified.
</UL>
<P>
<A NAME="IDX213"></A>
<A NAME="IDX214"></A>
<A NAME="IDX215"></A>
<A NAME="IDX216"></A>
<H2><A NAME="SEC40" HREF="make_toc.html#SEC40">Double-Colon Rules</A></H2>
<P>
<DFN>Double-colon</DFN> rules are rules written with <SAMP>`::'</SAMP> instead of
<SAMP>`:'</SAMP> after the target names.  They are handled differently from
ordinary rules when the same target appears in more than one rule.
<P>
When a target appears in multiple rules, all the rules must be the same
type: all ordinary, or all double-colon.  If they are double-colon, each of
them is independent of the others.  Each double-colon rule's commands are
executed if the target is older than any dependencies of that rule.  This
can result in executing none, any, or all of the double-colon rules.
<P>
Double-colon rules with the same target are in fact completely separate
from one another.  Each double-colon rule is processed individually, just
as rules with different targets are processed.
<P>
The double-colon rules for a target are executed in the order they appear
in the makefile.  However, the cases where double-colon rules really make
sense are those where the order of executing the commands would not matter.
<P>
Double-colon rules are somewhat obscure and not often very useful; they
provide a mechanism for cases in which the method used to update a target
differs depending on which dependency files caused the update, and such
cases are rare.
<P>
Each double-colon rule should specify commands; if it does not, an
implicit rule will be used if one applies.  
See section <A HREF="make_10.html#SEC86">Using Implicit Rules</A>.
<P>
<A NAME="IDX217"></A>
<A NAME="IDX218"></A>
<A NAME="IDX219"></A>
<H2><A NAME="SEC41" HREF="make_toc.html#SEC41">Generating Dependencies Automatically</A></H2>
<P>
In the makefile for a program, many of the rules you need to write often
say only that some object file depends on some header
file.  For example, if <TT>`main.c'</TT> uses <TT>`defs.h'</TT> via an
<CODE>#include</CODE>, you would write:
<P>
<PRE>
main.o: defs.h
</PRE>
<P>
You need this rule so that <CODE>make</CODE> knows that it must remake
<TT>`main.o'</TT> whenever <TT>`defs.h'</TT> changes.  You can see that for a
large program you would have to write dozens of such rules in your
makefile.  And, you must always be very careful to update the makefile
every time you add or remove an <CODE>#include</CODE>.
<A NAME="IDX220"></A>
<A NAME="IDX221"></A>
<P>
To avoid this hassle, most modern C compilers can write these rules for
you, by looking at the <CODE>#include</CODE> lines in the source files.
Usually this is done with the <SAMP>`-M'</SAMP> option to the compiler.
For example, the command:
<P>
<PRE>
cc -M main.c
</PRE>
<P>
generates the output:
<P>
<PRE>
main.o : main.c defs.h
</PRE>
<P>
Thus you no longer have to write all those rules yourself.
The compiler will do it for you.
<P>
Note that such a dependency constitutes mentioning <TT>`main.o'</TT> in a
makefile, so it can never be considered an intermediate file by implicit
rule search.  This means that <CODE>make</CODE> won't ever remove the file
after using it; see section <A HREF="make_10.html#SEC90">Chains of Implicit Rules</A>.
<A NAME="IDX222"></A>
<P>
With old <CODE>make</CODE> programs, it was traditional practice to use this
compiler feature to generate dependencies on demand with a command like
<SAMP>`make depend'</SAMP>.  That command would create a file <TT>`depend'</TT>
containing all the automatically-generated dependencies; then the
makefile could use <CODE>include</CODE> to read them in (see section <A HREF="make_3.html#SEC15">Including Other Makefiles</A>).
<P>
In GNU <CODE>make</CODE>, the feature of remaking makefiles makes this
practice obsolete--you need never tell <CODE>make</CODE> explicitly to
regenerate the dependencies, because it always regenerates any makefile
that is out of date.  See section <A HREF="make_3.html#SEC17">How Makefiles Are Remade</A>.
<P>
The practice we recommend for automatic dependency generation is to have
one makefile corresponding to each source file.  For each source file
<TT>`<VAR>name</VAR>.c'</TT> there is a makefile <TT>`<VAR>name</VAR>.d'</TT> which lists
what files the object file <TT>`<VAR>name</VAR>.o'</TT> depends on.  That way
only the source files that have changed need to be rescanned to produce
the new dependencies.
<P>
Here is the pattern rule to generate a file of dependencies (i.e., a makefile)
called <TT>`<VAR>name</VAR>.d'</TT> from a C source file called <TT>`<VAR>name</VAR>.c'</TT>:
<P>
<PRE>
%.d: %.c
        $(SHELL) -ec '$(CC) -M $(CPPFLAGS) $&#60; \
                      | sed '\"s/$*\\.o[ :]*/&#38; $@/g'\" &#62; $@'
</PRE>
<P>
See section <A HREF="make_10.html#SEC91">Defining and Redefining Pattern Rules</A>, for information on defining pattern rules.  The
<SAMP>`-e'</SAMP> flag to the shell makes it exit immediately if the
<CODE>$(CC)</CODE> command fails (exits with a nonzero status).  Normally the
shell exits with the status of the last command in the pipeline
(<CODE>sed</CODE> in this case), so <CODE>make</CODE> would not notice a nonzero
status from the compiler.
<A NAME="IDX223"></A>
<A NAME="IDX224"></A>
<P>
With the GNU C compiler, you may wish to use the <SAMP>`-MM'</SAMP> flag instead
of <SAMP>`-M'</SAMP>.  This omits dependencies on system header files.
See section `Options Controlling the Preprocessor' in <CITE>Using GNU CC</CITE>, for details.
<A NAME="IDX225"></A>
<P>
The purpose of the <CODE>sed</CODE> command is to translate (for example):
<P>
<PRE>
main.o : main.c defs.h
</PRE>
<P>
into:
<P>
<PRE>
main.o main.d : main.c defs.h
</PRE>
<P>
<A NAME="IDX226"></A>
This makes each <SAMP>`.d'</SAMP> file depend on all the source and header files
that the corresponding <SAMP>`.o'</SAMP> file depends on.  <CODE>make</CODE> then
knows it must regenerate the dependencies whenever any of the source or
header files changes.
<P>
Once you've defined the rule to remake the <SAMP>`.d'</SAMP> files,
you then use the <CODE>include</CODE> directive to read them all in.
See section <A HREF="make_3.html#SEC15">Including Other Makefiles</A>.  For example:
<P>
<PRE>
sources = foo.c bar.c

include $(sources:.c=.d)
</PRE>
<P>
(This example uses a substitution variable reference to translate the
list of source files <SAMP>`foo.c bar.c'</SAMP> into a list of dependency
makefiles, <SAMP>`foo.d bar.d'</SAMP>.  See section <A HREF="make_6.html#SEC59">Substitution References</A>, for full
information on substitution references.)  Since the <SAMP>`.d'</SAMP> files are
makefiles like any others, <CODE>make</CODE> will remake them as necessary
with no further work from you.  See section <A HREF="make_3.html#SEC17">How Makefiles Are Remade</A>.
<P>
<P>Go to the <A HREF="make_3.html">previous</A>, <A HREF="make_5.html">next</A> section.<P>
