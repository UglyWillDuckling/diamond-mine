/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  };
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/obsidian-daily-notes-interface/dist/main.js
var require_main = __commonJS({
  "node_modules/obsidian-daily-notes-interface/dist/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var obsidian = require("obsidian");
    var DEFAULT_DAILY_NOTE_FORMAT = "YYYY-MM-DD";
    var DEFAULT_WEEKLY_NOTE_FORMAT = "gggg-[W]ww";
    var DEFAULT_MONTHLY_NOTE_FORMAT = "YYYY-MM";
    var DEFAULT_QUARTERLY_NOTE_FORMAT = "YYYY-[Q]Q";
    var DEFAULT_YEARLY_NOTE_FORMAT = "YYYY";
    function shouldUsePeriodicNotesSettings(periodicity) {
      var _a, _b;
      const periodicNotes = window.app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a[periodicity]) == null ? void 0 : _b.enabled);
    }
    function getDailyNoteSettings() {
      var _a, _b, _c, _d;
      try {
        const { internalPlugins, plugins } = window.app;
        if (shouldUsePeriodicNotesSettings("daily")) {
          const { format: format3, folder: folder2, template: template2 } = ((_b = (_a = plugins.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.daily) || {};
          return {
            format: format3 || DEFAULT_DAILY_NOTE_FORMAT,
            folder: (folder2 == null ? void 0 : folder2.trim()) || "",
            template: (template2 == null ? void 0 : template2.trim()) || ""
          };
        }
        const { folder, format: format2, template } = ((_d = (_c = internalPlugins.getPluginById("daily-notes")) == null ? void 0 : _c.instance) == null ? void 0 : _d.options) || {};
        return {
          format: format2 || DEFAULT_DAILY_NOTE_FORMAT,
          folder: (folder == null ? void 0 : folder.trim()) || "",
          template: (template == null ? void 0 : template.trim()) || ""
        };
      } catch (err) {
        console.info("No custom daily note settings found!", err);
      }
    }
    function getWeeklyNoteSettings() {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pluginManager = window.app.plugins;
        const calendarSettings = (_a = pluginManager.getPlugin("calendar")) == null ? void 0 : _a.options;
        const periodicNotesSettings = (_c = (_b = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _b.settings) == null ? void 0 : _c.weekly;
        if (shouldUsePeriodicNotesSettings("weekly")) {
          return {
            format: periodicNotesSettings.format || DEFAULT_WEEKLY_NOTE_FORMAT,
            folder: ((_d = periodicNotesSettings.folder) == null ? void 0 : _d.trim()) || "",
            template: ((_e = periodicNotesSettings.template) == null ? void 0 : _e.trim()) || ""
          };
        }
        const settings2 = calendarSettings || {};
        return {
          format: settings2.weeklyNoteFormat || DEFAULT_WEEKLY_NOTE_FORMAT,
          folder: ((_f = settings2.weeklyNoteFolder) == null ? void 0 : _f.trim()) || "",
          template: ((_g = settings2.weeklyNoteTemplate) == null ? void 0 : _g.trim()) || ""
        };
      } catch (err) {
        console.info("No custom weekly note settings found!", err);
      }
    }
    function getMonthlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings2 = shouldUsePeriodicNotesSettings("monthly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.monthly) || {};
        return {
          format: settings2.format || DEFAULT_MONTHLY_NOTE_FORMAT,
          folder: ((_c = settings2.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings2.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom monthly note settings found!", err);
      }
    }
    function getQuarterlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings2 = shouldUsePeriodicNotesSettings("quarterly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.quarterly) || {};
        return {
          format: settings2.format || DEFAULT_QUARTERLY_NOTE_FORMAT,
          folder: ((_c = settings2.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings2.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom quarterly note settings found!", err);
      }
    }
    function getYearlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings2 = shouldUsePeriodicNotesSettings("yearly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.yearly) || {};
        return {
          format: settings2.format || DEFAULT_YEARLY_NOTE_FORMAT,
          folder: ((_c = settings2.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings2.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom yearly note settings found!", err);
      }
    }
    function join(...partSegments) {
      let parts = [];
      for (let i = 0, l = partSegments.length; i < l; i++) {
        parts = parts.concat(partSegments[i].split("/"));
      }
      const newParts = [];
      for (let i = 0, l = parts.length; i < l; i++) {
        const part = parts[i];
        if (!part || part === ".")
          continue;
        else
          newParts.push(part);
      }
      if (parts[0] === "")
        newParts.unshift("");
      return newParts.join("/");
    }
    function basename(fullPath) {
      let base = fullPath.substring(fullPath.lastIndexOf("/") + 1);
      if (base.lastIndexOf(".") != -1)
        base = base.substring(0, base.lastIndexOf("."));
      return base;
    }
    async function ensureFolderExists(path) {
      const dirs = path.replace(/\\/g, "/").split("/");
      dirs.pop();
      if (dirs.length) {
        const dir = join(...dirs);
        if (!window.app.vault.getAbstractFileByPath(dir)) {
          await window.app.vault.createFolder(dir);
        }
      }
    }
    async function getNotePath(directory, filename) {
      if (!filename.endsWith(".md")) {
        filename += ".md";
      }
      const path = obsidian.normalizePath(join(directory, filename));
      await ensureFolderExists(path);
      return path;
    }
    async function getTemplateInfo(template) {
      const { metadataCache, vault } = window.app;
      const templatePath = obsidian.normalizePath(template);
      if (templatePath === "/") {
        return Promise.resolve(["", null]);
      }
      try {
        const templateFile = metadataCache.getFirstLinkpathDest(templatePath, "");
        const contents = await vault.cachedRead(templateFile);
        const IFoldInfo = window.app.foldManager.load(templateFile);
        return [contents, IFoldInfo];
      } catch (err) {
        console.error(`Failed to read the daily note template '${templatePath}'`, err);
        new obsidian.Notice("Failed to read the daily note template");
        return ["", null];
      }
    }
    function getDateUID(date, granularity = "day") {
      const ts = date.clone().startOf(granularity).format();
      return `${granularity}-${ts}`;
    }
    function removeEscapedCharacters(format2) {
      return format2.replace(/\[[^\]]*\]/g, "");
    }
    function isFormatAmbiguous(format2, granularity) {
      if (granularity === "week") {
        const cleanFormat = removeEscapedCharacters(format2);
        return /w{1,2}/i.test(cleanFormat) && (/M{1,4}/.test(cleanFormat) || /D{1,4}/.test(cleanFormat));
      }
      return false;
    }
    function getDateFromFile(file, granularity) {
      return getDateFromFilename(file.basename, granularity);
    }
    function getDateFromPath(path, granularity) {
      return getDateFromFilename(basename(path), granularity);
    }
    function getDateFromFilename(filename, granularity) {
      const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      };
      const format2 = getSettings[granularity]().format.split("/").pop();
      const noteDate = window.moment(filename, format2, true);
      if (!noteDate.isValid()) {
        return null;
      }
      if (isFormatAmbiguous(format2, granularity)) {
        if (granularity === "week") {
          const cleanFormat = removeEscapedCharacters(format2);
          if (/w{1,2}/i.test(cleanFormat)) {
            return window.moment(filename, format2.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""), false);
          }
        }
      }
      return noteDate;
    }
    var DailyNotesFolderMissingError = class extends Error {
    };
    async function createDailyNote2(date) {
      const app = window.app;
      const { vault } = app;
      const moment = window.moment;
      const { template, format: format2, folder } = getDailyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*yesterday\s*}}/gi, date.clone().subtract(1, "day").format(format2)).replace(/{{\s*tomorrow\s*}}/gi, date.clone().add(1, "d").format(format2)));
        app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getDailyNote2(date, dailyNotes) {
      var _a;
      return (_a = dailyNotes[getDateUID(date, "day")]) != null ? _a : null;
    }
    function getAllDailyNotes2() {
      const { vault } = window.app;
      const { folder } = getDailyNoteSettings();
      const dailyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!dailyNotesFolder) {
        throw new DailyNotesFolderMissingError("Failed to find daily notes folder");
      }
      const dailyNotes = {};
      obsidian.Vault.recurseChildren(dailyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "day");
          if (date) {
            const dateString = getDateUID(date, "day");
            dailyNotes[dateString] = note;
          }
        }
      });
      return dailyNotes;
    }
    var WeeklyNotesFolderMissingError = class extends Error {
    };
    function getDaysOfWeek() {
      const { moment } = window;
      let weekStart = moment.localeData()._week.dow;
      const daysOfWeek = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
      ];
      while (weekStart) {
        daysOfWeek.push(daysOfWeek.shift());
        weekStart--;
      }
      return daysOfWeek;
    }
    function getDayOfWeekNumericalValue(dayOfWeekName) {
      return getDaysOfWeek().indexOf(dayOfWeekName.toLowerCase());
    }
    async function createWeeklyNote2(date) {
      const { vault } = window.app;
      const { template, format: format2, folder } = getWeeklyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = window.moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (_, dayOfWeek, momentFormat) => {
          const day = getDayOfWeekNumericalValue(dayOfWeek);
          return date.weekday(day).format(momentFormat.trim());
        }));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getWeeklyNote2(date, weeklyNotes) {
      var _a;
      return (_a = weeklyNotes[getDateUID(date, "week")]) != null ? _a : null;
    }
    function getAllWeeklyNotes2() {
      const weeklyNotes = {};
      if (!appHasWeeklyNotesPluginLoaded2()) {
        return weeklyNotes;
      }
      const { vault } = window.app;
      const { folder } = getWeeklyNoteSettings();
      const weeklyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!weeklyNotesFolder) {
        throw new WeeklyNotesFolderMissingError("Failed to find weekly notes folder");
      }
      obsidian.Vault.recurseChildren(weeklyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "week");
          if (date) {
            const dateString = getDateUID(date, "week");
            weeklyNotes[dateString] = note;
          }
        }
      });
      return weeklyNotes;
    }
    var MonthlyNotesFolderMissingError = class extends Error {
    };
    async function createMonthlyNote(date) {
      const { vault } = window.app;
      const { template, format: format2, folder } = getMonthlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = window.moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getMonthlyNote(date, monthlyNotes) {
      var _a;
      return (_a = monthlyNotes[getDateUID(date, "month")]) != null ? _a : null;
    }
    function getAllMonthlyNotes() {
      const monthlyNotes = {};
      if (!appHasMonthlyNotesPluginLoaded()) {
        return monthlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getMonthlyNoteSettings();
      const monthlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!monthlyNotesFolder) {
        throw new MonthlyNotesFolderMissingError("Failed to find monthly notes folder");
      }
      obsidian.Vault.recurseChildren(monthlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "month");
          if (date) {
            const dateString = getDateUID(date, "month");
            monthlyNotes[dateString] = note;
          }
        }
      });
      return monthlyNotes;
    }
    var QuarterlyNotesFolderMissingError = class extends Error {
    };
    async function createQuarterlyNote(date) {
      const { vault } = window.app;
      const { template, format: format2, folder } = getQuarterlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = window.moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getQuarterlyNote(date, quarterly) {
      var _a;
      return (_a = quarterly[getDateUID(date, "quarter")]) != null ? _a : null;
    }
    function getAllQuarterlyNotes() {
      const quarterly = {};
      if (!appHasQuarterlyNotesPluginLoaded()) {
        return quarterly;
      }
      const { vault } = window.app;
      const { folder } = getQuarterlyNoteSettings();
      const quarterlyFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!quarterlyFolder) {
        throw new QuarterlyNotesFolderMissingError("Failed to find quarterly notes folder");
      }
      obsidian.Vault.recurseChildren(quarterlyFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "quarter");
          if (date) {
            const dateString = getDateUID(date, "quarter");
            quarterly[dateString] = note;
          }
        }
      });
      return quarterly;
    }
    var YearlyNotesFolderMissingError = class extends Error {
    };
    async function createYearlyNote(date) {
      const { vault } = window.app;
      const { template, format: format2, folder } = getYearlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format2);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = window.moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format2);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getYearlyNote(date, yearlyNotes) {
      var _a;
      return (_a = yearlyNotes[getDateUID(date, "year")]) != null ? _a : null;
    }
    function getAllYearlyNotes() {
      const yearlyNotes = {};
      if (!appHasYearlyNotesPluginLoaded()) {
        return yearlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getYearlyNoteSettings();
      const yearlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!yearlyNotesFolder) {
        throw new YearlyNotesFolderMissingError("Failed to find yearly notes folder");
      }
      obsidian.Vault.recurseChildren(yearlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "year");
          if (date) {
            const dateString = getDateUID(date, "year");
            yearlyNotes[dateString] = note;
          }
        }
      });
      return yearlyNotes;
    }
    function appHasDailyNotesPluginLoaded2() {
      var _a, _b;
      const { app } = window;
      const dailyNotesPlugin = app.internalPlugins.plugins["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.daily) == null ? void 0 : _b.enabled);
    }
    function appHasWeeklyNotesPluginLoaded2() {
      var _a, _b;
      const { app } = window;
      if (app.plugins.getPlugin("calendar")) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.weekly) == null ? void 0 : _b.enabled);
    }
    function appHasMonthlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.monthly) == null ? void 0 : _b.enabled);
    }
    function appHasQuarterlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.quarterly) == null ? void 0 : _b.enabled);
    }
    function appHasYearlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.yearly) == null ? void 0 : _b.enabled);
    }
    function getPeriodicNoteSettings(granularity) {
      const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      }[granularity];
      return getSettings();
    }
    function createPeriodicNote(granularity, date) {
      const createFn = {
        day: createDailyNote2,
        month: createMonthlyNote,
        week: createWeeklyNote2
      };
      return createFn[granularity](date);
    }
    exports.DEFAULT_DAILY_NOTE_FORMAT = DEFAULT_DAILY_NOTE_FORMAT;
    exports.DEFAULT_MONTHLY_NOTE_FORMAT = DEFAULT_MONTHLY_NOTE_FORMAT;
    exports.DEFAULT_QUARTERLY_NOTE_FORMAT = DEFAULT_QUARTERLY_NOTE_FORMAT;
    exports.DEFAULT_WEEKLY_NOTE_FORMAT = DEFAULT_WEEKLY_NOTE_FORMAT;
    exports.DEFAULT_YEARLY_NOTE_FORMAT = DEFAULT_YEARLY_NOTE_FORMAT;
    exports.appHasDailyNotesPluginLoaded = appHasDailyNotesPluginLoaded2;
    exports.appHasMonthlyNotesPluginLoaded = appHasMonthlyNotesPluginLoaded;
    exports.appHasQuarterlyNotesPluginLoaded = appHasQuarterlyNotesPluginLoaded;
    exports.appHasWeeklyNotesPluginLoaded = appHasWeeklyNotesPluginLoaded2;
    exports.appHasYearlyNotesPluginLoaded = appHasYearlyNotesPluginLoaded;
    exports.createDailyNote = createDailyNote2;
    exports.createMonthlyNote = createMonthlyNote;
    exports.createPeriodicNote = createPeriodicNote;
    exports.createQuarterlyNote = createQuarterlyNote;
    exports.createWeeklyNote = createWeeklyNote2;
    exports.createYearlyNote = createYearlyNote;
    exports.getAllDailyNotes = getAllDailyNotes2;
    exports.getAllMonthlyNotes = getAllMonthlyNotes;
    exports.getAllQuarterlyNotes = getAllQuarterlyNotes;
    exports.getAllWeeklyNotes = getAllWeeklyNotes2;
    exports.getAllYearlyNotes = getAllYearlyNotes;
    exports.getDailyNote = getDailyNote2;
    exports.getDailyNoteSettings = getDailyNoteSettings;
    exports.getDateFromFile = getDateFromFile;
    exports.getDateFromPath = getDateFromPath;
    exports.getDateUID = getDateUID;
    exports.getMonthlyNote = getMonthlyNote;
    exports.getMonthlyNoteSettings = getMonthlyNoteSettings;
    exports.getPeriodicNoteSettings = getPeriodicNoteSettings;
    exports.getQuarterlyNote = getQuarterlyNote;
    exports.getQuarterlyNoteSettings = getQuarterlyNoteSettings;
    exports.getTemplateInfo = getTemplateInfo;
    exports.getWeeklyNote = getWeeklyNote2;
    exports.getWeeklyNoteSettings = getWeeklyNoteSettings;
    exports.getYearlyNote = getYearlyNote;
    exports.getYearlyNoteSettings = getYearlyNoteSettings;
  }
});

// node_modules/@dagrejs/graphlib/lib/graph.js
var require_graph = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/graph.js"(exports, module2) {
    "use strict";
    var DEFAULT_EDGE_NAME = "\0";
    var GRAPH_NODE = "\0";
    var EDGE_KEY_DELIM = "";
    var _isDirected, _isMultigraph, _isCompound, _label, _defaultNodeLabelFn, _defaultEdgeLabelFn, _nodes, _in, _preds, _out, _sucs, _edgeObjs, _edgeLabels, _nodeCount, _edgeCount, _parent, _children, _removeFromParentsChildList, removeFromParentsChildList_fn;
    var Graph = class {
      constructor(opts) {
        __privateAdd(this, _removeFromParentsChildList);
        __privateAdd(this, _isDirected, true);
        __privateAdd(this, _isMultigraph, false);
        __privateAdd(this, _isCompound, false);
        __privateAdd(this, _label, void 0);
        __privateAdd(this, _defaultNodeLabelFn, () => void 0);
        __privateAdd(this, _defaultEdgeLabelFn, () => void 0);
        __privateAdd(this, _nodes, {});
        __privateAdd(this, _in, {});
        __privateAdd(this, _preds, {});
        __privateAdd(this, _out, {});
        __privateAdd(this, _sucs, {});
        __privateAdd(this, _edgeObjs, {});
        __privateAdd(this, _edgeLabels, {});
        __privateAdd(this, _nodeCount, 0);
        __privateAdd(this, _edgeCount, 0);
        __privateAdd(this, _parent, void 0);
        __privateAdd(this, _children, void 0);
        if (opts) {
          __privateSet(this, _isDirected, opts.hasOwnProperty("directed") ? opts.directed : true);
          __privateSet(this, _isMultigraph, opts.hasOwnProperty("multigraph") ? opts.multigraph : false);
          __privateSet(this, _isCompound, opts.hasOwnProperty("compound") ? opts.compound : false);
        }
        if (__privateGet(this, _isCompound)) {
          __privateSet(this, _parent, {});
          __privateSet(this, _children, {});
          __privateGet(this, _children)[GRAPH_NODE] = {};
        }
      }
      isDirected() {
        return __privateGet(this, _isDirected);
      }
      isMultigraph() {
        return __privateGet(this, _isMultigraph);
      }
      isCompound() {
        return __privateGet(this, _isCompound);
      }
      setGraph(label) {
        __privateSet(this, _label, label);
        return this;
      }
      graph() {
        return __privateGet(this, _label);
      }
      setDefaultNodeLabel(newDefault) {
        __privateSet(this, _defaultNodeLabelFn, newDefault);
        if (typeof newDefault !== "function") {
          __privateSet(this, _defaultNodeLabelFn, () => newDefault);
        }
        return this;
      }
      nodeCount() {
        return __privateGet(this, _nodeCount);
      }
      nodes() {
        return Object.keys(__privateGet(this, _nodes));
      }
      sources() {
        var self = this;
        return this.nodes().filter((v) => Object.keys(__privateGet(self, _in)[v]).length === 0);
      }
      sinks() {
        var self = this;
        return this.nodes().filter((v) => Object.keys(__privateGet(self, _out)[v]).length === 0);
      }
      setNodes(vs, value) {
        var args = arguments;
        var self = this;
        vs.forEach(function(v) {
          if (args.length > 1) {
            self.setNode(v, value);
          } else {
            self.setNode(v);
          }
        });
        return this;
      }
      setNode(v, value) {
        if (__privateGet(this, _nodes).hasOwnProperty(v)) {
          if (arguments.length > 1) {
            __privateGet(this, _nodes)[v] = value;
          }
          return this;
        }
        __privateGet(this, _nodes)[v] = arguments.length > 1 ? value : __privateGet(this, _defaultNodeLabelFn).call(this, v);
        if (__privateGet(this, _isCompound)) {
          __privateGet(this, _parent)[v] = GRAPH_NODE;
          __privateGet(this, _children)[v] = {};
          __privateGet(this, _children)[GRAPH_NODE][v] = true;
        }
        __privateGet(this, _in)[v] = {};
        __privateGet(this, _preds)[v] = {};
        __privateGet(this, _out)[v] = {};
        __privateGet(this, _sucs)[v] = {};
        ++__privateWrapper(this, _nodeCount)._;
        return this;
      }
      node(v) {
        return __privateGet(this, _nodes)[v];
      }
      hasNode(v) {
        return __privateGet(this, _nodes).hasOwnProperty(v);
      }
      removeNode(v) {
        var self = this;
        if (__privateGet(this, _nodes).hasOwnProperty(v)) {
          var removeEdge = (e) => self.removeEdge(__privateGet(self, _edgeObjs)[e]);
          delete __privateGet(this, _nodes)[v];
          if (__privateGet(this, _isCompound)) {
            __privateMethod(this, _removeFromParentsChildList, removeFromParentsChildList_fn).call(this, v);
            delete __privateGet(this, _parent)[v];
            this.children(v).forEach(function(child) {
              self.setParent(child);
            });
            delete __privateGet(this, _children)[v];
          }
          Object.keys(__privateGet(this, _in)[v]).forEach(removeEdge);
          delete __privateGet(this, _in)[v];
          delete __privateGet(this, _preds)[v];
          Object.keys(__privateGet(this, _out)[v]).forEach(removeEdge);
          delete __privateGet(this, _out)[v];
          delete __privateGet(this, _sucs)[v];
          --__privateWrapper(this, _nodeCount)._;
        }
        return this;
      }
      setParent(v, parent) {
        if (!__privateGet(this, _isCompound)) {
          throw new Error("Cannot set parent in a non-compound graph");
        }
        if (parent === void 0) {
          parent = GRAPH_NODE;
        } else {
          parent += "";
          for (var ancestor = parent; ancestor !== void 0; ancestor = this.parent(ancestor)) {
            if (ancestor === v) {
              throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
            }
          }
          this.setNode(parent);
        }
        this.setNode(v);
        __privateMethod(this, _removeFromParentsChildList, removeFromParentsChildList_fn).call(this, v);
        __privateGet(this, _parent)[v] = parent;
        __privateGet(this, _children)[parent][v] = true;
        return this;
      }
      parent(v) {
        if (__privateGet(this, _isCompound)) {
          var parent = __privateGet(this, _parent)[v];
          if (parent !== GRAPH_NODE) {
            return parent;
          }
        }
      }
      children(v = GRAPH_NODE) {
        if (__privateGet(this, _isCompound)) {
          var children2 = __privateGet(this, _children)[v];
          if (children2) {
            return Object.keys(children2);
          }
        } else if (v === GRAPH_NODE) {
          return this.nodes();
        } else if (this.hasNode(v)) {
          return [];
        }
      }
      predecessors(v) {
        var predsV = __privateGet(this, _preds)[v];
        if (predsV) {
          return Object.keys(predsV);
        }
      }
      successors(v) {
        var sucsV = __privateGet(this, _sucs)[v];
        if (sucsV) {
          return Object.keys(sucsV);
        }
      }
      neighbors(v) {
        var preds = this.predecessors(v);
        if (preds) {
          const union = new Set(preds);
          for (var succ of this.successors(v)) {
            union.add(succ);
          }
          return Array.from(union.values());
        }
      }
      isLeaf(v) {
        var neighbors;
        if (this.isDirected()) {
          neighbors = this.successors(v);
        } else {
          neighbors = this.neighbors(v);
        }
        return neighbors.length === 0;
      }
      filterNodes(filter) {
        var copy = new this.constructor({
          directed: __privateGet(this, _isDirected),
          multigraph: __privateGet(this, _isMultigraph),
          compound: __privateGet(this, _isCompound)
        });
        copy.setGraph(this.graph());
        var self = this;
        Object.entries(__privateGet(this, _nodes)).forEach(function([v, value]) {
          if (filter(v)) {
            copy.setNode(v, value);
          }
        });
        Object.values(__privateGet(this, _edgeObjs)).forEach(function(e) {
          if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
            copy.setEdge(e, self.edge(e));
          }
        });
        var parents = {};
        function findParent(v) {
          var parent = self.parent(v);
          if (parent === void 0 || copy.hasNode(parent)) {
            parents[v] = parent;
            return parent;
          } else if (parent in parents) {
            return parents[parent];
          } else {
            return findParent(parent);
          }
        }
        if (__privateGet(this, _isCompound)) {
          copy.nodes().forEach((v) => copy.setParent(v, findParent(v)));
        }
        return copy;
      }
      setDefaultEdgeLabel(newDefault) {
        __privateSet(this, _defaultEdgeLabelFn, newDefault);
        if (typeof newDefault !== "function") {
          __privateSet(this, _defaultEdgeLabelFn, () => newDefault);
        }
        return this;
      }
      edgeCount() {
        return __privateGet(this, _edgeCount);
      }
      edges() {
        return Object.values(__privateGet(this, _edgeObjs));
      }
      setPath(vs, value) {
        var self = this;
        var args = arguments;
        vs.reduce(function(v, w) {
          if (args.length > 1) {
            self.setEdge(v, w, value);
          } else {
            self.setEdge(v, w);
          }
          return w;
        });
        return this;
      }
      setEdge() {
        var v, w, name, value;
        var valueSpecified = false;
        var arg0 = arguments[0];
        if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
          v = arg0.v;
          w = arg0.w;
          name = arg0.name;
          if (arguments.length === 2) {
            value = arguments[1];
            valueSpecified = true;
          }
        } else {
          v = arg0;
          w = arguments[1];
          name = arguments[3];
          if (arguments.length > 2) {
            value = arguments[2];
            valueSpecified = true;
          }
        }
        v = "" + v;
        w = "" + w;
        if (name !== void 0) {
          name = "" + name;
        }
        var e = edgeArgsToId(__privateGet(this, _isDirected), v, w, name);
        if (__privateGet(this, _edgeLabels).hasOwnProperty(e)) {
          if (valueSpecified) {
            __privateGet(this, _edgeLabels)[e] = value;
          }
          return this;
        }
        if (name !== void 0 && !__privateGet(this, _isMultigraph)) {
          throw new Error("Cannot set a named edge when isMultigraph = false");
        }
        this.setNode(v);
        this.setNode(w);
        __privateGet(this, _edgeLabels)[e] = valueSpecified ? value : __privateGet(this, _defaultEdgeLabelFn).call(this, v, w, name);
        var edgeObj = edgeArgsToObj(__privateGet(this, _isDirected), v, w, name);
        v = edgeObj.v;
        w = edgeObj.w;
        Object.freeze(edgeObj);
        __privateGet(this, _edgeObjs)[e] = edgeObj;
        incrementOrInitEntry(__privateGet(this, _preds)[w], v);
        incrementOrInitEntry(__privateGet(this, _sucs)[v], w);
        __privateGet(this, _in)[w][e] = edgeObj;
        __privateGet(this, _out)[v][e] = edgeObj;
        __privateWrapper(this, _edgeCount)._++;
        return this;
      }
      edge(v, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(__privateGet(this, _isDirected), arguments[0]) : edgeArgsToId(__privateGet(this, _isDirected), v, w, name);
        return __privateGet(this, _edgeLabels)[e];
      }
      edgeAsObj() {
        const edge = this.edge(...arguments);
        if (typeof edge !== "object") {
          return { label: edge };
        }
        return edge;
      }
      hasEdge(v, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(__privateGet(this, _isDirected), arguments[0]) : edgeArgsToId(__privateGet(this, _isDirected), v, w, name);
        return __privateGet(this, _edgeLabels).hasOwnProperty(e);
      }
      removeEdge(v, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(__privateGet(this, _isDirected), arguments[0]) : edgeArgsToId(__privateGet(this, _isDirected), v, w, name);
        var edge = __privateGet(this, _edgeObjs)[e];
        if (edge) {
          v = edge.v;
          w = edge.w;
          delete __privateGet(this, _edgeLabels)[e];
          delete __privateGet(this, _edgeObjs)[e];
          decrementOrRemoveEntry(__privateGet(this, _preds)[w], v);
          decrementOrRemoveEntry(__privateGet(this, _sucs)[v], w);
          delete __privateGet(this, _in)[w][e];
          delete __privateGet(this, _out)[v][e];
          __privateWrapper(this, _edgeCount)._--;
        }
        return this;
      }
      inEdges(v, u) {
        var inV = __privateGet(this, _in)[v];
        if (inV) {
          var edges = Object.values(inV);
          if (!u) {
            return edges;
          }
          return edges.filter((edge) => edge.v === u);
        }
      }
      outEdges(v, w) {
        var outV = __privateGet(this, _out)[v];
        if (outV) {
          var edges = Object.values(outV);
          if (!w) {
            return edges;
          }
          return edges.filter((edge) => edge.w === w);
        }
      }
      nodeEdges(v, w) {
        var inEdges = this.inEdges(v, w);
        if (inEdges) {
          return inEdges.concat(this.outEdges(v, w));
        }
      }
    };
    _isDirected = new WeakMap();
    _isMultigraph = new WeakMap();
    _isCompound = new WeakMap();
    _label = new WeakMap();
    _defaultNodeLabelFn = new WeakMap();
    _defaultEdgeLabelFn = new WeakMap();
    _nodes = new WeakMap();
    _in = new WeakMap();
    _preds = new WeakMap();
    _out = new WeakMap();
    _sucs = new WeakMap();
    _edgeObjs = new WeakMap();
    _edgeLabels = new WeakMap();
    _nodeCount = new WeakMap();
    _edgeCount = new WeakMap();
    _parent = new WeakMap();
    _children = new WeakMap();
    _removeFromParentsChildList = new WeakSet();
    removeFromParentsChildList_fn = function(v) {
      delete __privateGet(this, _children)[__privateGet(this, _parent)[v]][v];
    };
    function incrementOrInitEntry(map, k) {
      if (map[k]) {
        map[k]++;
      } else {
        map[k] = 1;
      }
    }
    function decrementOrRemoveEntry(map, k) {
      if (!--map[k]) {
        delete map[k];
      }
    }
    function edgeArgsToId(isDirected, v_, w_, name) {
      var v = "" + v_;
      var w = "" + w_;
      if (!isDirected && v > w) {
        var tmp = v;
        v = w;
        w = tmp;
      }
      return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (name === void 0 ? DEFAULT_EDGE_NAME : name);
    }
    function edgeArgsToObj(isDirected, v_, w_, name) {
      var v = "" + v_;
      var w = "" + w_;
      if (!isDirected && v > w) {
        var tmp = v;
        v = w;
        w = tmp;
      }
      var edgeObj = { v, w };
      if (name) {
        edgeObj.name = name;
      }
      return edgeObj;
    }
    function edgeObjToId(isDirected, edgeObj) {
      return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
    }
    module2.exports = Graph;
  }
});

// node_modules/@dagrejs/graphlib/lib/version.js
var require_version = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/version.js"(exports, module2) {
    module2.exports = "2.1.13";
  }
});

// node_modules/@dagrejs/graphlib/lib/index.js
var require_lib = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/index.js"(exports, module2) {
    module2.exports = {
      Graph: require_graph(),
      version: require_version()
    };
  }
});

// node_modules/@dagrejs/graphlib/lib/json.js
var require_json = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/json.js"(exports, module2) {
    var Graph = require_graph();
    module2.exports = {
      write: write2,
      read: read2
    };
    function write2(g) {
      var json = {
        options: {
          directed: g.isDirected(),
          multigraph: g.isMultigraph(),
          compound: g.isCompound()
        },
        nodes: writeNodes(g),
        edges: writeEdges(g)
      };
      if (g.graph() !== void 0) {
        json.value = structuredClone(g.graph());
      }
      return json;
    }
    function writeNodes(g) {
      return g.nodes().map(function(v) {
        var nodeValue = g.node(v);
        var parent = g.parent(v);
        var node = { v };
        if (nodeValue !== void 0) {
          node.value = nodeValue;
        }
        if (parent !== void 0) {
          node.parent = parent;
        }
        return node;
      });
    }
    function writeEdges(g) {
      return g.edges().map(function(e) {
        var edgeValue = g.edge(e);
        var edge = { v: e.v, w: e.w };
        if (e.name !== void 0) {
          edge.name = e.name;
        }
        if (edgeValue !== void 0) {
          edge.value = edgeValue;
        }
        return edge;
      });
    }
    function read2(json) {
      var g = new Graph(json.options).setGraph(json.value);
      json.nodes.forEach(function(entry) {
        g.setNode(entry.v, entry.value);
        if (entry.parent) {
          g.setParent(entry.v, entry.parent);
        }
      });
      json.edges.forEach(function(entry) {
        g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
      });
      return g;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/components.js
var require_components = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/components.js"(exports, module2) {
    module2.exports = components;
    function components(g) {
      var visited = {};
      var cmpts = [];
      var cmpt;
      function dfs(v) {
        if (visited.hasOwnProperty(v))
          return;
        visited[v] = true;
        cmpt.push(v);
        g.successors(v).forEach(dfs);
        g.predecessors(v).forEach(dfs);
      }
      g.nodes().forEach(function(v) {
        cmpt = [];
        dfs(v);
        if (cmpt.length) {
          cmpts.push(cmpt);
        }
      });
      return cmpts;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/data/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/data/priority-queue.js"(exports, module2) {
    var _arr, _keyIndices, _heapify, heapify_fn, _decrease, decrease_fn, _swap, swap_fn;
    var PriorityQueue = class {
      constructor() {
        __privateAdd(this, _heapify);
        __privateAdd(this, _decrease);
        __privateAdd(this, _swap);
        __privateAdd(this, _arr, []);
        __privateAdd(this, _keyIndices, {});
      }
      size() {
        return __privateGet(this, _arr).length;
      }
      keys() {
        return __privateGet(this, _arr).map(function(x) {
          return x.key;
        });
      }
      has(key) {
        return __privateGet(this, _keyIndices).hasOwnProperty(key);
      }
      priority(key) {
        var index = __privateGet(this, _keyIndices)[key];
        if (index !== void 0) {
          return __privateGet(this, _arr)[index].priority;
        }
      }
      min() {
        if (this.size() === 0) {
          throw new Error("Queue underflow");
        }
        return __privateGet(this, _arr)[0].key;
      }
      add(key, priority) {
        var keyIndices = __privateGet(this, _keyIndices);
        key = String(key);
        if (!keyIndices.hasOwnProperty(key)) {
          var arr = __privateGet(this, _arr);
          var index = arr.length;
          keyIndices[key] = index;
          arr.push({ key, priority });
          __privateMethod(this, _decrease, decrease_fn).call(this, index);
          return true;
        }
        return false;
      }
      removeMin() {
        __privateMethod(this, _swap, swap_fn).call(this, 0, __privateGet(this, _arr).length - 1);
        var min2 = __privateGet(this, _arr).pop();
        delete __privateGet(this, _keyIndices)[min2.key];
        __privateMethod(this, _heapify, heapify_fn).call(this, 0);
        return min2.key;
      }
      decrease(key, priority) {
        var index = __privateGet(this, _keyIndices)[key];
        if (priority > __privateGet(this, _arr)[index].priority) {
          throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + __privateGet(this, _arr)[index].priority + " New: " + priority);
        }
        __privateGet(this, _arr)[index].priority = priority;
        __privateMethod(this, _decrease, decrease_fn).call(this, index);
      }
    };
    _arr = new WeakMap();
    _keyIndices = new WeakMap();
    _heapify = new WeakSet();
    heapify_fn = function(i) {
      var arr = __privateGet(this, _arr);
      var l = 2 * i;
      var r = l + 1;
      var largest = i;
      if (l < arr.length) {
        largest = arr[l].priority < arr[largest].priority ? l : largest;
        if (r < arr.length) {
          largest = arr[r].priority < arr[largest].priority ? r : largest;
        }
        if (largest !== i) {
          __privateMethod(this, _swap, swap_fn).call(this, i, largest);
          __privateMethod(this, _heapify, heapify_fn).call(this, largest);
        }
      }
    };
    _decrease = new WeakSet();
    decrease_fn = function(index) {
      var arr = __privateGet(this, _arr);
      var priority = arr[index].priority;
      var parent;
      while (index !== 0) {
        parent = index >> 1;
        if (arr[parent].priority < priority) {
          break;
        }
        __privateMethod(this, _swap, swap_fn).call(this, index, parent);
        index = parent;
      }
    };
    _swap = new WeakSet();
    swap_fn = function(i, j) {
      var arr = __privateGet(this, _arr);
      var keyIndices = __privateGet(this, _keyIndices);
      var origArrI = arr[i];
      var origArrJ = arr[j];
      arr[i] = origArrJ;
      arr[j] = origArrI;
      keyIndices[origArrJ.key] = i;
      keyIndices[origArrI.key] = j;
    };
    module2.exports = PriorityQueue;
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/dijkstra.js"(exports, module2) {
    var PriorityQueue = require_priority_queue();
    module2.exports = dijkstra;
    var DEFAULT_WEIGHT_FUNC = () => 1;
    function dijkstra(g, source, weightFn, edgeFn) {
      return runDijkstra(g, String(source), weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function(v) {
        return g.outEdges(v);
      });
    }
    function runDijkstra(g, source, weightFn, edgeFn) {
      var results = {};
      var pq = new PriorityQueue();
      var v, vEntry;
      var updateNeighbors = function(edge) {
        var w = edge.v !== v ? edge.v : edge.w;
        var wEntry = results[w];
        var weight = weightFn(edge);
        var distance = vEntry.distance + weight;
        if (weight < 0) {
          throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
        }
        if (distance < wEntry.distance) {
          wEntry.distance = distance;
          wEntry.predecessor = v;
          pq.decrease(w, distance);
        }
      };
      g.nodes().forEach(function(v2) {
        var distance = v2 === source ? 0 : Number.POSITIVE_INFINITY;
        results[v2] = { distance };
        pq.add(v2, distance);
      });
      while (pq.size() > 0) {
        v = pq.removeMin();
        vEntry = results[v];
        if (vEntry.distance === Number.POSITIVE_INFINITY) {
          break;
        }
        edgeFn(v).forEach(updateNeighbors);
      }
      return results;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/dijkstra-all.js
var require_dijkstra_all = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/dijkstra-all.js"(exports, module2) {
    var dijkstra = require_dijkstra();
    module2.exports = dijkstraAll;
    function dijkstraAll(g, weightFunc, edgeFunc) {
      return g.nodes().reduce(function(acc, v) {
        acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
        return acc;
      }, {});
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/tarjan.js
var require_tarjan = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/tarjan.js"(exports, module2) {
    module2.exports = tarjan;
    function tarjan(g) {
      var index = 0;
      var stack = [];
      var visited = {};
      var results = [];
      function dfs(v) {
        var entry = visited[v] = {
          onStack: true,
          lowlink: index,
          index: index++
        };
        stack.push(v);
        g.successors(v).forEach(function(w2) {
          if (!visited.hasOwnProperty(w2)) {
            dfs(w2);
            entry.lowlink = Math.min(entry.lowlink, visited[w2].lowlink);
          } else if (visited[w2].onStack) {
            entry.lowlink = Math.min(entry.lowlink, visited[w2].index);
          }
        });
        if (entry.lowlink === entry.index) {
          var cmpt = [];
          var w;
          do {
            w = stack.pop();
            visited[w].onStack = false;
            cmpt.push(w);
          } while (v !== w);
          results.push(cmpt);
        }
      }
      g.nodes().forEach(function(v) {
        if (!visited.hasOwnProperty(v)) {
          dfs(v);
        }
      });
      return results;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/find-cycles.js
var require_find_cycles = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/find-cycles.js"(exports, module2) {
    var tarjan = require_tarjan();
    module2.exports = findCycles;
    function findCycles(g) {
      return tarjan(g).filter(function(cmpt) {
        return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
      });
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/floyd-warshall.js
var require_floyd_warshall = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/floyd-warshall.js"(exports, module2) {
    module2.exports = floydWarshall;
    var DEFAULT_WEIGHT_FUNC = () => 1;
    function floydWarshall(g, weightFn, edgeFn) {
      return runFloydWarshall(g, weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function(v) {
        return g.outEdges(v);
      });
    }
    function runFloydWarshall(g, weightFn, edgeFn) {
      var results = {};
      var nodes = g.nodes();
      nodes.forEach(function(v) {
        results[v] = {};
        results[v][v] = { distance: 0 };
        nodes.forEach(function(w) {
          if (v !== w) {
            results[v][w] = { distance: Number.POSITIVE_INFINITY };
          }
        });
        edgeFn(v).forEach(function(edge) {
          var w = edge.v === v ? edge.w : edge.v;
          var d = weightFn(edge);
          results[v][w] = { distance: d, predecessor: v };
        });
      });
      nodes.forEach(function(k) {
        var rowK = results[k];
        nodes.forEach(function(i) {
          var rowI = results[i];
          nodes.forEach(function(j) {
            var ik = rowI[k];
            var kj = rowK[j];
            var ij = rowI[j];
            var altDistance = ik.distance + kj.distance;
            if (altDistance < ij.distance) {
              ij.distance = altDistance;
              ij.predecessor = kj.predecessor;
            }
          });
        });
      });
      return results;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/topsort.js
var require_topsort = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/topsort.js"(exports, module2) {
    function topsort(g) {
      var visited = {};
      var stack = {};
      var results = [];
      function visit(node) {
        if (stack.hasOwnProperty(node)) {
          throw new CycleException();
        }
        if (!visited.hasOwnProperty(node)) {
          stack[node] = true;
          visited[node] = true;
          g.predecessors(node).forEach(visit);
          delete stack[node];
          results.push(node);
        }
      }
      g.sinks().forEach(visit);
      if (Object.keys(visited).length !== g.nodeCount()) {
        throw new CycleException();
      }
      return results;
    }
    var CycleException = class extends Error {
      constructor() {
        super(...arguments);
      }
    };
    module2.exports = topsort;
    topsort.CycleException = CycleException;
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/is-acyclic.js
var require_is_acyclic = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/is-acyclic.js"(exports, module2) {
    var topsort = require_topsort();
    module2.exports = isAcyclic;
    function isAcyclic(g) {
      try {
        topsort(g);
      } catch (e) {
        if (e instanceof topsort.CycleException) {
          return false;
        }
        throw e;
      }
      return true;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/dfs.js
var require_dfs = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/dfs.js"(exports, module2) {
    module2.exports = dfs;
    function dfs(g, vs, order2) {
      if (!Array.isArray(vs)) {
        vs = [vs];
      }
      var navigation = g.isDirected() ? (v) => g.successors(v) : (v) => g.neighbors(v);
      var orderFunc = order2 === "post" ? postOrderDfs : preOrderDfs;
      var acc = [];
      var visited = {};
      vs.forEach((v) => {
        if (!g.hasNode(v)) {
          throw new Error("Graph does not have node: " + v);
        }
        orderFunc(v, navigation, visited, acc);
      });
      return acc;
    }
    function postOrderDfs(v, navigation, visited, acc) {
      var stack = [[v, false]];
      while (stack.length > 0) {
        var curr = stack.pop();
        if (curr[1]) {
          acc.push(curr[0]);
        } else {
          if (!visited.hasOwnProperty(curr[0])) {
            visited[curr[0]] = true;
            stack.push([curr[0], true]);
            forEachRight(navigation(curr[0]), (w) => stack.push([w, false]));
          }
        }
      }
    }
    function preOrderDfs(v, navigation, visited, acc) {
      var stack = [v];
      while (stack.length > 0) {
        var curr = stack.pop();
        if (!visited.hasOwnProperty(curr)) {
          visited[curr] = true;
          acc.push(curr);
          forEachRight(navigation(curr), (w) => stack.push(w));
        }
      }
    }
    function forEachRight(array, iteratee) {
      var length = array.length;
      while (length--) {
        iteratee(array[length], length, array);
      }
      return array;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/postorder.js
var require_postorder = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/postorder.js"(exports, module2) {
    var dfs = require_dfs();
    module2.exports = postorder;
    function postorder(g, vs) {
      return dfs(g, vs, "post");
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/preorder.js
var require_preorder = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/preorder.js"(exports, module2) {
    var dfs = require_dfs();
    module2.exports = preorder;
    function preorder(g, vs) {
      return dfs(g, vs, "pre");
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/prim.js
var require_prim = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/prim.js"(exports, module2) {
    var Graph = require_graph();
    var PriorityQueue = require_priority_queue();
    module2.exports = prim;
    function prim(g, weightFunc) {
      var result = new Graph();
      var parents = {};
      var pq = new PriorityQueue();
      var v;
      function updateNeighbors(edge) {
        var w = edge.v === v ? edge.w : edge.v;
        var pri = pq.priority(w);
        if (pri !== void 0) {
          var edgeWeight = weightFunc(edge);
          if (edgeWeight < pri) {
            parents[w] = v;
            pq.decrease(w, edgeWeight);
          }
        }
      }
      if (g.nodeCount() === 0) {
        return result;
      }
      g.nodes().forEach(function(v2) {
        pq.add(v2, Number.POSITIVE_INFINITY);
        result.setNode(v2);
      });
      pq.decrease(g.nodes()[0], 0);
      var init3 = false;
      while (pq.size() > 0) {
        v = pq.removeMin();
        if (parents.hasOwnProperty(v)) {
          result.setEdge(v, parents[v]);
        } else if (init3) {
          throw new Error("Input graph is not connected: " + g);
        } else {
          init3 = true;
        }
        g.nodeEdges(v).forEach(updateNeighbors);
      }
      return result;
    }
  }
});

// node_modules/@dagrejs/graphlib/lib/alg/index.js
var require_alg = __commonJS({
  "node_modules/@dagrejs/graphlib/lib/alg/index.js"(exports, module2) {
    module2.exports = {
      components: require_components(),
      dijkstra: require_dijkstra(),
      dijkstraAll: require_dijkstra_all(),
      findCycles: require_find_cycles(),
      floydWarshall: require_floyd_warshall(),
      isAcyclic: require_is_acyclic(),
      postorder: require_postorder(),
      preorder: require_preorder(),
      prim: require_prim(),
      tarjan: require_tarjan(),
      topsort: require_topsort()
    };
  }
});

// node_modules/@dagrejs/graphlib/index.js
var require_graphlib = __commonJS({
  "node_modules/@dagrejs/graphlib/index.js"(exports, module2) {
    var lib = require_lib();
    module2.exports = {
      Graph: lib.Graph,
      json: require_json(),
      alg: require_alg(),
      version: lib.version
    };
  }
});

// node_modules/@dagrejs/dagre/lib/data/list.js
var require_list = __commonJS({
  "node_modules/@dagrejs/dagre/lib/data/list.js"(exports, module2) {
    module2.exports = List;
    function List() {
      var sentinel = {};
      sentinel._next = sentinel._prev = sentinel;
      this._sentinel = sentinel;
    }
    List.prototype.dequeue = function() {
      var sentinel = this._sentinel;
      var entry = sentinel._prev;
      if (entry !== sentinel) {
        unlink(entry);
        return entry;
      }
    };
    List.prototype.enqueue = function(entry) {
      var sentinel = this._sentinel;
      if (entry._prev && entry._next) {
        unlink(entry);
      }
      entry._next = sentinel._next;
      sentinel._next._prev = entry;
      sentinel._next = entry;
      entry._prev = sentinel;
    };
    List.prototype.toString = function() {
      var strs = [];
      var sentinel = this._sentinel;
      var curr = sentinel._prev;
      while (curr !== sentinel) {
        strs.push(JSON.stringify(curr, filterOutLinks));
        curr = curr._prev;
      }
      return "[" + strs.join(", ") + "]";
    };
    function unlink(entry) {
      entry._prev._next = entry._next;
      entry._next._prev = entry._prev;
      delete entry._next;
      delete entry._prev;
    }
    function filterOutLinks(k, v) {
      if (k !== "_next" && k !== "_prev") {
        return v;
      }
    }
  }
});

// node_modules/@dagrejs/dagre/lib/greedy-fas.js
var require_greedy_fas = __commonJS({
  "node_modules/@dagrejs/dagre/lib/greedy-fas.js"(exports, module2) {
    var Graph = require_graphlib().Graph;
    var List = require_list();
    module2.exports = greedyFAS;
    var DEFAULT_WEIGHT_FN = () => 1;
    function greedyFAS(g, weightFn) {
      if (g.nodeCount() <= 1) {
        return [];
      }
      var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
      var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
      return results.flatMap((e) => g.outEdges(e.v, e.w));
    }
    function doGreedyFAS(g, buckets, zeroIdx) {
      var results = [];
      var sources = buckets[buckets.length - 1];
      var sinks = buckets[0];
      var entry;
      while (g.nodeCount()) {
        while (entry = sinks.dequeue()) {
          removeNode(g, buckets, zeroIdx, entry);
        }
        while (entry = sources.dequeue()) {
          removeNode(g, buckets, zeroIdx, entry);
        }
        if (g.nodeCount()) {
          for (var i = buckets.length - 2; i > 0; --i) {
            entry = buckets[i].dequeue();
            if (entry) {
              results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
              break;
            }
          }
        }
      }
      return results;
    }
    function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
      var results = collectPredecessors ? [] : void 0;
      g.inEdges(entry.v).forEach(function(edge) {
        var weight = g.edge(edge);
        var uEntry = g.node(edge.v);
        if (collectPredecessors) {
          results.push({ v: edge.v, w: edge.w });
        }
        uEntry.out -= weight;
        assignBucket(buckets, zeroIdx, uEntry);
      });
      g.outEdges(entry.v).forEach(function(edge) {
        var weight = g.edge(edge);
        var w = edge.w;
        var wEntry = g.node(w);
        wEntry["in"] -= weight;
        assignBucket(buckets, zeroIdx, wEntry);
      });
      g.removeNode(entry.v);
      return results;
    }
    function buildState(g, weightFn) {
      var fasGraph = new Graph();
      var maxIn = 0;
      var maxOut = 0;
      g.nodes().forEach(function(v) {
        fasGraph.setNode(v, { v, "in": 0, out: 0 });
      });
      g.edges().forEach(function(e) {
        var prevWeight = fasGraph.edge(e.v, e.w) || 0;
        var weight = weightFn(e);
        var edgeWeight = prevWeight + weight;
        fasGraph.setEdge(e.v, e.w, edgeWeight);
        maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
        maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
      });
      var buckets = range(maxOut + maxIn + 3).map(() => new List());
      var zeroIdx = maxIn + 1;
      fasGraph.nodes().forEach(function(v) {
        assignBucket(buckets, zeroIdx, fasGraph.node(v));
      });
      return { graph: fasGraph, buckets, zeroIdx };
    }
    function assignBucket(buckets, zeroIdx, entry) {
      if (!entry.out) {
        buckets[0].enqueue(entry);
      } else if (!entry["in"]) {
        buckets[buckets.length - 1].enqueue(entry);
      } else {
        buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
      }
    }
    function range(limit) {
      const range2 = [];
      for (let i = 0; i < limit; i++) {
        range2.push(i);
      }
      return range2;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/util.js
var require_util = __commonJS({
  "node_modules/@dagrejs/dagre/lib/util.js"(exports, module2) {
    "use strict";
    var Graph = require_graphlib().Graph;
    module2.exports = {
      addBorderNode,
      addDummyNode,
      asNonCompoundGraph,
      buildLayerMatrix,
      intersectRect,
      mapValues,
      maxRank,
      normalizeRanks,
      notime,
      partition,
      pick,
      predecessorWeights,
      range,
      removeEmptyRanks,
      simplify,
      successorWeights,
      time,
      uniqueId,
      zipObject
    };
    function addDummyNode(g, type, attrs, name) {
      var v;
      do {
        v = uniqueId(name);
      } while (g.hasNode(v));
      attrs.dummy = type;
      g.setNode(v, attrs);
      return v;
    }
    function simplify(g) {
      var simplified = new Graph().setGraph(g.graph());
      g.nodes().forEach((v) => simplified.setNode(v, g.node(v)));
      g.edges().forEach((e) => {
        var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
        var label = g.edge(e);
        simplified.setEdge(e.v, e.w, {
          weight: simpleLabel.weight + label.weight,
          minlen: Math.max(simpleLabel.minlen, label.minlen)
        });
      });
      return simplified;
    }
    function asNonCompoundGraph(g) {
      var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
      g.nodes().forEach((v) => {
        if (!g.children(v).length) {
          simplified.setNode(v, g.node(v));
        }
      });
      g.edges().forEach((e) => {
        simplified.setEdge(e, g.edge(e));
      });
      return simplified;
    }
    function successorWeights(g) {
      var weightMap = g.nodes().map((v) => {
        var sucs = {};
        g.outEdges(v).forEach((e) => {
          sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
        });
        return sucs;
      });
      return zipObject(g.nodes(), weightMap);
    }
    function predecessorWeights(g) {
      var weightMap = g.nodes().map((v) => {
        var preds = {};
        g.inEdges(v).forEach((e) => {
          preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
        });
        return preds;
      });
      return zipObject(g.nodes(), weightMap);
    }
    function intersectRect(rect, point) {
      var x = rect.x;
      var y = rect.y;
      var dx = point.x - x;
      var dy = point.y - y;
      var w = rect.width / 2;
      var h = rect.height / 2;
      if (!dx && !dy) {
        throw new Error("Not possible to find intersection inside of the rectangle");
      }
      var sx, sy;
      if (Math.abs(dy) * w > Math.abs(dx) * h) {
        if (dy < 0) {
          h = -h;
        }
        sx = h * dx / dy;
        sy = h;
      } else {
        if (dx < 0) {
          w = -w;
        }
        sx = w;
        sy = w * dy / dx;
      }
      return { x: x + sx, y: y + sy };
    }
    function buildLayerMatrix(g) {
      var layering = range(maxRank(g) + 1).map(() => []);
      g.nodes().forEach((v) => {
        var node = g.node(v);
        var rank = node.rank;
        if (rank !== void 0) {
          layering[rank][node.order] = v;
        }
      });
      return layering;
    }
    function normalizeRanks(g) {
      var min2 = Math.min(...g.nodes().map((v) => {
        var rank = g.node(v).rank;
        if (rank === void 0) {
          return Number.MAX_VALUE;
        }
        return rank;
      }));
      g.nodes().forEach((v) => {
        var node = g.node(v);
        if (node.hasOwnProperty("rank")) {
          node.rank -= min2;
        }
      });
    }
    function removeEmptyRanks(g) {
      var offset2 = Math.min(...g.nodes().map((v) => g.node(v).rank));
      var layers = [];
      g.nodes().forEach((v) => {
        var rank = g.node(v).rank - offset2;
        if (!layers[rank]) {
          layers[rank] = [];
        }
        layers[rank].push(v);
      });
      var delta = 0;
      var nodeRankFactor = g.graph().nodeRankFactor;
      Array.from(layers).forEach((vs, i) => {
        if (vs === void 0 && i % nodeRankFactor !== 0) {
          --delta;
        } else if (vs !== void 0 && delta) {
          vs.forEach((v) => g.node(v).rank += delta);
        }
      });
    }
    function addBorderNode(g, prefix, rank, order2) {
      var node = {
        width: 0,
        height: 0
      };
      if (arguments.length >= 4) {
        node.rank = rank;
        node.order = order2;
      }
      return addDummyNode(g, "border", node, prefix);
    }
    function maxRank(g) {
      return Math.max(...g.nodes().map((v) => {
        var rank = g.node(v).rank;
        if (rank === void 0) {
          return Number.MIN_VALUE;
        }
        return rank;
      }));
    }
    function partition(collection, fn2) {
      var result = { lhs: [], rhs: [] };
      collection.forEach((value) => {
        if (fn2(value)) {
          result.lhs.push(value);
        } else {
          result.rhs.push(value);
        }
      });
      return result;
    }
    function time(name, fn2) {
      var start2 = Date.now();
      try {
        return fn2();
      } finally {
        console.log(name + " time: " + (Date.now() - start2) + "ms");
      }
    }
    function notime(name, fn2) {
      return fn2();
    }
    var idCounter = 0;
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }
    function range(start2, limit, step = 1) {
      if (limit == null) {
        limit = start2;
        start2 = 0;
      }
      let endCon = (i) => i < limit;
      if (step < 0) {
        endCon = (i) => limit < i;
      }
      const range2 = [];
      for (let i = start2; endCon(i); i += step) {
        range2.push(i);
      }
      return range2;
    }
    function pick(source, keys) {
      const dest = {};
      for (const key of keys) {
        if (source[key] !== void 0) {
          dest[key] = source[key];
        }
      }
      return dest;
    }
    function mapValues(obj, funcOrProp) {
      let func = funcOrProp;
      if (typeof funcOrProp === "string") {
        func = (val) => val[funcOrProp];
      }
      return Object.entries(obj).reduce((acc, [k, v]) => {
        acc[k] = func(v, k);
        return acc;
      }, {});
    }
    function zipObject(props, values) {
      return props.reduce((acc, key, i) => {
        acc[key] = values[i];
        return acc;
      }, {});
    }
  }
});

// node_modules/@dagrejs/dagre/lib/acyclic.js
var require_acyclic = __commonJS({
  "node_modules/@dagrejs/dagre/lib/acyclic.js"(exports, module2) {
    "use strict";
    var greedyFAS = require_greedy_fas();
    var uniqueId = require_util().uniqueId;
    module2.exports = {
      run: run2,
      undo
    };
    function run2(g) {
      var fas = g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g);
      fas.forEach(function(e) {
        var label = g.edge(e);
        g.removeEdge(e);
        label.forwardName = e.name;
        label.reversed = true;
        g.setEdge(e.w, e.v, label, uniqueId("rev"));
      });
      function weightFn(g2) {
        return function(e) {
          return g2.edge(e).weight;
        };
      }
    }
    function dfsFAS(g) {
      var fas = [];
      var stack = {};
      var visited = {};
      function dfs(v) {
        if (visited.hasOwnProperty(v)) {
          return;
        }
        visited[v] = true;
        stack[v] = true;
        g.outEdges(v).forEach(function(e) {
          if (stack.hasOwnProperty(e.w)) {
            fas.push(e);
          } else {
            dfs(e.w);
          }
        });
        delete stack[v];
      }
      g.nodes().forEach(dfs);
      return fas;
    }
    function undo(g) {
      g.edges().forEach(function(e) {
        var label = g.edge(e);
        if (label.reversed) {
          g.removeEdge(e);
          var forwardName = label.forwardName;
          delete label.reversed;
          delete label.forwardName;
          g.setEdge(e.w, e.v, label, forwardName);
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/normalize.js
var require_normalize = __commonJS({
  "node_modules/@dagrejs/dagre/lib/normalize.js"(exports, module2) {
    "use strict";
    var util = require_util();
    module2.exports = {
      run: run2,
      undo
    };
    function run2(g) {
      g.graph().dummyChains = [];
      g.edges().forEach((edge) => normalizeEdge(g, edge));
    }
    function normalizeEdge(g, e) {
      var v = e.v;
      var vRank = g.node(v).rank;
      var w = e.w;
      var wRank = g.node(w).rank;
      var name = e.name;
      var edgeLabel = g.edge(e);
      var labelRank = edgeLabel.labelRank;
      if (wRank === vRank + 1)
        return;
      g.removeEdge(e);
      var dummy, attrs, i;
      for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
        edgeLabel.points = [];
        attrs = {
          width: 0,
          height: 0,
          edgeLabel,
          edgeObj: e,
          rank: vRank
        };
        dummy = util.addDummyNode(g, "edge", attrs, "_d");
        if (vRank === labelRank) {
          attrs.width = edgeLabel.width;
          attrs.height = edgeLabel.height;
          attrs.dummy = "edge-label";
          attrs.labelpos = edgeLabel.labelpos;
        }
        g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
        if (i === 0) {
          g.graph().dummyChains.push(dummy);
        }
        v = dummy;
      }
      g.setEdge(v, w, { weight: edgeLabel.weight }, name);
    }
    function undo(g) {
      g.graph().dummyChains.forEach(function(v) {
        var node = g.node(v);
        var origLabel = node.edgeLabel;
        var w;
        g.setEdge(node.edgeObj, origLabel);
        while (node.dummy) {
          w = g.successors(v)[0];
          g.removeNode(v);
          origLabel.points.push({ x: node.x, y: node.y });
          if (node.dummy === "edge-label") {
            origLabel.x = node.x;
            origLabel.y = node.y;
            origLabel.width = node.width;
            origLabel.height = node.height;
          }
          v = w;
          node = g.node(v);
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/util.js
var require_util2 = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/util.js"(exports, module2) {
    "use strict";
    module2.exports = {
      longestPath,
      slack
    };
    function longestPath(g) {
      var visited = {};
      function dfs(v) {
        var label = g.node(v);
        if (visited.hasOwnProperty(v)) {
          return label.rank;
        }
        visited[v] = true;
        var rank = Math.min(...g.outEdges(v).map((e) => {
          if (e == null) {
            return Number.POSITIVE_INFINITY;
          }
          return dfs(e.w) - g.edge(e).minlen;
        }));
        if (rank === Number.POSITIVE_INFINITY) {
          rank = 0;
        }
        return label.rank = rank;
      }
      g.sources().forEach(dfs);
    }
    function slack(g, e) {
      return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/feasible-tree.js
var require_feasible_tree = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/feasible-tree.js"(exports, module2) {
    "use strict";
    var Graph = require_graphlib().Graph;
    var slack = require_util2().slack;
    module2.exports = feasibleTree;
    function feasibleTree(g) {
      var t = new Graph({ directed: false });
      var start2 = g.nodes()[0];
      var size = g.nodeCount();
      t.setNode(start2, {});
      var edge, delta;
      while (tightTree(t, g) < size) {
        edge = findMinSlackEdge(t, g);
        delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
        shiftRanks(t, g, delta);
      }
      return t;
    }
    function tightTree(t, g) {
      function dfs(v) {
        g.nodeEdges(v).forEach(function(e) {
          var edgeV = e.v, w = v === edgeV ? e.w : edgeV;
          if (!t.hasNode(w) && !slack(g, e)) {
            t.setNode(w, {});
            t.setEdge(v, w, {});
            dfs(w);
          }
        });
      }
      t.nodes().forEach(dfs);
      return t.nodeCount();
    }
    function findMinSlackEdge(t, g) {
      const edges = g.edges();
      return edges.reduce((acc, edge) => {
        let edgeSlack = Number.POSITIVE_INFINITY;
        if (t.hasNode(edge.v) !== t.hasNode(edge.w)) {
          edgeSlack = slack(g, edge);
        }
        if (edgeSlack < acc[0]) {
          return [edgeSlack, edge];
        }
        return acc;
      }, [Number.POSITIVE_INFINITY, null])[1];
    }
    function shiftRanks(t, g, delta) {
      t.nodes().forEach((v) => g.node(v).rank += delta);
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/network-simplex.js
var require_network_simplex = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/network-simplex.js"(exports, module2) {
    "use strict";
    var feasibleTree = require_feasible_tree();
    var slack = require_util2().slack;
    var initRank = require_util2().longestPath;
    var preorder = require_graphlib().alg.preorder;
    var postorder = require_graphlib().alg.postorder;
    var simplify = require_util().simplify;
    module2.exports = networkSimplex;
    networkSimplex.initLowLimValues = initLowLimValues;
    networkSimplex.initCutValues = initCutValues;
    networkSimplex.calcCutValue = calcCutValue;
    networkSimplex.leaveEdge = leaveEdge;
    networkSimplex.enterEdge = enterEdge;
    networkSimplex.exchangeEdges = exchangeEdges;
    function networkSimplex(g) {
      g = simplify(g);
      initRank(g);
      var t = feasibleTree(g);
      initLowLimValues(t);
      initCutValues(t, g);
      var e, f;
      while (e = leaveEdge(t)) {
        f = enterEdge(t, g, e);
        exchangeEdges(t, g, e, f);
      }
    }
    function initCutValues(t, g) {
      var vs = postorder(t, t.nodes());
      vs = vs.slice(0, vs.length - 1);
      vs.forEach((v) => assignCutValue(t, g, v));
    }
    function assignCutValue(t, g, child) {
      var childLab = t.node(child);
      var parent = childLab.parent;
      t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
    }
    function calcCutValue(t, g, child) {
      var childLab = t.node(child);
      var parent = childLab.parent;
      var childIsTail = true;
      var graphEdge = g.edge(child, parent);
      var cutValue = 0;
      if (!graphEdge) {
        childIsTail = false;
        graphEdge = g.edge(parent, child);
      }
      cutValue = graphEdge.weight;
      g.nodeEdges(child).forEach(function(e) {
        var isOutEdge = e.v === child, other = isOutEdge ? e.w : e.v;
        if (other !== parent) {
          var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e).weight;
          cutValue += pointsToHead ? otherWeight : -otherWeight;
          if (isTreeEdge(t, child, other)) {
            var otherCutValue = t.edge(child, other).cutvalue;
            cutValue += pointsToHead ? -otherCutValue : otherCutValue;
          }
        }
      });
      return cutValue;
    }
    function initLowLimValues(tree, root) {
      if (arguments.length < 2) {
        root = tree.nodes()[0];
      }
      dfsAssignLowLim(tree, {}, 1, root);
    }
    function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
      var low = nextLim;
      var label = tree.node(v);
      visited[v] = true;
      tree.neighbors(v).forEach(function(w) {
        if (!visited.hasOwnProperty(w)) {
          nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
        }
      });
      label.low = low;
      label.lim = nextLim++;
      if (parent) {
        label.parent = parent;
      } else {
        delete label.parent;
      }
      return nextLim;
    }
    function leaveEdge(tree) {
      return tree.edges().find((e) => tree.edge(e).cutvalue < 0);
    }
    function enterEdge(t, g, edge) {
      var v = edge.v;
      var w = edge.w;
      if (!g.hasEdge(v, w)) {
        v = edge.w;
        w = edge.v;
      }
      var vLabel = t.node(v);
      var wLabel = t.node(w);
      var tailLabel = vLabel;
      var flip2 = false;
      if (vLabel.lim > wLabel.lim) {
        tailLabel = wLabel;
        flip2 = true;
      }
      var candidates = g.edges().filter(function(edge2) {
        return flip2 === isDescendant(t, t.node(edge2.v), tailLabel) && flip2 !== isDescendant(t, t.node(edge2.w), tailLabel);
      });
      return candidates.reduce((acc, edge2) => {
        if (slack(g, edge2) < slack(g, acc)) {
          return edge2;
        }
        return acc;
      });
    }
    function exchangeEdges(t, g, e, f) {
      var v = e.v;
      var w = e.w;
      t.removeEdge(v, w);
      t.setEdge(f.v, f.w, {});
      initLowLimValues(t);
      initCutValues(t, g);
      updateRanks(t, g);
    }
    function updateRanks(t, g) {
      var root = t.nodes().find((v) => !g.node(v).parent);
      var vs = preorder(t, root);
      vs = vs.slice(1);
      vs.forEach(function(v) {
        var parent = t.node(v).parent, edge = g.edge(v, parent), flipped = false;
        if (!edge) {
          edge = g.edge(parent, v);
          flipped = true;
        }
        g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
      });
    }
    function isTreeEdge(tree, u, v) {
      return tree.hasEdge(u, v);
    }
    function isDescendant(tree, vLabel, rootLabel) {
      return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/rank/index.js
var require_rank = __commonJS({
  "node_modules/@dagrejs/dagre/lib/rank/index.js"(exports, module2) {
    "use strict";
    var rankUtil = require_util2();
    var longestPath = rankUtil.longestPath;
    var feasibleTree = require_feasible_tree();
    var networkSimplex = require_network_simplex();
    module2.exports = rank;
    function rank(g) {
      switch (g.graph().ranker) {
        case "network-simplex":
          networkSimplexRanker(g);
          break;
        case "tight-tree":
          tightTreeRanker(g);
          break;
        case "longest-path":
          longestPathRanker(g);
          break;
        default:
          networkSimplexRanker(g);
      }
    }
    var longestPathRanker = longestPath;
    function tightTreeRanker(g) {
      longestPath(g);
      feasibleTree(g);
    }
    function networkSimplexRanker(g) {
      networkSimplex(g);
    }
  }
});

// node_modules/@dagrejs/dagre/lib/parent-dummy-chains.js
var require_parent_dummy_chains = __commonJS({
  "node_modules/@dagrejs/dagre/lib/parent-dummy-chains.js"(exports, module2) {
    module2.exports = parentDummyChains;
    function parentDummyChains(g) {
      var postorderNums = postorder(g);
      g.graph().dummyChains.forEach(function(v) {
        var node = g.node(v);
        var edgeObj = node.edgeObj;
        var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
        var path = pathData.path;
        var lca = pathData.lca;
        var pathIdx = 0;
        var pathV = path[pathIdx];
        var ascending = true;
        while (v !== edgeObj.w) {
          node = g.node(v);
          if (ascending) {
            while ((pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {
              pathIdx++;
            }
            if (pathV === lca) {
              ascending = false;
            }
          }
          if (!ascending) {
            while (pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
              pathIdx++;
            }
            pathV = path[pathIdx];
          }
          g.setParent(v, pathV);
          v = g.successors(v)[0];
        }
      });
    }
    function findPath(g, postorderNums, v, w) {
      var vPath = [];
      var wPath = [];
      var low = Math.min(postorderNums[v].low, postorderNums[w].low);
      var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
      var parent;
      var lca;
      parent = v;
      do {
        parent = g.parent(parent);
        vPath.push(parent);
      } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
      lca = parent;
      parent = w;
      while ((parent = g.parent(parent)) !== lca) {
        wPath.push(parent);
      }
      return { path: vPath.concat(wPath.reverse()), lca };
    }
    function postorder(g) {
      var result = {};
      var lim = 0;
      function dfs(v) {
        var low = lim;
        g.children(v).forEach(dfs);
        result[v] = { low, lim: lim++ };
      }
      g.children().forEach(dfs);
      return result;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/nesting-graph.js
var require_nesting_graph = __commonJS({
  "node_modules/@dagrejs/dagre/lib/nesting-graph.js"(exports, module2) {
    var util = require_util();
    module2.exports = {
      run: run2,
      cleanup
    };
    function run2(g) {
      var root = util.addDummyNode(g, "root", {}, "_root");
      var depths = treeDepths(g);
      var height = Math.max(...Object.values(depths)) - 1;
      var nodeSep = 2 * height + 1;
      g.graph().nestingRoot = root;
      g.edges().forEach((e) => g.edge(e).minlen *= nodeSep);
      var weight = sumWeights(g) + 1;
      g.children().forEach(function(child) {
        dfs(g, root, nodeSep, weight, height, depths, child);
      });
      g.graph().nodeRankFactor = nodeSep;
    }
    function dfs(g, root, nodeSep, weight, height, depths, v) {
      var children2 = g.children(v);
      if (!children2.length) {
        if (v !== root) {
          g.setEdge(root, v, { weight: 0, minlen: nodeSep });
        }
        return;
      }
      var top2 = util.addBorderNode(g, "_bt");
      var bottom2 = util.addBorderNode(g, "_bb");
      var label = g.node(v);
      g.setParent(top2, v);
      label.borderTop = top2;
      g.setParent(bottom2, v);
      label.borderBottom = bottom2;
      children2.forEach(function(child) {
        dfs(g, root, nodeSep, weight, height, depths, child);
        var childNode = g.node(child);
        var childTop = childNode.borderTop ? childNode.borderTop : child;
        var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
        var thisWeight = childNode.borderTop ? weight : 2 * weight;
        var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
        g.setEdge(top2, childTop, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
        g.setEdge(childBottom, bottom2, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
      });
      if (!g.parent(v)) {
        g.setEdge(root, top2, { weight: 0, minlen: height + depths[v] });
      }
    }
    function treeDepths(g) {
      var depths = {};
      function dfs2(v, depth) {
        var children2 = g.children(v);
        if (children2 && children2.length) {
          children2.forEach((child) => dfs2(child, depth + 1));
        }
        depths[v] = depth;
      }
      g.children().forEach((v) => dfs2(v, 1));
      return depths;
    }
    function sumWeights(g) {
      return g.edges().reduce((acc, e) => acc + g.edge(e).weight, 0);
    }
    function cleanup(g) {
      var graphLabel = g.graph();
      g.removeNode(graphLabel.nestingRoot);
      delete graphLabel.nestingRoot;
      g.edges().forEach((e) => {
        var edge = g.edge(e);
        if (edge.nestingEdge) {
          g.removeEdge(e);
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/add-border-segments.js
var require_add_border_segments = __commonJS({
  "node_modules/@dagrejs/dagre/lib/add-border-segments.js"(exports, module2) {
    var util = require_util();
    module2.exports = addBorderSegments;
    function addBorderSegments(g) {
      function dfs(v) {
        var children2 = g.children(v);
        var node = g.node(v);
        if (children2.length) {
          children2.forEach(dfs);
        }
        if (node.hasOwnProperty("minRank")) {
          node.borderLeft = [];
          node.borderRight = [];
          for (var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank) {
            addBorderNode(g, "borderLeft", "_bl", v, node, rank);
            addBorderNode(g, "borderRight", "_br", v, node, rank);
          }
        }
      }
      g.children().forEach(dfs);
    }
    function addBorderNode(g, prop, prefix, sg, sgNode, rank) {
      var label = { width: 0, height: 0, rank, borderType: prop };
      var prev = sgNode[prop][rank - 1];
      var curr = util.addDummyNode(g, "border", label, prefix);
      sgNode[prop][rank] = curr;
      g.setParent(curr, sg);
      if (prev) {
        g.setEdge(prev, curr, { weight: 1 });
      }
    }
  }
});

// node_modules/@dagrejs/dagre/lib/coordinate-system.js
var require_coordinate_system = __commonJS({
  "node_modules/@dagrejs/dagre/lib/coordinate-system.js"(exports, module2) {
    "use strict";
    module2.exports = {
      adjust,
      undo
    };
    function adjust(g) {
      var rankDir = g.graph().rankdir.toLowerCase();
      if (rankDir === "lr" || rankDir === "rl") {
        swapWidthHeight(g);
      }
    }
    function undo(g) {
      var rankDir = g.graph().rankdir.toLowerCase();
      if (rankDir === "bt" || rankDir === "rl") {
        reverseY(g);
      }
      if (rankDir === "lr" || rankDir === "rl") {
        swapXY(g);
        swapWidthHeight(g);
      }
    }
    function swapWidthHeight(g) {
      g.nodes().forEach((v) => swapWidthHeightOne(g.node(v)));
      g.edges().forEach((e) => swapWidthHeightOne(g.edge(e)));
    }
    function swapWidthHeightOne(attrs) {
      var w = attrs.width;
      attrs.width = attrs.height;
      attrs.height = w;
    }
    function reverseY(g) {
      g.nodes().forEach((v) => reverseYOne(g.node(v)));
      g.edges().forEach(function(e) {
        var edge = g.edge(e);
        edge.points.forEach(reverseYOne);
        if (edge.hasOwnProperty("y")) {
          reverseYOne(edge);
        }
      });
    }
    function reverseYOne(attrs) {
      attrs.y = -attrs.y;
    }
    function swapXY(g) {
      g.nodes().forEach((v) => swapXYOne(g.node(v)));
      g.edges().forEach(function(e) {
        var edge = g.edge(e);
        edge.points.forEach(swapXYOne);
        if (edge.hasOwnProperty("x")) {
          swapXYOne(edge);
        }
      });
    }
    function swapXYOne(attrs) {
      var x = attrs.x;
      attrs.x = attrs.y;
      attrs.y = x;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/init-order.js
var require_init_order = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/init-order.js"(exports, module2) {
    "use strict";
    var util = require_util();
    module2.exports = initOrder;
    function initOrder(g) {
      var visited = {};
      var simpleNodes = g.nodes().filter((v) => !g.children(v).length);
      var maxRank = Math.max(...simpleNodes.map((v) => g.node(v).rank));
      var layers = util.range(maxRank + 1).map(() => []);
      function dfs(v) {
        if (visited[v])
          return;
        visited[v] = true;
        var node = g.node(v);
        layers[node.rank].push(v);
        g.successors(v).forEach(dfs);
      }
      var orderedVs = simpleNodes.sort((a, b) => g.node(a).rank - g.node(b).rank);
      orderedVs.forEach(dfs);
      return layers;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/cross-count.js
var require_cross_count = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/cross-count.js"(exports, module2) {
    "use strict";
    var zipObject = require_util().zipObject;
    module2.exports = crossCount;
    function crossCount(g, layering) {
      var cc = 0;
      for (var i = 1; i < layering.length; ++i) {
        cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);
      }
      return cc;
    }
    function twoLayerCrossCount(g, northLayer, southLayer) {
      var southPos = zipObject(southLayer, southLayer.map((v, i) => i));
      var southEntries = northLayer.flatMap((v) => {
        return g.outEdges(v).map((e) => {
          return { pos: southPos[e.w], weight: g.edge(e).weight };
        }).sort((a, b) => a.pos - b.pos);
      });
      var firstIndex = 1;
      while (firstIndex < southLayer.length)
        firstIndex <<= 1;
      var treeSize = 2 * firstIndex - 1;
      firstIndex -= 1;
      var tree = new Array(treeSize).fill(0);
      var cc = 0;
      southEntries.forEach((entry) => {
        var index = entry.pos + firstIndex;
        tree[index] += entry.weight;
        var weightSum = 0;
        while (index > 0) {
          if (index % 2) {
            weightSum += tree[index + 1];
          }
          index = index - 1 >> 1;
          tree[index] += entry.weight;
        }
        cc += entry.weight * weightSum;
      });
      return cc;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/barycenter.js
var require_barycenter = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/barycenter.js"(exports, module2) {
    module2.exports = barycenter;
    function barycenter(g, movable = []) {
      return movable.map((v) => {
        var inV = g.inEdges(v);
        if (!inV.length) {
          return { v };
        } else {
          var result = inV.reduce((acc, e) => {
            var edge = g.edge(e), nodeU = g.node(e.v);
            return {
              sum: acc.sum + edge.weight * nodeU.order,
              weight: acc.weight + edge.weight
            };
          }, { sum: 0, weight: 0 });
          return {
            v,
            barycenter: result.sum / result.weight,
            weight: result.weight
          };
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/resolve-conflicts.js
var require_resolve_conflicts = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/resolve-conflicts.js"(exports, module2) {
    "use strict";
    var util = require_util();
    module2.exports = resolveConflicts;
    function resolveConflicts(entries, cg) {
      var mappedEntries = {};
      entries.forEach((entry, i) => {
        var tmp = mappedEntries[entry.v] = {
          indegree: 0,
          "in": [],
          out: [],
          vs: [entry.v],
          i
        };
        if (entry.barycenter !== void 0) {
          tmp.barycenter = entry.barycenter;
          tmp.weight = entry.weight;
        }
      });
      cg.edges().forEach((e) => {
        var entryV = mappedEntries[e.v];
        var entryW = mappedEntries[e.w];
        if (entryV !== void 0 && entryW !== void 0) {
          entryW.indegree++;
          entryV.out.push(mappedEntries[e.w]);
        }
      });
      var sourceSet = Object.values(mappedEntries).filter((entry) => !entry.indegree);
      return doResolveConflicts(sourceSet);
    }
    function doResolveConflicts(sourceSet) {
      var entries = [];
      function handleIn(vEntry) {
        return function(uEntry) {
          if (uEntry.merged) {
            return;
          }
          if (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) {
            mergeEntries(vEntry, uEntry);
          }
        };
      }
      function handleOut(vEntry) {
        return function(wEntry) {
          wEntry["in"].push(vEntry);
          if (--wEntry.indegree === 0) {
            sourceSet.push(wEntry);
          }
        };
      }
      while (sourceSet.length) {
        var entry = sourceSet.pop();
        entries.push(entry);
        entry["in"].reverse().forEach(handleIn(entry));
        entry.out.forEach(handleOut(entry));
      }
      return entries.filter((entry2) => !entry2.merged).map((entry2) => {
        return util.pick(entry2, ["vs", "i", "barycenter", "weight"]);
      });
    }
    function mergeEntries(target, source) {
      var sum = 0;
      var weight = 0;
      if (target.weight) {
        sum += target.barycenter * target.weight;
        weight += target.weight;
      }
      if (source.weight) {
        sum += source.barycenter * source.weight;
        weight += source.weight;
      }
      target.vs = source.vs.concat(target.vs);
      target.barycenter = sum / weight;
      target.weight = weight;
      target.i = Math.min(source.i, target.i);
      source.merged = true;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/sort.js
var require_sort = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/sort.js"(exports, module2) {
    var util = require_util();
    module2.exports = sort;
    function sort(entries, biasRight) {
      var parts = util.partition(entries, function(entry) {
        return entry.hasOwnProperty("barycenter");
      });
      var sortable = parts.lhs, unsortable = parts.rhs.sort((a, b) => b.i - a.i), vs = [], sum = 0, weight = 0, vsIndex = 0;
      sortable.sort(compareWithBias(!!biasRight));
      vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      sortable.forEach(function(entry) {
        vsIndex += entry.vs.length;
        vs.push(entry.vs);
        sum += entry.barycenter * entry.weight;
        weight += entry.weight;
        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      });
      var result = { vs: vs.flat(true) };
      if (weight) {
        result.barycenter = sum / weight;
        result.weight = weight;
      }
      return result;
    }
    function consumeUnsortable(vs, unsortable, index) {
      var last;
      while (unsortable.length && (last = unsortable[unsortable.length - 1]).i <= index) {
        unsortable.pop();
        vs.push(last.vs);
        index++;
      }
      return index;
    }
    function compareWithBias(bias) {
      return function(entryV, entryW) {
        if (entryV.barycenter < entryW.barycenter) {
          return -1;
        } else if (entryV.barycenter > entryW.barycenter) {
          return 1;
        }
        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
      };
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/sort-subgraph.js
var require_sort_subgraph = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/sort-subgraph.js"(exports, module2) {
    var barycenter = require_barycenter();
    var resolveConflicts = require_resolve_conflicts();
    var sort = require_sort();
    module2.exports = sortSubgraph;
    function sortSubgraph(g, v, cg, biasRight) {
      var movable = g.children(v);
      var node = g.node(v);
      var bl = node ? node.borderLeft : void 0;
      var br = node ? node.borderRight : void 0;
      var subgraphs = {};
      if (bl) {
        movable = movable.filter((w) => w !== bl && w !== br);
      }
      var barycenters = barycenter(g, movable);
      barycenters.forEach(function(entry) {
        if (g.children(entry.v).length) {
          var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
          subgraphs[entry.v] = subgraphResult;
          if (subgraphResult.hasOwnProperty("barycenter")) {
            mergeBarycenters(entry, subgraphResult);
          }
        }
      });
      var entries = resolveConflicts(barycenters, cg);
      expandSubgraphs(entries, subgraphs);
      var result = sort(entries, biasRight);
      if (bl) {
        result.vs = [bl, result.vs, br].flat(true);
        if (g.predecessors(bl).length) {
          var blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
          if (!result.hasOwnProperty("barycenter")) {
            result.barycenter = 0;
            result.weight = 0;
          }
          result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
          result.weight += 2;
        }
      }
      return result;
    }
    function expandSubgraphs(entries, subgraphs) {
      entries.forEach(function(entry) {
        entry.vs = entry.vs.flatMap(function(v) {
          if (subgraphs[v]) {
            return subgraphs[v].vs;
          }
          return v;
        });
      });
    }
    function mergeBarycenters(target, other) {
      if (target.barycenter !== void 0) {
        target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
        target.weight += other.weight;
      } else {
        target.barycenter = other.barycenter;
        target.weight = other.weight;
      }
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/build-layer-graph.js
var require_build_layer_graph = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/build-layer-graph.js"(exports, module2) {
    var Graph = require_graphlib().Graph;
    var util = require_util();
    module2.exports = buildLayerGraph;
    function buildLayerGraph(g, rank, relationship) {
      var root = createRootNode2(g), result = new Graph({ compound: true }).setGraph({ root }).setDefaultNodeLabel(function(v) {
        return g.node(v);
      });
      g.nodes().forEach(function(v) {
        var node = g.node(v), parent = g.parent(v);
        if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
          result.setNode(v);
          result.setParent(v, parent || root);
          g[relationship](v).forEach(function(e) {
            var u = e.v === v ? e.w : e.v, edge = result.edge(u, v), weight = edge !== void 0 ? edge.weight : 0;
            result.setEdge(u, v, { weight: g.edge(e).weight + weight });
          });
          if (node.hasOwnProperty("minRank")) {
            result.setNode(v, {
              borderLeft: node.borderLeft[rank],
              borderRight: node.borderRight[rank]
            });
          }
        }
      });
      return result;
    }
    function createRootNode2(g) {
      var v;
      while (g.hasNode(v = util.uniqueId("_root")))
        ;
      return v;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/add-subgraph-constraints.js
var require_add_subgraph_constraints = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/add-subgraph-constraints.js"(exports, module2) {
    module2.exports = addSubgraphConstraints;
    function addSubgraphConstraints(g, cg, vs) {
      var prev = {}, rootPrev;
      vs.forEach(function(v) {
        var child = g.parent(v), parent, prevChild;
        while (child) {
          parent = g.parent(child);
          if (parent) {
            prevChild = prev[parent];
            prev[parent] = child;
          } else {
            prevChild = rootPrev;
            rootPrev = child;
          }
          if (prevChild && prevChild !== child) {
            cg.setEdge(prevChild, child);
            return;
          }
          child = parent;
        }
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/order/index.js
var require_order = __commonJS({
  "node_modules/@dagrejs/dagre/lib/order/index.js"(exports, module2) {
    "use strict";
    var initOrder = require_init_order();
    var crossCount = require_cross_count();
    var sortSubgraph = require_sort_subgraph();
    var buildLayerGraph = require_build_layer_graph();
    var addSubgraphConstraints = require_add_subgraph_constraints();
    var Graph = require_graphlib().Graph;
    var util = require_util();
    module2.exports = order2;
    function order2(g) {
      var maxRank = util.maxRank(g), downLayerGraphs = buildLayerGraphs(g, util.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, util.range(maxRank - 1, -1, -1), "outEdges");
      var layering = initOrder(g);
      assignOrder(g, layering);
      var bestCC = Number.POSITIVE_INFINITY, best;
      for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
        sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
        layering = util.buildLayerMatrix(g);
        var cc = crossCount(g, layering);
        if (cc < bestCC) {
          lastBest = 0;
          best = Object.assign({}, layering);
          bestCC = cc;
        }
      }
      assignOrder(g, best);
    }
    function buildLayerGraphs(g, ranks, relationship) {
      return ranks.map(function(rank) {
        return buildLayerGraph(g, rank, relationship);
      });
    }
    function sweepLayerGraphs(layerGraphs, biasRight) {
      var cg = new Graph();
      layerGraphs.forEach(function(lg) {
        var root = lg.graph().root;
        var sorted = sortSubgraph(lg, root, cg, biasRight);
        sorted.vs.forEach((v, i) => lg.node(v).order = i);
        addSubgraphConstraints(lg, cg, sorted.vs);
      });
    }
    function assignOrder(g, layering) {
      Object.values(layering).forEach((layer) => layer.forEach((v, i) => g.node(v).order = i));
    }
  }
});

// node_modules/@dagrejs/dagre/lib/position/bk.js
var require_bk = __commonJS({
  "node_modules/@dagrejs/dagre/lib/position/bk.js"(exports, module2) {
    "use strict";
    var Graph = require_graphlib().Graph;
    var util = require_util();
    module2.exports = {
      positionX,
      findType1Conflicts,
      findType2Conflicts,
      addConflict,
      hasConflict,
      verticalAlignment,
      horizontalCompaction,
      alignCoordinates,
      findSmallestWidthAlignment,
      balance
    };
    function findType1Conflicts(g, layering) {
      var conflicts = {};
      function visitLayer(prevLayer, layer) {
        var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = layer[layer.length - 1];
        layer.forEach(function(v, i) {
          var w = findOtherInnerSegmentNode(g, v), k1 = w ? g.node(w).order : prevLayerLength;
          if (w || v === lastNode) {
            layer.slice(scanPos, i + 1).forEach(function(scanNode) {
              g.predecessors(scanNode).forEach(function(u) {
                var uLabel = g.node(u), uPos = uLabel.order;
                if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {
                  addConflict(conflicts, u, scanNode);
                }
              });
            });
            scanPos = i + 1;
            k0 = k1;
          }
        });
        return layer;
      }
      layering.reduce(visitLayer);
      return conflicts;
    }
    function findType2Conflicts(g, layering) {
      var conflicts = {};
      function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
        var v;
        util.range(southPos, southEnd).forEach(function(i) {
          v = south[i];
          if (g.node(v).dummy) {
            g.predecessors(v).forEach(function(u) {
              var uNode = g.node(u);
              if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                addConflict(conflicts, u, v);
              }
            });
          }
        });
      }
      function visitLayer(north, south) {
        var prevNorthPos = -1, nextNorthPos, southPos = 0;
        south.forEach(function(v, southLookahead) {
          if (g.node(v).dummy === "border") {
            var predecessors = g.predecessors(v);
            if (predecessors.length) {
              nextNorthPos = g.node(predecessors[0]).order;
              scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
              southPos = southLookahead;
              prevNorthPos = nextNorthPos;
            }
          }
          scan(south, southPos, south.length, nextNorthPos, north.length);
        });
        return south;
      }
      layering.reduce(visitLayer);
      return conflicts;
    }
    function findOtherInnerSegmentNode(g, v) {
      if (g.node(v).dummy) {
        return g.predecessors(v).find((u) => g.node(u).dummy);
      }
    }
    function addConflict(conflicts, v, w) {
      if (v > w) {
        var tmp = v;
        v = w;
        w = tmp;
      }
      var conflictsV = conflicts[v];
      if (!conflictsV) {
        conflicts[v] = conflictsV = {};
      }
      conflictsV[w] = true;
    }
    function hasConflict(conflicts, v, w) {
      if (v > w) {
        var tmp = v;
        v = w;
        w = tmp;
      }
      return !!conflicts[v] && conflicts[v].hasOwnProperty(w);
    }
    function verticalAlignment(g, layering, conflicts, neighborFn) {
      var root = {}, align = {}, pos = {};
      layering.forEach(function(layer) {
        layer.forEach(function(v, order2) {
          root[v] = v;
          align[v] = v;
          pos[v] = order2;
        });
      });
      layering.forEach(function(layer) {
        var prevIdx = -1;
        layer.forEach(function(v) {
          var ws = neighborFn(v);
          if (ws.length) {
            ws = ws.sort((a, b) => pos[a] - pos[b]);
            var mp = (ws.length - 1) / 2;
            for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
              var w = ws[i];
              if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {
                align[w] = v;
                align[v] = root[v] = root[w];
                prevIdx = pos[w];
              }
            }
          }
        });
      });
      return { root, align };
    }
    function horizontalCompaction(g, layering, root, align, reverseSep) {
      var xs = {}, blockG = buildBlockGraph(g, layering, root, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
      function iterate(setXsFunc, nextNodesFunc) {
        var stack = blockG.nodes();
        var elem = stack.pop();
        var visited = {};
        while (elem) {
          if (visited[elem]) {
            setXsFunc(elem);
          } else {
            visited[elem] = true;
            stack.push(elem);
            stack = stack.concat(nextNodesFunc(elem));
          }
          elem = stack.pop();
        }
      }
      function pass1(elem) {
        xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
          return Math.max(acc, xs[e.v] + blockG.edge(e));
        }, 0);
      }
      function pass2(elem) {
        var min2 = blockG.outEdges(elem).reduce(function(acc, e) {
          return Math.min(acc, xs[e.w] - blockG.edge(e));
        }, Number.POSITIVE_INFINITY);
        var node = g.node(elem);
        if (min2 !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
          xs[elem] = Math.max(xs[elem], min2);
        }
      }
      iterate(pass1, blockG.predecessors.bind(blockG));
      iterate(pass2, blockG.successors.bind(blockG));
      Object.keys(align).forEach((v) => xs[v] = xs[root[v]]);
      return xs;
    }
    function buildBlockGraph(g, layering, root, reverseSep) {
      var blockGraph = new Graph(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
      layering.forEach(function(layer) {
        var u;
        layer.forEach(function(v) {
          var vRoot = root[v];
          blockGraph.setNode(vRoot);
          if (u) {
            var uRoot = root[u], prevMax = blockGraph.edge(uRoot, vRoot);
            blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
          }
          u = v;
        });
      });
      return blockGraph;
    }
    function findSmallestWidthAlignment(g, xss) {
      return Object.values(xss).reduce((currentMinAndXs, xs) => {
        var max2 = Number.NEGATIVE_INFINITY;
        var min2 = Number.POSITIVE_INFINITY;
        Object.entries(xs).forEach(([v, x]) => {
          var halfWidth = width(g, v) / 2;
          max2 = Math.max(x + halfWidth, max2);
          min2 = Math.min(x - halfWidth, min2);
        });
        const newMin = max2 - min2;
        if (newMin < currentMinAndXs[0]) {
          currentMinAndXs = [newMin, xs];
        }
        return currentMinAndXs;
      }, [Number.POSITIVE_INFINITY, null])[1];
    }
    function alignCoordinates(xss, alignTo) {
      var alignToVals = Object.values(alignTo), alignToMin = Math.min(...alignToVals), alignToMax = Math.max(...alignToVals);
      ["u", "d"].forEach(function(vert) {
        ["l", "r"].forEach(function(horiz) {
          var alignment = vert + horiz, xs = xss[alignment];
          if (xs === alignTo)
            return;
          var xsVals = Object.values(xs);
          let delta = alignToMin - Math.min(...xsVals);
          if (horiz !== "l") {
            delta = alignToMax - Math.max(...xsVals);
          }
          if (delta) {
            xss[alignment] = util.mapValues(xs, (x) => x + delta);
          }
        });
      });
    }
    function balance(xss, align) {
      return util.mapValues(xss.ul, function(num, v) {
        if (align) {
          return xss[align.toLowerCase()][v];
        } else {
          var xs = Object.values(xss).map((xs2) => xs2[v]).sort((a, b) => a - b);
          return (xs[1] + xs[2]) / 2;
        }
      });
    }
    function positionX(g) {
      var layering = util.buildLayerMatrix(g);
      var conflicts = Object.assign(findType1Conflicts(g, layering), findType2Conflicts(g, layering));
      var xss = {};
      var adjustedLayering;
      ["u", "d"].forEach(function(vert) {
        adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
        ["l", "r"].forEach(function(horiz) {
          if (horiz === "r") {
            adjustedLayering = adjustedLayering.map((inner) => {
              return Object.values(inner).reverse();
            });
          }
          var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
          var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
          var xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === "r");
          if (horiz === "r") {
            xs = util.mapValues(xs, (x) => -x);
          }
          xss[vert + horiz] = xs;
        });
      });
      var smallestWidth = findSmallestWidthAlignment(g, xss);
      alignCoordinates(xss, smallestWidth);
      return balance(xss, g.graph().align);
    }
    function sep(nodeSep, edgeSep, reverseSep) {
      return function(g, v, w) {
        var vLabel = g.node(v);
        var wLabel = g.node(w);
        var sum = 0;
        var delta;
        sum += vLabel.width / 2;
        if (vLabel.hasOwnProperty("labelpos")) {
          switch (vLabel.labelpos.toLowerCase()) {
            case "l":
              delta = -vLabel.width / 2;
              break;
            case "r":
              delta = vLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += wLabel.width / 2;
        if (wLabel.hasOwnProperty("labelpos")) {
          switch (wLabel.labelpos.toLowerCase()) {
            case "l":
              delta = wLabel.width / 2;
              break;
            case "r":
              delta = -wLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        return sum;
      };
    }
    function width(g, v) {
      return g.node(v).width;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/position/index.js
var require_position = __commonJS({
  "node_modules/@dagrejs/dagre/lib/position/index.js"(exports, module2) {
    "use strict";
    var util = require_util();
    var positionX = require_bk().positionX;
    module2.exports = position;
    function position(g) {
      g = util.asNonCompoundGraph(g);
      positionY(g);
      Object.entries(positionX(g)).forEach(([v, x]) => g.node(v).x = x);
    }
    function positionY(g) {
      var layering = util.buildLayerMatrix(g);
      var rankSep = g.graph().ranksep;
      var prevY = 0;
      layering.forEach(function(layer) {
        const maxHeight = layer.reduce((acc, v) => {
          const height = g.node(v).height;
          if (acc > height) {
            return acc;
          } else {
            return height;
          }
        }, 0);
        layer.forEach((v) => g.node(v).y = prevY + maxHeight / 2);
        prevY += maxHeight + rankSep;
      });
    }
  }
});

// node_modules/@dagrejs/dagre/lib/layout.js
var require_layout = __commonJS({
  "node_modules/@dagrejs/dagre/lib/layout.js"(exports, module2) {
    "use strict";
    var acyclic = require_acyclic();
    var normalize = require_normalize();
    var rank = require_rank();
    var normalizeRanks = require_util().normalizeRanks;
    var parentDummyChains = require_parent_dummy_chains();
    var removeEmptyRanks = require_util().removeEmptyRanks;
    var nestingGraph = require_nesting_graph();
    var addBorderSegments = require_add_border_segments();
    var coordinateSystem = require_coordinate_system();
    var order2 = require_order();
    var position = require_position();
    var util = require_util();
    var Graph = require_graphlib().Graph;
    module2.exports = layout;
    function layout(g, opts) {
      var time = opts && opts.debugTiming ? util.time : util.notime;
      time("layout", function() {
        var layoutGraph = time("  buildLayoutGraph", function() {
          return buildLayoutGraph(g);
        });
        time("  runLayout", function() {
          runLayout(layoutGraph, time);
        });
        time("  updateInputGraph", function() {
          updateInputGraph(g, layoutGraph);
        });
      });
    }
    function runLayout(g, time) {
      time("    makeSpaceForEdgeLabels", function() {
        makeSpaceForEdgeLabels(g);
      });
      time("    removeSelfEdges", function() {
        removeSelfEdges(g);
      });
      time("    acyclic", function() {
        acyclic.run(g);
      });
      time("    nestingGraph.run", function() {
        nestingGraph.run(g);
      });
      time("    rank", function() {
        rank(util.asNonCompoundGraph(g));
      });
      time("    injectEdgeLabelProxies", function() {
        injectEdgeLabelProxies(g);
      });
      time("    removeEmptyRanks", function() {
        removeEmptyRanks(g);
      });
      time("    nestingGraph.cleanup", function() {
        nestingGraph.cleanup(g);
      });
      time("    normalizeRanks", function() {
        normalizeRanks(g);
      });
      time("    assignRankMinMax", function() {
        assignRankMinMax(g);
      });
      time("    removeEdgeLabelProxies", function() {
        removeEdgeLabelProxies(g);
      });
      time("    normalize.run", function() {
        normalize.run(g);
      });
      time("    parentDummyChains", function() {
        parentDummyChains(g);
      });
      time("    addBorderSegments", function() {
        addBorderSegments(g);
      });
      time("    order", function() {
        order2(g);
      });
      time("    insertSelfEdges", function() {
        insertSelfEdges(g);
      });
      time("    adjustCoordinateSystem", function() {
        coordinateSystem.adjust(g);
      });
      time("    position", function() {
        position(g);
      });
      time("    positionSelfEdges", function() {
        positionSelfEdges(g);
      });
      time("    removeBorderNodes", function() {
        removeBorderNodes(g);
      });
      time("    normalize.undo", function() {
        normalize.undo(g);
      });
      time("    fixupEdgeLabelCoords", function() {
        fixupEdgeLabelCoords(g);
      });
      time("    undoCoordinateSystem", function() {
        coordinateSystem.undo(g);
      });
      time("    translateGraph", function() {
        translateGraph(g);
      });
      time("    assignNodeIntersects", function() {
        assignNodeIntersects(g);
      });
      time("    reversePoints", function() {
        reversePointsForReversedEdges(g);
      });
      time("    acyclic.undo", function() {
        acyclic.undo(g);
      });
    }
    function updateInputGraph(inputGraph, layoutGraph) {
      inputGraph.nodes().forEach((v) => {
        var inputLabel = inputGraph.node(v);
        var layoutLabel = layoutGraph.node(v);
        if (inputLabel) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
          inputLabel.rank = layoutLabel.rank;
          if (layoutGraph.children(v).length) {
            inputLabel.width = layoutLabel.width;
            inputLabel.height = layoutLabel.height;
          }
        }
      });
      inputGraph.edges().forEach((e) => {
        var inputLabel = inputGraph.edge(e);
        var layoutLabel = layoutGraph.edge(e);
        inputLabel.points = layoutLabel.points;
        if (layoutLabel.hasOwnProperty("x")) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
        }
      });
      inputGraph.graph().width = layoutGraph.graph().width;
      inputGraph.graph().height = layoutGraph.graph().height;
    }
    var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
    var nodeNumAttrs = ["width", "height"];
    var nodeDefaults = { width: 0, height: 0 };
    var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
    var edgeDefaults = {
      minlen: 1,
      weight: 1,
      width: 0,
      height: 0,
      labeloffset: 10,
      labelpos: "r"
    };
    var edgeAttrs = ["labelpos"];
    function buildLayoutGraph(inputGraph) {
      var g = new Graph({ multigraph: true, compound: true });
      var graph = canonicalize(inputGraph.graph());
      g.setGraph(Object.assign({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), util.pick(graph, graphAttrs)));
      inputGraph.nodes().forEach((v) => {
        var node = canonicalize(inputGraph.node(v));
        const newNode = selectNumberAttrs(node, nodeNumAttrs);
        Object.keys(nodeDefaults).forEach((k) => {
          if (newNode[k] === void 0) {
            newNode[k] = nodeDefaults[k];
          }
        });
        g.setNode(v, newNode);
        g.setParent(v, inputGraph.parent(v));
      });
      inputGraph.edges().forEach((e) => {
        var edge = canonicalize(inputGraph.edge(e));
        g.setEdge(e, Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), util.pick(edge, edgeAttrs)));
      });
      return g;
    }
    function makeSpaceForEdgeLabels(g) {
      var graph = g.graph();
      graph.ranksep /= 2;
      g.edges().forEach((e) => {
        var edge = g.edge(e);
        edge.minlen *= 2;
        if (edge.labelpos.toLowerCase() !== "c") {
          if (graph.rankdir === "TB" || graph.rankdir === "BT") {
            edge.width += edge.labeloffset;
          } else {
            edge.height += edge.labeloffset;
          }
        }
      });
    }
    function injectEdgeLabelProxies(g) {
      g.edges().forEach((e) => {
        var edge = g.edge(e);
        if (edge.width && edge.height) {
          var v = g.node(e.v);
          var w = g.node(e.w);
          var label = { rank: (w.rank - v.rank) / 2 + v.rank, e };
          util.addDummyNode(g, "edge-proxy", label, "_ep");
        }
      });
    }
    function assignRankMinMax(g) {
      var maxRank = 0;
      g.nodes().forEach((v) => {
        var node = g.node(v);
        if (node.borderTop) {
          node.minRank = g.node(node.borderTop).rank;
          node.maxRank = g.node(node.borderBottom).rank;
          maxRank = Math.max(maxRank, node.maxRank);
        }
      });
      g.graph().maxRank = maxRank;
    }
    function removeEdgeLabelProxies(g) {
      g.nodes().forEach((v) => {
        var node = g.node(v);
        if (node.dummy === "edge-proxy") {
          g.edge(node.e).labelRank = node.rank;
          g.removeNode(v);
        }
      });
    }
    function translateGraph(g) {
      var minX = Number.POSITIVE_INFINITY;
      var maxX = 0;
      var minY = Number.POSITIVE_INFINITY;
      var maxY = 0;
      var graphLabel = g.graph();
      var marginX = graphLabel.marginx || 0;
      var marginY = graphLabel.marginy || 0;
      function getExtremes(attrs) {
        var x = attrs.x;
        var y = attrs.y;
        var w = attrs.width;
        var h = attrs.height;
        minX = Math.min(minX, x - w / 2);
        maxX = Math.max(maxX, x + w / 2);
        minY = Math.min(minY, y - h / 2);
        maxY = Math.max(maxY, y + h / 2);
      }
      g.nodes().forEach((v) => getExtremes(g.node(v)));
      g.edges().forEach((e) => {
        var edge = g.edge(e);
        if (edge.hasOwnProperty("x")) {
          getExtremes(edge);
        }
      });
      minX -= marginX;
      minY -= marginY;
      g.nodes().forEach((v) => {
        var node = g.node(v);
        node.x -= minX;
        node.y -= minY;
      });
      g.edges().forEach((e) => {
        var edge = g.edge(e);
        edge.points.forEach((p) => {
          p.x -= minX;
          p.y -= minY;
        });
        if (edge.hasOwnProperty("x")) {
          edge.x -= minX;
        }
        if (edge.hasOwnProperty("y")) {
          edge.y -= minY;
        }
      });
      graphLabel.width = maxX - minX + marginX;
      graphLabel.height = maxY - minY + marginY;
    }
    function assignNodeIntersects(g) {
      g.edges().forEach((e) => {
        var edge = g.edge(e);
        var nodeV = g.node(e.v);
        var nodeW = g.node(e.w);
        var p1, p2;
        if (!edge.points) {
          edge.points = [];
          p1 = nodeW;
          p2 = nodeV;
        } else {
          p1 = edge.points[0];
          p2 = edge.points[edge.points.length - 1];
        }
        edge.points.unshift(util.intersectRect(nodeV, p1));
        edge.points.push(util.intersectRect(nodeW, p2));
      });
    }
    function fixupEdgeLabelCoords(g) {
      g.edges().forEach((e) => {
        var edge = g.edge(e);
        if (edge.hasOwnProperty("x")) {
          if (edge.labelpos === "l" || edge.labelpos === "r") {
            edge.width -= edge.labeloffset;
          }
          switch (edge.labelpos) {
            case "l":
              edge.x -= edge.width / 2 + edge.labeloffset;
              break;
            case "r":
              edge.x += edge.width / 2 + edge.labeloffset;
              break;
          }
        }
      });
    }
    function reversePointsForReversedEdges(g) {
      g.edges().forEach((e) => {
        var edge = g.edge(e);
        if (edge.reversed) {
          edge.points.reverse();
        }
      });
    }
    function removeBorderNodes(g) {
      g.nodes().forEach((v) => {
        if (g.children(v).length) {
          var node = g.node(v);
          var t = g.node(node.borderTop);
          var b = g.node(node.borderBottom);
          var l = g.node(node.borderLeft[node.borderLeft.length - 1]);
          var r = g.node(node.borderRight[node.borderRight.length - 1]);
          node.width = Math.abs(r.x - l.x);
          node.height = Math.abs(b.y - t.y);
          node.x = l.x + node.width / 2;
          node.y = t.y + node.height / 2;
        }
      });
      g.nodes().forEach((v) => {
        if (g.node(v).dummy === "border") {
          g.removeNode(v);
        }
      });
    }
    function removeSelfEdges(g) {
      g.edges().forEach((e) => {
        if (e.v === e.w) {
          var node = g.node(e.v);
          if (!node.selfEdges) {
            node.selfEdges = [];
          }
          node.selfEdges.push({ e, label: g.edge(e) });
          g.removeEdge(e);
        }
      });
    }
    function insertSelfEdges(g) {
      var layers = util.buildLayerMatrix(g);
      layers.forEach((layer) => {
        var orderShift = 0;
        layer.forEach((v, i) => {
          var node = g.node(v);
          node.order = i + orderShift;
          (node.selfEdges || []).forEach((selfEdge) => {
            util.addDummyNode(g, "selfedge", {
              width: selfEdge.label.width,
              height: selfEdge.label.height,
              rank: node.rank,
              order: i + ++orderShift,
              e: selfEdge.e,
              label: selfEdge.label
            }, "_se");
          });
          delete node.selfEdges;
        });
      });
    }
    function positionSelfEdges(g) {
      g.nodes().forEach((v) => {
        var node = g.node(v);
        if (node.dummy === "selfedge") {
          var selfNode = g.node(node.e.v);
          var x = selfNode.x + selfNode.width / 2;
          var y = selfNode.y;
          var dx = node.x - x;
          var dy = selfNode.height / 2;
          g.setEdge(node.e, node.label);
          g.removeNode(v);
          node.label.points = [
            { x: x + 2 * dx / 3, y: y - dy },
            { x: x + 5 * dx / 6, y: y - dy },
            { x: x + dx, y },
            { x: x + 5 * dx / 6, y: y + dy },
            { x: x + 2 * dx / 3, y: y + dy }
          ];
          node.label.x = node.x;
          node.label.y = node.y;
        }
      });
    }
    function selectNumberAttrs(obj, attrs) {
      return util.mapValues(util.pick(obj, attrs), Number);
    }
    function canonicalize(attrs) {
      var newAttrs = {};
      if (attrs) {
        Object.entries(attrs).forEach(([k, v]) => {
          if (typeof k === "string") {
            k = k.toLowerCase();
          }
          newAttrs[k] = v;
        });
      }
      return newAttrs;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/debug.js
var require_debug = __commonJS({
  "node_modules/@dagrejs/dagre/lib/debug.js"(exports, module2) {
    var util = require_util();
    var Graph = require_graphlib().Graph;
    module2.exports = {
      debugOrdering
    };
    function debugOrdering(g) {
      var layerMatrix = util.buildLayerMatrix(g);
      var h = new Graph({ compound: true, multigraph: true }).setGraph({});
      g.nodes().forEach(function(v) {
        h.setNode(v, { label: v });
        h.setParent(v, "layer" + g.node(v).rank);
      });
      g.edges().forEach(function(e) {
        h.setEdge(e.v, e.w, {}, e.name);
      });
      layerMatrix.forEach(function(layer, i) {
        var layerV = "layer" + i;
        h.setNode(layerV, { rank: "same" });
        layer.reduce(function(u, v) {
          h.setEdge(u, v, { style: "invis" });
          return v;
        });
      });
      return h;
    }
  }
});

// node_modules/@dagrejs/dagre/lib/version.js
var require_version2 = __commonJS({
  "node_modules/@dagrejs/dagre/lib/version.js"(exports, module2) {
    module2.exports = "1.0.2";
  }
});

// node_modules/@dagrejs/dagre/index.js
var require_dagre = __commonJS({
  "node_modules/@dagrejs/dagre/index.js"(exports, module2) {
    module2.exports = {
      graphlib: require_graphlib(),
      layout: require_layout(),
      debug: require_debug(),
      util: {
        time: require_util().time,
        notime: require_util().notime
      },
      version: require_version2()
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianClipperPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// node_modules/deepmerge-ts/dist/node/index.mjs
var actions = {
  defaultMerge: Symbol("deepmerge-ts: default merge"),
  skip: Symbol("deepmerge-ts: skip")
};
var actionsInto = {
  defaultMerge: actions.defaultMerge
};
function defaultMetaDataUpdater(previousMeta, metaMeta) {
  return metaMeta;
}
function getObjectType(object) {
  if (typeof object !== "object" || object === null) {
    return 0;
  }
  if (Array.isArray(object)) {
    return 2;
  }
  if (isRecord(object)) {
    return 1;
  }
  if (object instanceof Set) {
    return 3;
  }
  if (object instanceof Map) {
    return 4;
  }
  return 5;
}
function getKeys(objects) {
  const keys = /* @__PURE__ */ new Set();
  for (const object of objects) {
    for (const key of [
      ...Object.keys(object),
      ...Object.getOwnPropertySymbols(object)
    ]) {
      keys.add(key);
    }
  }
  return keys;
}
function objectHasProperty(object, property) {
  return typeof object === "object" && Object.prototype.propertyIsEnumerable.call(object, property);
}
function getIterableOfIterables(iterables) {
  return {
    *[Symbol.iterator]() {
      for (const iterable of iterables) {
        for (const value of iterable) {
          yield value;
        }
      }
    }
  };
}
var validRecordToStringValues = /* @__PURE__ */ new Set([
  "[object Object]",
  "[object Module]"
]);
function isRecord(value) {
  if (!validRecordToStringValues.has(Object.prototype.toString.call(value))) {
    return false;
  }
  const { constructor } = value;
  if (constructor === void 0) {
    return true;
  }
  const prototype = constructor.prototype;
  if (prototype === null || typeof prototype !== "object" || !validRecordToStringValues.has(Object.prototype.toString.call(prototype))) {
    return false;
  }
  if (!prototype.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function mergeRecords$2(values, utils, meta) {
  const result = {};
  for (const key of getKeys(values)) {
    const propValues = [];
    for (const value of values) {
      if (objectHasProperty(value, key)) {
        propValues.push(value[key]);
      }
    }
    if (propValues.length === 0) {
      continue;
    }
    const updatedMeta = utils.metaDataUpdater(meta, {
      key,
      parents: values
    });
    const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);
    if (propertyResult === actions.skip) {
      continue;
    }
    if (key === "__proto__") {
      Object.defineProperty(result, key, {
        value: propertyResult,
        configurable: true,
        enumerable: true,
        writable: true
      });
    } else {
      result[key] = propertyResult;
    }
  }
  return result;
}
function mergeArrays$2(values) {
  return values.flat();
}
function mergeSets$2(values) {
  return new Set(getIterableOfIterables(values));
}
function mergeMaps$2(values) {
  return new Map(getIterableOfIterables(values));
}
function mergeOthers$2(values) {
  return values[values.length - 1];
}
var defaultMergeFunctions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  mergeRecords: mergeRecords$2,
  mergeArrays: mergeArrays$2,
  mergeSets: mergeSets$2,
  mergeMaps: mergeMaps$2,
  mergeOthers: mergeOthers$2
});
function deepmerge(...objects) {
  return deepmergeCustom({})(...objects);
}
function deepmergeCustom(options, rootMetaData) {
  const utils = getUtils(options, customizedDeepmerge);
  function customizedDeepmerge(...objects) {
    return mergeUnknowns(objects, utils, rootMetaData);
  }
  return customizedDeepmerge;
}
function getUtils(options, customizedDeepmerge) {
  var _a, _b;
  return {
    defaultMergeFunctions,
    mergeFunctions: {
      ...defaultMergeFunctions,
      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.prototype.hasOwnProperty.call(defaultMergeFunctions, key)).map(([key, option]) => option === false ? [key, mergeOthers$2] : [key, option]))
    },
    metaDataUpdater: (_a = options.metaDataUpdater) !== null && _a !== void 0 ? _a : defaultMetaDataUpdater,
    deepmerge: customizedDeepmerge,
    useImplicitDefaultMerging: (_b = options.enableImplicitDefaultMerging) !== null && _b !== void 0 ? _b : false,
    actions
  };
}
function mergeUnknowns(values, utils, meta) {
  if (values.length === 0) {
    return void 0;
  }
  if (values.length === 1) {
    return mergeOthers$1(values, utils, meta);
  }
  const type = getObjectType(values[0]);
  if (type !== 0 && type !== 5) {
    for (let m_index = 1; m_index < values.length; m_index++) {
      if (getObjectType(values[m_index]) === type) {
        continue;
      }
      return mergeOthers$1(values, utils, meta);
    }
  }
  switch (type) {
    case 1: {
      return mergeRecords$1(values, utils, meta);
    }
    case 2: {
      return mergeArrays$1(values, utils, meta);
    }
    case 3: {
      return mergeSets$1(values, utils, meta);
    }
    case 4: {
      return mergeMaps$1(values, utils, meta);
    }
    default: {
      return mergeOthers$1(values, utils, meta);
    }
  }
}
function mergeRecords$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeRecords(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords) {
    return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);
  }
  return result;
}
function mergeArrays$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeArrays(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays) {
    return utils.defaultMergeFunctions.mergeArrays(values);
  }
  return result;
}
function mergeSets$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeSets(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets) {
    return utils.defaultMergeFunctions.mergeSets(values);
  }
  return result;
}
function mergeMaps$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeMaps(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps) {
    return utils.defaultMergeFunctions.mergeMaps(values);
  }
  return result;
}
function mergeOthers$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeOthers(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers) {
    return utils.defaultMergeFunctions.mergeOthers(values);
  }
  return result;
}

// src/settings/types.ts
var SectionPosition = {
  PREPEND: "prepend",
  APPEND: "append"
};
var DEFAULT_SETTINGS = {
  dailyNoteHeading: "",
  weeklyNoteHeading: "",
  tags: "",
  timestampFormat: "HH:mm",
  dateFormat: "MM/DD/YY",
  dailyOpenOnWrite: false,
  useDailyNote: true,
  dailyPosition: SectionPosition.APPEND,
  useWeeklyNote: false,
  weeklyPosition: SectionPosition.APPEND,
  weeklyOpenOnWrite: false,
  dailyEntryTemplateLocation: "",
  weeklyEntryTemplateLocation: "",
  topicEntryTemplateLocation: "",
  topicPosition: SectionPosition.APPEND,
  topicOpenOnWrite: false,
  markdownSettings: {
    h1: "##",
    h2: "##",
    h3: "###",
    h4: "####",
    h5: "#####",
    h6: "######"
  },
  advanced: false,
  advancedStorageFolder: "clippings",
  captureComments: false,
  experimentalCanvas: false,
  experimentalBookmarkletComment: false
};

// src/utils/templateutils.ts
var import_obsidian = require("obsidian");
async function getTemplateContents(app, templatePath) {
  const { metadataCache, vault } = app;
  const normalizedTemplatePath = (0, import_obsidian.normalizePath)(templatePath != null ? templatePath : "");
  if (templatePath === "/") {
    return Promise.resolve("");
  }
  let templateContents = "";
  try {
    const templateFile = metadataCache.getFirstLinkpathDest(normalizedTemplatePath, "");
    if (templateFile) {
      templateContents = await vault.cachedRead(templateFile);
    }
    return `${templateContents}
`;
  } catch (err) {
    console.error(`Failed to read the clipper entry template '${normalizedTemplatePath}'`, err);
    new import_obsidian.Notice("Failed to read the Obsidian Clipper daily note entry template configured in Settings");
    throw Error("Template File Missing");
  }
}
function applyTemplateTransformations(title, url, tags, time, date, content = "", comment = "", rawTemplateContents) {
  const templateContents = rawTemplateContents.replace(/{{\s*title\s*}}/gi, title).replace(/{{\s*url\s*}}/gi, url).replace(/{{\s*tags\s*}}/gi, tags).replace(/{{\s*content\s*}}/gi, content).replace(/{{\s*comment\s*}}/gi, comment).replace(/{{\s*time\s*}}/gi, time).replace(/{{\s*date\s*}}/gi, date);
  return templateContents;
}

// src/clippeddata.ts
var ClippedData = class {
  constructor(title, url, settings2, app, data = "", comment = "") {
    this.title = title;
    this.url = url;
    this.title = title;
    this.url = url;
    if (data !== "") {
      this.data = data;
    }
    this.comment = comment;
    const tagJoins = [];
    settings2.tags.split(",").forEach((t) => {
      tagJoins.push(`#${t}`);
    });
    this.tags = tagJoins.join(" ");
    this.settings = settings2;
    this.app = app;
    this.timeStamp = window.moment().format(this.settings.timestampFormat);
    this.date = window.moment().format(this.settings.dateFormat);
  }
  async formattedEntry(template) {
    let formattedData = "";
    if (template && template != "") {
      const rawTemplateContents = await getTemplateContents(this.app, template);
      formattedData = applyTemplateTransformations(this.title, this.url, this.tags, this.timeStamp, this.date, this.data, this.comment, rawTemplateContents);
    } else {
      if (!this.data) {
        formattedData = `- [ ] [${this.title}](${this.url}) ${this.tags}

---`;
      } else {
        if (this.settings.advanced) {
          formattedData = `- [ ] ${this.title} ${this.tags}
${this.data}

---`;
        } else {
          formattedData = `- [ ] [${this.title}](${this.url}) ${this.tags}
${this.data}

---`;
        }
      }
    }
    return formattedData;
  }
  getUrl() {
    return this.url;
  }
  getEntryContent() {
    return this.data;
  }
};

// src/periodicnotes/dailyperiodicnoteentry.ts
var import_obsidian_daily_notes_interface = __toESM(require_main());

// src/periodicnotes/periodicnoteentry.ts
var import_obsidian4 = require("obsidian");

// src/abstracts/noteentry.ts
var import_obsidian3 = require("obsidian");

// src/periodicnotes/filewriter.ts
var import_obsidian2 = require("obsidian");

// node_modules/parse-domain/serialized-tries/icann.js
var icann_default = "ac>com,edu,gov,net,mil,org<ad>nom<ae>co,net,org,sch,ac,gov,mil<aero>accident-investigation,accident-prevention,aerobatic,aeroclub,aerodrome,agents,aircraft,airline,airport,air-surveillance,airtraffic,air-traffic-control,ambulance,amusement,association,author,ballooning,broker,caa,cargo,catering,certification,championship,charter,civilaviation,club,conference,consultant,consulting,control,council,crew,design,dgca,educator,emergency,engine,engineer,entertainment,equipment,exchange,express,federation,flight,fuel,gliding,government,groundhandling,group,hanggliding,homebuilt,insurance,journal,journalist,leasing,logistics,magazine,maintenance,media,microlight,modelling,navigation,parachuting,paragliding,passenger-association,pilot,press,production,recreation,repbody,res,research,rotorcraft,safety,scientist,services,show,skydiving,software,student,trader,trading,trainer,union,workinggroup,works<af>gov,com,org,net,edu<ag>com,org,net,co,nom<ai>off,com,net,org<al>com,edu,gov,mil,net,org<am>co,com,commune,net,org<ao>ed,gv,og,co,pb,it<aq,ar>bet,com,coop,edu,gob,gov,int,mil,musica,mutual,net,org,senasa,tur<arpa>e164,in-addr,ip6,iris,uri,urn<as>gov<asia,at>ac>sth<co,gv,or<au>com,net,org,edu>act,catholic,nsw>schools<nt,qld,sa,tas,vic,wa<gov>qld,sa,tas,vic,wa<asn,id,info,conf,oz,act,nsw,nt,qld,sa,tas,vic,wa<aw>com<ax,az>com,net,int,gov,org,edu,info,pp,mil,name,pro,biz<ba>com,edu,gov,mil,net,org<bb>biz,co,com,edu,gov,info,net,org,store,tv<bd>*<be>ac<bf>gov<bg>a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,0,1,2,3,4,5,6,7,8,9<bh>com,edu,net,org,gov<bi>co,com,edu,or,org<biz,bj>asso,barreau,gouv<bm>com,edu,gov,net,org<bn>com,edu,gov,net,org<bo>com,edu,gob,int,org,net,mil,tv,web,academia,agro,arte,blog,bolivia,ciencia,cooperativa,democracia,deporte,ecologia,economia,empresa,indigena,industria,info,medicina,movimiento,musica,natural,nombre,noticias,patria,politica,profesional,plurinacional,pueblo,revista,salud,tecnologia,tksat,transporte,wiki<br>9guacu,abc,adm,adv,agr,aju,am,anani,aparecida,app,arq,art,ato,b,barueri,belem,bhz,bib,bio,blog,bmd,boavista,bsb,campinagrande,campinas,caxias,cim,cng,cnt,com,contagem,coop,coz,cri,cuiaba,curitiba,def,des,det,dev,ecn,eco,edu,emp,enf,eng,esp,etc,eti,far,feira,flog,floripa,fm,fnd,fortal,fot,foz,fst,g12,geo,ggf,goiania,gov>ac,al,am,ap,ba,ce,df,es,go,ma,mg,ms,mt,pa,pb,pe,pi,pr,rj,rn,ro,rr,rs,sc,se,sp,to<gru,imb,ind,inf,jab,jampa,jdf,joinville,jor,jus,leg,lel,log,londrina,macapa,maceio,manaus,maringa,mat,med,mil,morena,mp,mus,natal,net,niteroi,nom>*<not,ntr,odo,ong,org,osasco,palmas,poa,ppg,pro,psc,psi,pvh,qsl,radio,rec,recife,rep,ribeirao,rio,riobranco,riopreto,salvador,sampa,santamaria,santoandre,saobernardo,saogonca,seg,sjc,slg,slz,sorocaba,srv,taxi,tc,tec,teo,the,tmp,trd,tur,tv,udi,vet,vix,vlog,wiki,zlg<bs>com,net,org,edu,gov<bt>com,edu,gov,net,org<bv,bw>co,org<by>gov,mil,com,of<bz>com,net,org,edu,gov<ca>ab,bc,mb,nb,nf,nl,ns,nt,nu,on,pe,qc,sk,yk,gc<cat,cc,cd>gov<cf,cg,ch,ci>org,or,com,co,edu,ed,ac,net,go,asso,xn--aroport-bya,int,presse,md,gouv<ck>*,!www<cl>co,gob,gov,mil<cm>co,com,gov,net<cn>ac,com,edu,gov,net,org,mil,xn--55qx5d,xn--io0a7i,xn--od0alg,ah,bj,cq,fj,gd,gs,gz,gx,ha,hb,he,hi,hl,hn,jl,js,jx,ln,nm,nx,qh,sc,sd,sh,sn,sx,tj,xj,xz,yn,zj,hk,mo,tw<co>arts,com,edu,firm,gov,info,int,mil,net,nom,org,rec,web<com,coop,cr>ac,co,ed,fi,go,or,sa<cu>com,edu,org,net,gov,inf<cv>com,edu,int,nome,org<cw>com,edu,net,org<cx>gov<cy>ac,biz,com,ekloges,gov,ltd,mil,net,org,press,pro,tm<cz,de,dj,dk,dm>com,net,org,edu,gov<do>art,com,edu,gob,gov,mil,net,org,sld,web<dz>art,asso,com,edu,gov,org,net,pol,soc,tm<ec>com,info,net,fin,k12,med,pro,org,edu,gov,gob,mil<edu,ee>edu,gov,riik,lib,med,com,pri,aip,org,fie<eg>com,edu,eun,gov,mil,name,net,org,sci<er>*<es>com,nom,org,gob,edu<et>com,gov,org,edu,biz,name,info,net<eu,fi>aland<fj>ac,biz,com,gov,info,mil,name,net,org,pro<fk>*<fm>com,edu,net,org<fo,fr>asso,com,gouv,nom,prd,tm,aeroport,avocat,avoues,cci,chambagri,chirurgiens-dentistes,experts-comptables,geometre-expert,greta,huissier-justice,medecin,notaires,pharmacien,port,veterinaire<ga,gb,gd>edu,gov<ge>com,edu,gov,org,mil,net,pvt<gf,gg>co,net,org<gh>com,edu,gov,org,mil<gi>com,ltd,gov,mod,edu,org<gl>co,com,edu,net,org<gm,gn>ac,com,edu,gov,org,net<gov,gp>com,net,mobi,edu,org,asso<gq,gr>com,edu,net,org,gov<gs,gt>com,edu,gob,ind,mil,net,org<gu>com,edu,gov,guam,info,net,org,web<gw,gy>co,com,edu,gov,net,org<hk>com,edu,gov,idv,net,org,xn--55qx5d,xn--wcvs22d,xn--lcvr32d,xn--mxtq1m,xn--gmqw5a,xn--ciqpn,xn--gmq050i,xn--zf0avx,xn--io0a7i,xn--mk0axi,xn--od0alg,xn--od0aq3b,xn--tn0ag,xn--uc0atv,xn--uc0ay4a<hm,hn>com,edu,org,net,mil,gob<hr>iz,from,name,com<ht>com,shop,firm,info,adult,net,pro,org,med,art,coop,pol,asso,edu,rel,gouv,perso<hu>co,info,org,priv,sport,tm,2000,agrar,bolt,casino,city,erotica,erotika,film,forum,games,hotel,ingatlan,jogasz,konyvelo,lakas,media,news,reklam,sex,shop,suli,szex,tozsde,utazas,video<id>ac,biz,co,desa,go,mil,my,net,or,ponpes,sch,web<ie>gov<il>ac,co,gov,idf,k12,muni,net,org<im>ac,co>ltd,plc<com,net,org,tt,tv<in>co,firm,net,org,gen,ind,nic,ac,edu,res,gov,mil<info,int>eu<io>com<iq>gov,edu,mil,com,org,net<ir>ac,co,gov,id,net,org,sch,xn--mgba3a4f16a,xn--mgba3a4fra<is>net,com,edu,gov,org,int<it>gov,edu,abr,abruzzo,aosta-valley,aostavalley,bas,basilicata,cal,calabria,cam,campania,emilia-romagna,emiliaromagna,emr,friuli-v-giulia,friuli-ve-giulia,friuli-vegiulia,friuli-venezia-giulia,friuli-veneziagiulia,friuli-vgiulia,friuliv-giulia,friulive-giulia,friulivegiulia,friulivenezia-giulia,friuliveneziagiulia,friulivgiulia,fvg,laz,lazio,lig,liguria,lom,lombardia,lombardy,lucania,mar,marche,mol,molise,piedmont,piemonte,pmn,pug,puglia,sar,sardegna,sardinia,sic,sicilia,sicily,taa,tos,toscana,trentin-sud-tirol,xn--trentin-sd-tirol-rzb,trentin-sudtirol,xn--trentin-sdtirol-7vb,trentin-sued-tirol,trentin-suedtirol,trentino-a-adige,trentino-aadige,trentino-alto-adige,trentino-altoadige,trentino-s-tirol,trentino-stirol,trentino-sud-tirol,xn--trentino-sd-tirol-c3b,trentino-sudtirol,xn--trentino-sdtirol-szb,trentino-sued-tirol,trentino-suedtirol,trentino,trentinoa-adige,trentinoaadige,trentinoalto-adige,trentinoaltoadige,trentinos-tirol,trentinostirol,trentinosud-tirol,xn--trentinosd-tirol-rzb,trentinosudtirol,xn--trentinosdtirol-7vb,trentinosued-tirol,trentinosuedtirol,trentinsud-tirol,xn--trentinsd-tirol-6vb,trentinsudtirol,xn--trentinsdtirol-nsb,trentinsued-tirol,trentinsuedtirol,tuscany,umb,umbria,val-d-aosta,val-daosta,vald-aosta,valdaosta,valle-aosta,valle-d-aosta,valle-daosta,valleaosta,valled-aosta,valledaosta,vallee-aoste,xn--valle-aoste-ebb,vallee-d-aoste,xn--valle-d-aoste-ehb,valleeaoste,xn--valleaoste-e7a,valleedaoste,xn--valledaoste-ebb,vao,vda,ven,veneto,ag,agrigento,al,alessandria,alto-adige,altoadige,an,ancona,andria-barletta-trani,andria-trani-barletta,andriabarlettatrani,andriatranibarletta,ao,aosta,aoste,ap,aq,aquila,ar,arezzo,ascoli-piceno,ascolipiceno,asti,at,av,avellino,ba,balsan-sudtirol,xn--balsan-sdtirol-nsb,balsan-suedtirol,balsan,bari,barletta-trani-andria,barlettatraniandria,belluno,benevento,bergamo,bg,bi,biella,bl,bn,bo,bologna,bolzano-altoadige,bolzano,bozen-sudtirol,xn--bozen-sdtirol-2ob,bozen-suedtirol,bozen,br,brescia,brindisi,bs,bt,bulsan-sudtirol,xn--bulsan-sdtirol-nsb,bulsan-suedtirol,bulsan,bz,ca,cagliari,caltanissetta,campidano-medio,campidanomedio,campobasso,carbonia-iglesias,carboniaiglesias,carrara-massa,carraramassa,caserta,catania,catanzaro,cb,ce,cesena-forli,xn--cesena-forl-mcb,cesenaforli,xn--cesenaforl-i8a,ch,chieti,ci,cl,cn,co,como,cosenza,cr,cremona,crotone,cs,ct,cuneo,cz,dell-ogliastra,dellogliastra,en,enna,fc,fe,fermo,ferrara,fg,fi,firenze,florence,fm,foggia,forli-cesena,xn--forl-cesena-fcb,forlicesena,xn--forlcesena-c8a,fr,frosinone,ge,genoa,genova,go,gorizia,gr,grosseto,iglesias-carbonia,iglesiascarbonia,im,imperia,is,isernia,kr,la-spezia,laquila,laspezia,latina,lc,le,lecce,lecco,li,livorno,lo,lodi,lt,lu,lucca,macerata,mantova,massa-carrara,massacarrara,matera,mb,mc,me,medio-campidano,mediocampidano,messina,mi,milan,milano,mn,mo,modena,monza-brianza,monza-e-della-brianza,monza,monzabrianza,monzaebrianza,monzaedellabrianza,ms,mt,na,naples,napoli,no,novara,nu,nuoro,og,ogliastra,olbia-tempio,olbiatempio,or,oristano,ot,pa,padova,padua,palermo,parma,pavia,pc,pd,pe,perugia,pesaro-urbino,pesarourbino,pescara,pg,pi,piacenza,pisa,pistoia,pn,po,pordenone,potenza,pr,prato,pt,pu,pv,pz,ra,ragusa,ravenna,rc,re,reggio-calabria,reggio-emilia,reggiocalabria,reggioemilia,rg,ri,rieti,rimini,rm,rn,ro,roma,rome,rovigo,sa,salerno,sassari,savona,si,siena,siracusa,so,sondrio,sp,sr,ss,suedtirol,xn--sdtirol-n2a,sv,ta,taranto,te,tempio-olbia,tempioolbia,teramo,terni,tn,to,torino,tp,tr,trani-andria-barletta,trani-barletta-andria,traniandriabarletta,tranibarlettaandria,trapani,trento,treviso,trieste,ts,turin,tv,ud,udine,urbino-pesaro,urbinopesaro,va,varese,vb,vc,ve,venezia,venice,verbania,vercelli,verona,vi,vibo-valentia,vibovalentia,vicenza,viterbo,vr,vs,vt,vv<je>co,net,org<jm>*<jo>com,org,net,edu,sch,gov,mil,name<jobs,jp>ac,ad,co,ed,go,gr,lg,ne,or,aichi>aisai,ama,anjo,asuke,chiryu,chita,fuso,gamagori,handa,hazu,hekinan,higashiura,ichinomiya,inazawa,inuyama,isshiki,iwakura,kanie,kariya,kasugai,kira,kiyosu,komaki,konan,kota,mihama,miyoshi,nishio,nisshin,obu,oguchi,oharu,okazaki,owariasahi,seto,shikatsu,shinshiro,shitara,tahara,takahama,tobishima,toei,togo,tokai,tokoname,toyoake,toyohashi,toyokawa,toyone,toyota,tsushima,yatomi<akita>akita,daisen,fujisato,gojome,hachirogata,happou,higashinaruse,honjo,honjyo,ikawa,kamikoani,kamioka,katagami,kazuno,kitaakita,kosaka,kyowa,misato,mitane,moriyoshi,nikaho,noshiro,odate,oga,ogata,semboku,yokote,yurihonjo<aomori>aomori,gonohe,hachinohe,hashikami,hiranai,hirosaki,itayanagi,kuroishi,misawa,mutsu,nakadomari,noheji,oirase,owani,rokunohe,sannohe,shichinohe,shingo,takko,towada,tsugaru,tsuruta<chiba>abiko,asahi,chonan,chosei,choshi,chuo,funabashi,futtsu,hanamigawa,ichihara,ichikawa,ichinomiya,inzai,isumi,kamagaya,kamogawa,kashiwa,katori,katsuura,kimitsu,kisarazu,kozaki,kujukuri,kyonan,matsudo,midori,mihama,minamiboso,mobara,mutsuzawa,nagara,nagareyama,narashino,narita,noda,oamishirasato,omigawa,onjuku,otaki,sakae,sakura,shimofusa,shirako,shiroi,shisui,sodegaura,sosa,tako,tateyama,togane,tohnosho,tomisato,urayasu,yachimata,yachiyo,yokaichiba,yokoshibahikari,yotsukaido<ehime>ainan,honai,ikata,imabari,iyo,kamijima,kihoku,kumakogen,masaki,matsuno,matsuyama,namikata,niihama,ozu,saijo,seiyo,shikokuchuo,tobe,toon,uchiko,uwajima,yawatahama<fukui>echizen,eiheiji,fukui,ikeda,katsuyama,mihama,minamiechizen,obama,ohi,ono,sabae,sakai,takahama,tsuruga,wakasa<fukuoka>ashiya,buzen,chikugo,chikuho,chikujo,chikushino,chikuzen,chuo,dazaifu,fukuchi,hakata,higashi,hirokawa,hisayama,iizuka,inatsuki,kaho,kasuga,kasuya,kawara,keisen,koga,kurate,kurogi,kurume,minami,miyako,miyama,miyawaka,mizumaki,munakata,nakagawa,nakama,nishi,nogata,ogori,okagaki,okawa,oki,omuta,onga,onojo,oto,saigawa,sasaguri,shingu,shinyoshitomi,shonai,soeda,sue,tachiarai,tagawa,takata,toho,toyotsu,tsuiki,ukiha,umi,usui,yamada,yame,yanagawa,yukuhashi<fukushima>aizubange,aizumisato,aizuwakamatsu,asakawa,bandai,date,fukushima,furudono,futaba,hanawa,higashi,hirata,hirono,iitate,inawashiro,ishikawa,iwaki,izumizaki,kagamiishi,kaneyama,kawamata,kitakata,kitashiobara,koori,koriyama,kunimi,miharu,mishima,namie,nango,nishiaizu,nishigo,okuma,omotego,ono,otama,samegawa,shimogo,shirakawa,showa,soma,sukagawa,taishin,tamakawa,tanagura,tenei,yabuki,yamato,yamatsuri,yanaizu,yugawa<gifu>anpachi,ena,gifu,ginan,godo,gujo,hashima,hichiso,hida,higashishirakawa,ibigawa,ikeda,kakamigahara,kani,kasahara,kasamatsu,kawaue,kitagata,mino,minokamo,mitake,mizunami,motosu,nakatsugawa,ogaki,sakahogi,seki,sekigahara,shirakawa,tajimi,takayama,tarui,toki,tomika,wanouchi,yamagata,yaotsu,yoro<gunma>annaka,chiyoda,fujioka,higashiagatsuma,isesaki,itakura,kanna,kanra,katashina,kawaba,kiryu,kusatsu,maebashi,meiwa,midori,minakami,naganohara,nakanojo,nanmoku,numata,oizumi,ora,ota,shibukawa,shimonita,shinto,showa,takasaki,takayama,tamamura,tatebayashi,tomioka,tsukiyono,tsumagoi,ueno,yoshioka<hiroshima>asaminami,daiwa,etajima,fuchu,fukuyama,hatsukaichi,higashihiroshima,hongo,jinsekikogen,kaita,kui,kumano,kure,mihara,miyoshi,naka,onomichi,osakikamijima,otake,saka,sera,seranishi,shinichi,shobara,takehara<hokkaido>abashiri,abira,aibetsu,akabira,akkeshi,asahikawa,ashibetsu,ashoro,assabu,atsuma,bibai,biei,bifuka,bihoro,biratori,chippubetsu,chitose,date,ebetsu,embetsu,eniwa,erimo,esan,esashi,fukagawa,fukushima,furano,furubira,haboro,hakodate,hamatonbetsu,hidaka,higashikagura,higashikawa,hiroo,hokuryu,hokuto,honbetsu,horokanai,horonobe,ikeda,imakane,ishikari,iwamizawa,iwanai,kamifurano,kamikawa,kamishihoro,kamisunagawa,kamoenai,kayabe,kembuchi,kikonai,kimobetsu,kitahiroshima,kitami,kiyosato,koshimizu,kunneppu,kuriyama,kuromatsunai,kushiro,kutchan,kyowa,mashike,matsumae,mikasa,minamifurano,mombetsu,moseushi,mukawa,muroran,naie,nakagawa,nakasatsunai,nakatombetsu,nanae,nanporo,nayoro,nemuro,niikappu,niki,nishiokoppe,noboribetsu,numata,obihiro,obira,oketo,okoppe,otaru,otobe,otofuke,otoineppu,oumu,ozora,pippu,rankoshi,rebun,rikubetsu,rishiri,rishirifuji,saroma,sarufutsu,shakotan,shari,shibecha,shibetsu,shikabe,shikaoi,shimamaki,shimizu,shimokawa,shinshinotsu,shintoku,shiranuka,shiraoi,shiriuchi,sobetsu,sunagawa,taiki,takasu,takikawa,takinoue,teshikaga,tobetsu,tohma,tomakomai,tomari,toya,toyako,toyotomi,toyoura,tsubetsu,tsukigata,urakawa,urausu,uryu,utashinai,wakkanai,wassamu,yakumo,yoichi<hyogo>aioi,akashi,ako,amagasaki,aogaki,asago,ashiya,awaji,fukusaki,goshiki,harima,himeji,ichikawa,inagawa,itami,kakogawa,kamigori,kamikawa,kasai,kasuga,kawanishi,miki,minamiawaji,nishinomiya,nishiwaki,ono,sanda,sannan,sasayama,sayo,shingu,shinonsen,shiso,sumoto,taishi,taka,takarazuka,takasago,takino,tamba,tatsuno,toyooka,yabu,yashiro,yoka,yokawa<ibaraki>ami,asahi,bando,chikusei,daigo,fujishiro,hitachi,hitachinaka,hitachiomiya,hitachiota,ibaraki,ina,inashiki,itako,iwama,joso,kamisu,kasama,kashima,kasumigaura,koga,miho,mito,moriya,naka,namegata,oarai,ogawa,omitama,ryugasaki,sakai,sakuragawa,shimodate,shimotsuma,shirosato,sowa,suifu,takahagi,tamatsukuri,tokai,tomobe,tone,toride,tsuchiura,tsukuba,uchihara,ushiku,yachiyo,yamagata,yawara,yuki<ishikawa>anamizu,hakui,hakusan,kaga,kahoku,kanazawa,kawakita,komatsu,nakanoto,nanao,nomi,nonoichi,noto,shika,suzu,tsubata,tsurugi,uchinada,wajima<iwate>fudai,fujisawa,hanamaki,hiraizumi,hirono,ichinohe,ichinoseki,iwaizumi,iwate,joboji,kamaishi,kanegasaki,karumai,kawai,kitakami,kuji,kunohe,kuzumaki,miyako,mizusawa,morioka,ninohe,noda,ofunato,oshu,otsuchi,rikuzentakata,shiwa,shizukuishi,sumita,tanohata,tono,yahaba,yamada<kagawa>ayagawa,higashikagawa,kanonji,kotohira,manno,marugame,mitoyo,naoshima,sanuki,tadotsu,takamatsu,tonosho,uchinomi,utazu,zentsuji<kagoshima>akune,amami,hioki,isa,isen,izumi,kagoshima,kanoya,kawanabe,kinko,kouyama,makurazaki,matsumoto,minamitane,nakatane,nishinoomote,satsumasendai,soo,tarumizu,yusui<kanagawa>aikawa,atsugi,ayase,chigasaki,ebina,fujisawa,hadano,hakone,hiratsuka,isehara,kaisei,kamakura,kiyokawa,matsuda,minamiashigara,miura,nakai,ninomiya,odawara,oi,oiso,sagamihara,samukawa,tsukui,yamakita,yamato,yokosuka,yugawara,zama,zushi<kochi>aki,geisei,hidaka,higashitsuno,ino,kagami,kami,kitagawa,kochi,mihara,motoyama,muroto,nahari,nakamura,nankoku,nishitosa,niyodogawa,ochi,okawa,otoyo,otsuki,sakawa,sukumo,susaki,tosa,tosashimizu,toyo,tsuno,umaji,yasuda,yusuhara<kumamoto>amakusa,arao,aso,choyo,gyokuto,kamiamakusa,kikuchi,kumamoto,mashiki,mifune,minamata,minamioguni,nagasu,nishihara,oguni,ozu,sumoto,takamori,uki,uto,yamaga,yamato,yatsushiro<kyoto>ayabe,fukuchiyama,higashiyama,ide,ine,joyo,kameoka,kamo,kita,kizu,kumiyama,kyotamba,kyotanabe,kyotango,maizuru,minami,minamiyamashiro,miyazu,muko,nagaokakyo,nakagyo,nantan,oyamazaki,sakyo,seika,tanabe,uji,ujitawara,wazuka,yamashina,yawata<mie>asahi,inabe,ise,kameyama,kawagoe,kiho,kisosaki,kiwa,komono,kumano,kuwana,matsusaka,meiwa,mihama,minamiise,misugi,miyama,nabari,shima,suzuka,tado,taiki,taki,tamaki,toba,tsu,udono,ureshino,watarai,yokkaichi<miyagi>furukawa,higashimatsushima,ishinomaki,iwanuma,kakuda,kami,kawasaki,marumori,matsushima,minamisanriku,misato,murata,natori,ogawara,ohira,onagawa,osaki,rifu,semine,shibata,shichikashuku,shikama,shiogama,shiroishi,tagajo,taiwa,tome,tomiya,wakuya,watari,yamamoto,zao<miyazaki>aya,ebino,gokase,hyuga,kadogawa,kawaminami,kijo,kitagawa,kitakata,kitaura,kobayashi,kunitomi,kushima,mimata,miyakonojo,miyazaki,morotsuka,nichinan,nishimera,nobeoka,saito,shiiba,shintomi,takaharu,takanabe,takazaki,tsuno<nagano>achi,agematsu,anan,aoki,asahi,azumino,chikuhoku,chikuma,chino,fujimi,hakuba,hara,hiraya,iida,iijima,iiyama,iizuna,ikeda,ikusaka,ina,karuizawa,kawakami,kiso,kisofukushima,kitaaiki,komagane,komoro,matsukawa,matsumoto,miasa,minamiaiki,minamimaki,minamiminowa,minowa,miyada,miyota,mochizuki,nagano,nagawa,nagiso,nakagawa,nakano,nozawaonsen,obuse,ogawa,okaya,omachi,omi,ookuwa,ooshika,otaki,otari,sakae,sakaki,saku,sakuho,shimosuwa,shinanomachi,shiojiri,suwa,suzaka,takagi,takamori,takayama,tateshina,tatsuno,togakushi,togura,tomi,ueda,wada,yamagata,yamanouchi,yasaka,yasuoka<nagasaki>chijiwa,futsu,goto,hasami,hirado,iki,isahaya,kawatana,kuchinotsu,matsuura,nagasaki,obama,omura,oseto,saikai,sasebo,seihi,shimabara,shinkamigoto,togitsu,tsushima,unzen<nara>ando,gose,heguri,higashiyoshino,ikaruga,ikoma,kamikitayama,kanmaki,kashiba,kashihara,katsuragi,kawai,kawakami,kawanishi,koryo,kurotaki,mitsue,miyake,nara,nosegawa,oji,ouda,oyodo,sakurai,sango,shimoichi,shimokitayama,shinjo,soni,takatori,tawaramoto,tenkawa,tenri,uda,yamatokoriyama,yamatotakada,yamazoe,yoshino<niigata>aga,agano,gosen,itoigawa,izumozaki,joetsu,kamo,kariwa,kashiwazaki,minamiuonuma,mitsuke,muika,murakami,myoko,nagaoka,niigata,ojiya,omi,sado,sanjo,seiro,seirou,sekikawa,shibata,tagami,tainai,tochio,tokamachi,tsubame,tsunan,uonuma,yahiko,yoita,yuzawa<oita>beppu,bungoono,bungotakada,hasama,hiji,himeshima,hita,kamitsue,kokonoe,kuju,kunisaki,kusu,oita,saiki,taketa,tsukumi,usa,usuki,yufu<okayama>akaiwa,asakuchi,bizen,hayashima,ibara,kagamino,kasaoka,kibichuo,kumenan,kurashiki,maniwa,misaki,nagi,niimi,nishiawakura,okayama,satosho,setouchi,shinjo,shoo,soja,takahashi,tamano,tsuyama,wake,yakage<okinawa>aguni,ginowan,ginoza,gushikami,haebaru,higashi,hirara,iheya,ishigaki,ishikawa,itoman,izena,kadena,kin,kitadaito,kitanakagusuku,kumejima,kunigami,minamidaito,motobu,nago,naha,nakagusuku,nakijin,nanjo,nishihara,ogimi,okinawa,onna,shimoji,taketomi,tarama,tokashiki,tomigusuku,tonaki,urasoe,uruma,yaese,yomitan,yonabaru,yonaguni,zamami<osaka>abeno,chihayaakasaka,chuo,daito,fujiidera,habikino,hannan,higashiosaka,higashisumiyoshi,higashiyodogawa,hirakata,ibaraki,ikeda,izumi,izumiotsu,izumisano,kadoma,kaizuka,kanan,kashiwara,katano,kawachinagano,kishiwada,kita,kumatori,matsubara,minato,minoh,misaki,moriguchi,neyagawa,nishi,nose,osakasayama,sakai,sayama,sennan,settsu,shijonawate,shimamoto,suita,tadaoka,taishi,tajiri,takaishi,takatsuki,tondabayashi,toyonaka,toyono,yao<saga>ariake,arita,fukudomi,genkai,hamatama,hizen,imari,kamimine,kanzaki,karatsu,kashima,kitagata,kitahata,kiyama,kouhoku,kyuragi,nishiarita,ogi,omachi,ouchi,saga,shiroishi,taku,tara,tosu,yoshinogari<saitama>arakawa,asaka,chichibu,fujimi,fujimino,fukaya,hanno,hanyu,hasuda,hatogaya,hatoyama,hidaka,higashichichibu,higashimatsuyama,honjo,ina,iruma,iwatsuki,kamiizumi,kamikawa,kamisato,kasukabe,kawagoe,kawaguchi,kawajima,kazo,kitamoto,koshigaya,kounosu,kuki,kumagaya,matsubushi,minano,misato,miyashiro,miyoshi,moroyama,nagatoro,namegawa,niiza,ogano,ogawa,ogose,okegawa,omiya,otaki,ranzan,ryokami,saitama,sakado,satte,sayama,shiki,shiraoka,soka,sugito,toda,tokigawa,tokorozawa,tsurugashima,urawa,warabi,yashio,yokoze,yono,yorii,yoshida,yoshikawa,yoshimi<shiga>aisho,gamo,higashiomi,hikone,koka,konan,kosei,koto,kusatsu,maibara,moriyama,nagahama,nishiazai,notogawa,omihachiman,otsu,ritto,ryuoh,takashima,takatsuki,torahime,toyosato,yasu<shimane>akagi,ama,gotsu,hamada,higashiizumo,hikawa,hikimi,izumo,kakinoki,masuda,matsue,misato,nishinoshima,ohda,okinoshima,okuizumo,shimane,tamayu,tsuwano,unnan,yakumo,yasugi,yatsuka<shizuoka>arai,atami,fuji,fujieda,fujikawa,fujinomiya,fukuroi,gotemba,haibara,hamamatsu,higashiizu,ito,iwata,izu,izunokuni,kakegawa,kannami,kawanehon,kawazu,kikugawa,kosai,makinohara,matsuzaki,minamiizu,mishima,morimachi,nishiizu,numazu,omaezaki,shimada,shimizu,shimoda,shizuoka,susono,yaizu,yoshida<tochigi>ashikaga,bato,haga,ichikai,iwafune,kaminokawa,kanuma,karasuyama,kuroiso,mashiko,mibu,moka,motegi,nasu,nasushiobara,nikko,nishikata,nogi,ohira,ohtawara,oyama,sakura,sano,shimotsuke,shioya,takanezawa,tochigi,tsuga,ujiie,utsunomiya,yaita<tokushima>aizumi,anan,ichiba,itano,kainan,komatsushima,matsushige,mima,minami,miyoshi,mugi,nakagawa,naruto,sanagochi,shishikui,tokushima,wajiki<tokyo>adachi,akiruno,akishima,aogashima,arakawa,bunkyo,chiyoda,chofu,chuo,edogawa,fuchu,fussa,hachijo,hachioji,hamura,higashikurume,higashimurayama,higashiyamato,hino,hinode,hinohara,inagi,itabashi,katsushika,kita,kiyose,kodaira,koganei,kokubunji,komae,koto,kouzushima,kunitachi,machida,meguro,minato,mitaka,mizuho,musashimurayama,musashino,nakano,nerima,ogasawara,okutama,ome,oshima,ota,setagaya,shibuya,shinagawa,shinjuku,suginami,sumida,tachikawa,taito,tama,toshima<tottori>chizu,hino,kawahara,koge,kotoura,misasa,nanbu,nichinan,sakaiminato,tottori,wakasa,yazu,yonago<toyama>asahi,fuchu,fukumitsu,funahashi,himi,imizu,inami,johana,kamiichi,kurobe,nakaniikawa,namerikawa,nanto,nyuzen,oyabe,taira,takaoka,tateyama,toga,tonami,toyama,unazuki,uozu,yamada<wakayama>arida,aridagawa,gobo,hashimoto,hidaka,hirogawa,inami,iwade,kainan,kamitonda,katsuragi,kimino,kinokawa,kitayama,koya,koza,kozagawa,kudoyama,kushimoto,mihama,misato,nachikatsuura,shingu,shirahama,taiji,tanabe,wakayama,yuasa,yura<yamagata>asahi,funagata,higashine,iide,kahoku,kaminoyama,kaneyama,kawanishi,mamurogawa,mikawa,murayama,nagai,nakayama,nanyo,nishikawa,obanazawa,oe,oguni,ohkura,oishida,sagae,sakata,sakegawa,shinjo,shirataka,shonai,takahata,tendo,tozawa,tsuruoka,yamagata,yamanobe,yonezawa,yuza<yamaguchi>abu,hagi,hikari,hofu,iwakuni,kudamatsu,mitou,nagato,oshima,shimonoseki,shunan,tabuse,tokuyama,toyota,ube,yuu<yamanashi>chuo,doshi,fuefuki,fujikawa,fujikawaguchiko,fujiyoshida,hayakawa,hokuto,ichikawamisato,kai,kofu,koshu,kosuge,minami-alps,minobu,nakamichi,nanbu,narusawa,nirasaki,nishikatsura,oshino,otsuki,showa,tabayama,tsuru,uenohara,yamanakako,yamanashi<xn--4pvxs,xn--vgu402c,xn--c3s14m,xn--f6qx53a,xn--8pvr4u,xn--uist22h,xn--djrs72d6uy,xn--mkru45i,xn--0trq7p7nn,xn--8ltr62k,xn--2m4a15e,xn--efvn9s,xn--32vp30h,xn--4it797k,xn--1lqs71d,xn--5rtp49c,xn--5js045d,xn--ehqz56n,xn--1lqs03n,xn--qqqt11m,xn--kbrq7o,xn--pssu33l,xn--ntsq17g,xn--uisz3g,xn--6btw5a,xn--1ctwo,xn--6orx2r,xn--rht61e,xn--rht27z,xn--djty4k,xn--nit225k,xn--rht3d,xn--klty5x,xn--kltx9a,xn--kltp7d,xn--uuwu58a,xn--zbx025d,xn--ntso0iqx3a,xn--elqq16h,xn--4it168d,xn--klt787d,xn--rny31h,xn--7t0a264c,xn--5rtq34k,xn--k7yn95e,xn--tor131o,xn--d5qv7z876c,kawasaki>*,!city<kitakyushu>*,!city<kobe>*,!city<nagoya>*,!city<sapporo>*,!city<sendai>*,!city<yokohama>*,!city<<ke>ac,co,go,info,me,mobi,ne,or,sc<kg>org,net,com,edu,gov,mil<kh>*<ki>edu,biz,net,org,gov,info,com<km>org,nom,gov,prd,tm,edu,mil,ass,com,coop,asso,presse,medecin,notaires,pharmaciens,veterinaire,gouv<kn>net,org,edu,gov<kp>com,edu,gov,org,rep,tra<kr>ac,co,es,go,hs,kg,mil,ms,ne,or,pe,re,sc,busan,chungbuk,chungnam,daegu,daejeon,gangwon,gwangju,gyeongbuk,gyeonggi,gyeongnam,incheon,jeju,jeonbuk,jeonnam,seoul,ulsan<kw>com,edu,emb,gov,ind,net,org<ky>com,edu,net,org<kz>org,edu,net,gov,mil,com<la>int,net,info,edu,gov,per,com,org<lb>com,edu,gov,net,org<lc>com,net,co,org,edu,gov<li,lk>gov,sch,net,int,com,org,edu,ngo,soc,web,ltd,assn,grp,hotel,ac<lr>com,edu,gov,org,net<ls>ac,biz,co,edu,gov,info,net,org,sc<lt>gov<lu,lv>com,edu,gov,org,mil,id,net,asn,conf<ly>com,net,gov,plc,edu,sch,med,org,id<ma>co,net,gov,org,ac,press<mc>tm,asso<md,me>co,net,org,edu,ac,gov,its,priv<mg>org,nom,gov,prd,tm,edu,mil,com,co<mh,mil,mk>com,org,net,edu,gov,inf,name<ml>com,edu,gouv,gov,net,org,presse<mm>*<mn>gov,edu,org<mo>com,net,org,edu,gov<mobi,mp,mq,mr>gov<ms>com,edu,gov,net,org<mt>com,edu,net,org<mu>com,net,org,gov,ac,co,or<museum>academy,agriculture,air,airguard,alabama,alaska,amber,ambulance,american,americana,americanantiques,americanart,amsterdam,and,annefrank,anthro,anthropology,antiques,aquarium,arboretum,archaeological,archaeology,architecture,art,artanddesign,artcenter,artdeco,arteducation,artgallery,arts,artsandcrafts,asmatart,assassination,assisi,association,astronomy,atlanta,austin,australia,automotive,aviation,axis,badajoz,baghdad,bahn,bale,baltimore,barcelona,baseball,basel,baths,bauern,beauxarts,beeldengeluid,bellevue,bergbau,berkeley,berlin,bern,bible,bilbao,bill,birdart,birthplace,bonn,boston,botanical,botanicalgarden,botanicgarden,botany,brandywinevalley,brasil,bristol,british,britishcolumbia,broadcast,brunel,brussel,brussels,bruxelles,building,burghof,bus,bushey,cadaques,california,cambridge,can,canada,capebreton,carrier,cartoonart,casadelamoneda,castle,castres,celtic,center,chattanooga,cheltenham,chesapeakebay,chicago,children,childrens,childrensgarden,chiropractic,chocolate,christiansburg,cincinnati,cinema,circus,civilisation,civilization,civilwar,clinton,clock,coal,coastaldefence,cody,coldwar,collection,colonialwilliamsburg,coloradoplateau,columbia,columbus,communication,communications,community,computer,computerhistory,xn--comunicaes-v6a2o,contemporary,contemporaryart,convent,copenhagen,corporation,xn--correios-e-telecomunicaes-ghc29a,corvette,costume,countryestate,county,crafts,cranbrook,creation,cultural,culturalcenter,culture,cyber,cymru,dali,dallas,database,ddr,decorativearts,delaware,delmenhorst,denmark,depot,design,detroit,dinosaur,discovery,dolls,donostia,durham,eastafrica,eastcoast,education,educational,egyptian,eisenbahn,elburg,elvendrell,embroidery,encyclopedic,england,entomology,environment,environmentalconservation,epilepsy,essex,estate,ethnology,exeter,exhibition,family,farm,farmequipment,farmers,farmstead,field,figueres,filatelia,film,fineart,finearts,finland,flanders,florida,force,fortmissoula,fortworth,foundation,francaise,frankfurt,franziskaner,freemasonry,freiburg,fribourg,frog,fundacio,furniture,gallery,garden,gateway,geelvinck,gemological,geology,georgia,giessen,glas,glass,gorge,grandrapids,graz,guernsey,halloffame,hamburg,handson,harvestcelebration,hawaii,health,heimatunduhren,hellas,helsinki,hembygdsforbund,heritage,histoire,historical,historicalsociety,historichouses,historisch,historisches,history,historyofscience,horology,house,humanities,illustration,imageandsound,indian,indiana,indianapolis,indianmarket,intelligence,interactive,iraq,iron,isleofman,jamison,jefferson,jerusalem,jewelry,jewish,jewishart,jfk,journalism,judaica,judygarland,juedisches,juif,karate,karikatur,kids,koebenhavn,koeln,kunst,kunstsammlung,kunstunddesign,labor,labour,lajolla,lancashire,landes,lans,xn--lns-qla,larsson,lewismiller,lincoln,linz,living,livinghistory,localhistory,london,losangeles,louvre,loyalist,lucerne,luxembourg,luzern,mad,madrid,mallorca,manchester,mansion,mansions,manx,marburg,maritime,maritimo,maryland,marylhurst,media,medical,medizinhistorisches,meeres,memorial,mesaverde,michigan,midatlantic,military,mill,miners,mining,minnesota,missile,missoula,modern,moma,money,monmouth,monticello,montreal,moscow,motorcycle,muenchen,muenster,mulhouse,muncie,museet,museumcenter,museumvereniging,music,national,nationalfirearms,nationalheritage,nativeamerican,naturalhistory,naturalhistorymuseum,naturalsciences,nature,naturhistorisches,natuurwetenschappen,naumburg,naval,nebraska,neues,newhampshire,newjersey,newmexico,newport,newspaper,newyork,niepce,norfolk,north,nrw,nyc,nyny,oceanographic,oceanographique,omaha,online,ontario,openair,oregon,oregontrail,otago,oxford,pacific,paderborn,palace,paleo,palmsprings,panama,paris,pasadena,pharmacy,philadelphia,philadelphiaarea,philately,phoenix,photography,pilots,pittsburgh,planetarium,plantation,plants,plaza,portal,portland,portlligat,posts-and-telecommunications,preservation,presidio,press,project,public,pubol,quebec,railroad,railway,research,resistance,riodejaneiro,rochester,rockart,roma,russia,saintlouis,salem,salvadordali,salzburg,sandiego,sanfrancisco,santabarbara,santacruz,santafe,saskatchewan,satx,savannahga,schlesisches,schoenbrunn,schokoladen,school,schweiz,science,scienceandhistory,scienceandindustry,sciencecenter,sciencecenters,science-fiction,sciencehistory,sciences,sciencesnaturelles,scotland,seaport,settlement,settlers,shell,sherbrooke,sibenik,silk,ski,skole,society,sologne,soundandvision,southcarolina,southwest,space,spy,square,stadt,stalbans,starnberg,state,stateofdelaware,station,steam,steiermark,stjohn,stockholm,stpetersburg,stuttgart,suisse,surgeonshall,surrey,svizzera,sweden,sydney,tank,tcm,technology,telekommunikation,television,texas,textile,theater,time,timekeeping,topology,torino,touch,town,transport,tree,trolley,trust,trustee,uhren,ulm,undersea,university,usa,usantiques,usarts,uscountryestate,usculture,usdecorativearts,usgarden,ushistory,ushuaia,uslivinghistory,utah,uvic,valley,vantaa,versailles,viking,village,virginia,virtual,virtuel,vlaanderen,volkenkunde,wales,wallonie,war,washingtondc,watchandclock,watch-and-clock,western,westfalen,whaling,wildlife,williamsburg,windmill,workshop,york,yorkshire,yosemite,youth,zoological,zoology,xn--9dbhblg6di,xn--h1aegh<mv>aero,biz,com,coop,edu,gov,info,int,mil,museum,name,net,org,pro<mw>ac,biz,co,com,coop,edu,gov,int,museum,net,org<mx>com,org,gob,edu,net<my>biz,com,edu,gov,mil,name,net,org<mz>ac,adv,co,edu,gov,mil,net,org<na>info,pro,name,school,or,dr,us,mx,ca,in,cc,tv,ws,mobi,co,com,org<name,nc>asso,nom<ne,net,nf>com,net,per,rec,web,arts,firm,info,other,store<ng>com,edu,gov,i,mil,mobi,name,net,org,sch<ni>ac,biz,co,com,edu,gob,in,info,int,mil,net,nom,org,web<nl,no>fhs,vgs,fylkesbibl,folkebibl,museum,idrett,priv,mil,stat,dep,kommune,herad,aa>gs<ah>gs<bu>gs<fm>gs<hl>gs<hm>gs<jan-mayen>gs<mr>gs<nl>gs<nt>gs<of>gs<ol>gs<oslo>gs<rl>gs<sf>gs<st>gs<svalbard>gs<tm>gs<tr>gs<va>gs<vf>gs<akrehamn,xn--krehamn-dxa,algard,xn--lgrd-poac,arna,brumunddal,bryne,bronnoysund,xn--brnnysund-m8ac,drobak,xn--drbak-wua,egersund,fetsund,floro,xn--flor-jra,fredrikstad,hokksund,honefoss,xn--hnefoss-q1a,jessheim,jorpeland,xn--jrpeland-54a,kirkenes,kopervik,krokstadelva,langevag,xn--langevg-jxa,leirvik,mjondalen,xn--mjndalen-64a,mo-i-rana,mosjoen,xn--mosjen-eya,nesoddtangen,orkanger,osoyro,xn--osyro-wua,raholt,xn--rholt-mra,sandnessjoen,xn--sandnessjen-ogb,skedsmokorset,slattum,spjelkavik,stathelle,stavern,stjordalshalsen,xn--stjrdalshalsen-sqb,tananger,tranby,vossevangen,afjord,xn--fjord-lra,agdenes,al,xn--l-1fa,alesund,xn--lesund-hua,alstahaug,alta,xn--lt-liac,alaheadju,xn--laheadju-7ya,alvdal,amli,xn--mli-tla,amot,xn--mot-tla,andebu,andoy,xn--andy-ira,andasuolo,ardal,xn--rdal-poa,aremark,arendal,xn--s-1fa,aseral,xn--seral-lra,asker,askim,askvoll,askoy,xn--asky-ira,asnes,xn--snes-poa,audnedaln,aukra,aure,aurland,aurskog-holand,xn--aurskog-hland-jnb,austevoll,austrheim,averoy,xn--avery-yua,balestrand,ballangen,balat,xn--blt-elab,balsfjord,bahccavuotna,xn--bhccavuotna-k7a,bamble,bardu,beardu,beiarn,bajddar,xn--bjddar-pta,baidar,xn--bidr-5nac,berg,bergen,berlevag,xn--berlevg-jxa,bearalvahki,xn--bearalvhki-y4a,bindal,birkenes,bjarkoy,xn--bjarky-fya,bjerkreim,bjugn,bodo,xn--bod-2na,badaddja,xn--bdddj-mrabd,budejju,bokn,bremanger,bronnoy,xn--brnny-wuac,bygland,bykle,barum,xn--brum-voa,telemark>bo,xn--b-5ga<nordland>bo,xn--b-5ga,heroy,xn--hery-ira<bievat,xn--bievt-0qa,bomlo,xn--bmlo-gra,batsfjord,xn--btsfjord-9za,bahcavuotna,xn--bhcavuotna-s4a,dovre,drammen,drangedal,dyroy,xn--dyry-ira,donna,xn--dnna-gra,eid,eidfjord,eidsberg,eidskog,eidsvoll,eigersund,elverum,enebakk,engerdal,etne,etnedal,evenes,evenassi,xn--eveni-0qa01ga,evje-og-hornnes,farsund,fauske,fuossko,fuoisku,fedje,fet,finnoy,xn--finny-yua,fitjar,fjaler,fjell,flakstad,flatanger,flekkefjord,flesberg,flora,fla,xn--fl-zia,folldal,forsand,fosnes,frei,frogn,froland,frosta,frana,xn--frna-woa,froya,xn--frya-hra,fusa,fyresdal,forde,xn--frde-gra,gamvik,gangaviika,xn--ggaviika-8ya47h,gaular,gausdal,gildeskal,xn--gildeskl-g0a,giske,gjemnes,gjerdrum,gjerstad,gjesdal,gjovik,xn--gjvik-wua,gloppen,gol,gran,grane,granvin,gratangen,grimstad,grong,kraanghke,xn--kranghke-b0a,grue,gulen,hadsel,halden,halsa,hamar,hamaroy,habmer,xn--hbmer-xqa,hapmir,xn--hpmir-xqa,hammerfest,hammarfeasta,xn--hmmrfeasta-s4ac,haram,hareid,harstad,hasvik,aknoluokta,xn--koluokta-7ya57h,hattfjelldal,aarborte,haugesund,hemne,hemnes,hemsedal,more-og-romsdal>heroy,sande<xn--mre-og-romsdal-qqb>xn--hery-ira,sande<hitra,hjartdal,hjelmeland,hobol,xn--hobl-ira,hof,hol,hole,holmestrand,holtalen,xn--holtlen-hxa,hornindal,horten,hurdal,hurum,hvaler,hyllestad,hagebostad,xn--hgebostad-g3a,hoyanger,xn--hyanger-q1a,hoylandet,xn--hylandet-54a,ha,xn--h-2fa,ibestad,inderoy,xn--indery-fya,iveland,jevnaker,jondal,jolster,xn--jlster-bya,karasjok,karasjohka,xn--krjohka-hwab49j,karlsoy,galsa,xn--gls-elac,karmoy,xn--karmy-yua,kautokeino,guovdageaidnu,klepp,klabu,xn--klbu-woa,kongsberg,kongsvinger,kragero,xn--krager-gya,kristiansand,kristiansund,krodsherad,xn--krdsherad-m8a,kvalsund,rahkkeravju,xn--rhkkervju-01af,kvam,kvinesdal,kvinnherad,kviteseid,kvitsoy,xn--kvitsy-fya,kvafjord,xn--kvfjord-nxa,giehtavuoatna,kvanangen,xn--kvnangen-k0a,navuotna,xn--nvuotna-hwa,kafjord,xn--kfjord-iua,gaivuotna,xn--givuotna-8ya,larvik,lavangen,lavagis,loabat,xn--loabt-0qa,lebesby,davvesiida,leikanger,leirfjord,leka,leksvik,lenvik,leangaviika,xn--leagaviika-52b,lesja,levanger,lier,lierne,lillehammer,lillesand,lindesnes,lindas,xn--linds-pra,lom,loppa,lahppi,xn--lhppi-xqa,lund,lunner,luroy,xn--lury-ira,luster,lyngdal,lyngen,ivgu,lardal,lerdal,xn--lrdal-sra,lodingen,xn--ldingen-q1a,lorenskog,xn--lrenskog-54a,loten,xn--lten-gra,malvik,masoy,xn--msy-ula0h,muosat,xn--muost-0qa,mandal,marker,marnardal,masfjorden,meland,meldal,melhus,meloy,xn--mely-ira,meraker,xn--merker-kua,moareke,xn--moreke-jua,midsund,midtre-gauldal,modalen,modum,molde,moskenes,moss,mosvik,malselv,xn--mlselv-iua,malatvuopmi,xn--mlatvuopmi-s4a,namdalseid,aejrie,namsos,namsskogan,naamesjevuemie,xn--nmesjevuemie-tcba,laakesvuemie,nannestad,narvik,narviika,naustdal,nedre-eiker,akershus>nes<buskerud>nes<nesna,nesodden,nesseby,unjarga,xn--unjrga-rta,nesset,nissedal,nittedal,nord-aurdal,nord-fron,nord-odal,norddal,nordkapp,davvenjarga,xn--davvenjrga-y4a,nordre-land,nordreisa,raisa,xn--risa-5na,nore-og-uvdal,notodden,naroy,xn--nry-yla5g,notteroy,xn--nttery-byae,odda,oksnes,xn--ksnes-uua,oppdal,oppegard,xn--oppegrd-ixa,orkdal,orland,xn--rland-uua,orskog,xn--rskog-uua,orsta,xn--rsta-fra,hedmark>os,valer,xn--vler-qoa<hordaland>os<osen,osteroy,xn--ostery-fya,ostre-toten,xn--stre-toten-zcb,overhalla,ovre-eiker,xn--vre-eiker-k8a,oyer,xn--yer-zna,oygarden,xn--ygarden-p1a,oystre-slidre,xn--ystre-slidre-ujb,porsanger,porsangu,xn--porsgu-sta26f,porsgrunn,radoy,xn--rady-ira,rakkestad,rana,ruovat,randaberg,rauma,rendalen,rennebu,rennesoy,xn--rennesy-v1a,rindal,ringebu,ringerike,ringsaker,rissa,risor,xn--risr-ira,roan,rollag,rygge,ralingen,xn--rlingen-mxa,rodoy,xn--rdy-0nab,romskog,xn--rmskog-bya,roros,xn--rros-gra,rost,xn--rst-0na,royken,xn--ryken-vua,royrvik,xn--ryrvik-bya,rade,xn--rde-ula,salangen,siellak,saltdal,salat,xn--slt-elab,xn--slat-5na,samnanger,vestfold>sande<sandefjord,sandnes,sandoy,xn--sandy-yua,sarpsborg,sauda,sauherad,sel,selbu,selje,seljord,sigdal,siljan,sirdal,skaun,skedsmo,ski,skien,skiptvet,skjervoy,xn--skjervy-v1a,skierva,xn--skierv-uta,skjak,xn--skjk-soa,skodje,skanland,xn--sknland-fxa,skanit,xn--sknit-yqa,smola,xn--smla-hra,snillfjord,snasa,xn--snsa-roa,snoasa,snaase,xn--snase-nra,sogndal,sokndal,sola,solund,songdalen,sortland,spydeberg,stange,stavanger,steigen,steinkjer,stjordal,xn--stjrdal-s1a,stokke,stor-elvdal,stord,stordal,storfjord,omasvuotna,strand,stranda,stryn,sula,suldal,sund,sunndal,surnadal,sveio,svelvik,sykkylven,sogne,xn--sgne-gra,somna,xn--smna-gra,sondre-land,xn--sndre-land-0cb,sor-aurdal,xn--sr-aurdal-l8a,sor-fron,xn--sr-fron-q1a,sor-odal,xn--sr-odal-q1a,sor-varanger,xn--sr-varanger-ggb,matta-varjjat,xn--mtta-vrjjat-k7af,sorfold,xn--srfold-bya,sorreisa,xn--srreisa-q1a,sorum,xn--srum-gra,tana,deatnu,time,tingvoll,tinn,tjeldsund,dielddanuorri,tjome,xn--tjme-hra,tokke,tolga,torsken,tranoy,xn--trany-yua,tromso,xn--troms-zua,tromsa,romsa,trondheim,troandin,trysil,trana,xn--trna-woa,trogstad,xn--trgstad-r1a,tvedestrand,tydal,tynset,tysfjord,divtasvuodna,divttasvuotna,tysnes,tysvar,xn--tysvr-vra,tonsberg,xn--tnsberg-q1a,ullensaker,ullensvang,ulvik,utsira,vadso,xn--vads-jra,cahcesuolo,xn--hcesuolo-7ya35b,vaksdal,valle,vang,vanylven,vardo,xn--vard-jra,varggat,xn--vrggt-xqad,vefsn,vaapste,vega,vegarshei,xn--vegrshei-c0a,vennesla,verdal,verran,vestby,vestnes,vestre-slidre,vestre-toten,vestvagoy,xn--vestvgy-ixa6o,vevelstad,vik,vikna,vindafjord,volda,voss,varoy,xn--vry-yla5g,vagan,xn--vgan-qoa,voagat,vagsoy,xn--vgsy-qoa0j,vaga,xn--vg-yiab,ostfold>valer<xn--stfold-9xa>xn--vler-qoa<<np>*<nr>biz,info,gov,edu,org,net,com<nu,nz>ac,co,cri,geek,gen,govt,health,iwi,kiwi,maori,mil,xn--mori-qsa,net,org,parliament,school<om>co,com,edu,gov,med,museum,net,org,pro<onion,org,pa>ac,gob,com,org,sld,edu,net,ing,abo,med,nom<pe>edu,gob,nom,mil,org,com,net<pf>com,org,edu<pg>*<ph>com,net,org,gov,edu,ngo,mil,i<pk>com,net,edu,org,fam,biz,web,gov,gob,gok,gon,gop,gos,info<pl>com,net,org,aid,agro,atm,auto,biz,edu,gmina,gsm,info,mail,miasta,media,mil,nieruchomosci,nom,pc,powiat,priv,realestate,rel,sex,shop,sklep,sos,szkola,targi,tm,tourism,travel,turystyka,gov>ap,ic,is,us,kmpsp,kppsp,kwpsp,psp,wskr,kwp,mw,ug,um,umig,ugim,upow,uw,starostwo,pa,po,psse,pup,rzgw,sa,so,sr,wsa,sko,uzs,wiih,winb,pinb,wios,witd,wzmiuw,piw,wiw,griw,wif,oum,sdn,zp,uppo,mup,wuoz,konsulat,oirm<augustow,babia-gora,bedzin,beskidy,bialowieza,bialystok,bielawa,bieszczady,boleslawiec,bydgoszcz,bytom,cieszyn,czeladz,czest,dlugoleka,elblag,elk,glogow,gniezno,gorlice,grajewo,ilawa,jaworzno,jelenia-gora,jgora,kalisz,kazimierz-dolny,karpacz,kartuzy,kaszuby,katowice,kepno,ketrzyn,klodzko,kobierzyce,kolobrzeg,konin,konskowola,kutno,lapy,lebork,legnica,lezajsk,limanowa,lomza,lowicz,lubin,lukow,malbork,malopolska,mazowsze,mazury,mielec,mielno,mragowo,naklo,nowaruda,nysa,olawa,olecko,olkusz,olsztyn,opoczno,opole,ostroda,ostroleka,ostrowiec,ostrowwlkp,pila,pisz,podhale,podlasie,polkowice,pomorze,pomorskie,prochowice,pruszkow,przeworsk,pulawy,radom,rawa-maz,rybnik,rzeszow,sanok,sejny,slask,slupsk,sosnowiec,stalowa-wola,skoczow,starachowice,stargard,suwalki,swidnica,swiebodzin,swinoujscie,szczecin,szczytno,tarnobrzeg,tgory,turek,tychy,ustka,walbrzych,warmia,warszawa,waw,wegrow,wielun,wlocl,wloclawek,wodzislaw,wolomin,wroclaw,zachpomor,zagan,zarow,zgora,zgorzelec<pm,pn>gov,co,org,edu,net<post,pr>com,net,org,gov,edu,isla,pro,biz,info,name,est,prof,ac<pro>aaa,aca,acct,avocat,bar,cpa,eng,jur,law,med,recht<ps>edu,gov,sec,plo,com,org,net<pt>net,gov,org,edu,int,publ,com,nome<pw>co,ne,or,ed,go,belau<py>com,coop,edu,gov,mil,net,org<qa>com,edu,gov,mil,name,net,org,sch<re>asso,com,nom<ro>arts,com,firm,info,nom,nt,org,rec,store,tm,www<rs>ac,co,edu,gov,in,org<ru,rw>ac,co,coop,gov,mil,net,org<sa>com,net,org,gov,med,pub,edu,sch<sb>com,edu,gov,net,org<sc>com,gov,net,org,edu<sd>com,net,org,edu,med,tv,gov,info<se>a,ac,b,bd,brand,c,d,e,f,fh,fhsk,fhv,g,h,i,k,komforb,kommunalforbund,komvux,l,lanbib,m,n,naturbruksgymn,o,org,p,parti,pp,press,r,s,t,tm,u,w,x,y,z<sg>com,net,org,gov,edu,per<sh>com,net,gov,org,mil<si,sj,sk,sl>com,net,edu,gov,org<sm,sn>art,com,edu,gouv,org,perso,univ<so>com,edu,gov,me,net,org<sr,ss>biz,com,edu,gov,me,net,org,sch<st>co,com,consulado,edu,embaixada,mil,net,org,principe,saotome,store<su,sv>com,edu,gob,org,red<sx>gov<sy>edu,gov,net,mil,com,org<sz>co,ac,org<tc,td,tel,tf,tg,th>ac,co,go,in,mi,net,or<tj>ac,biz,co,com,edu,go,gov,int,mil,name,net,nic,org,test,web<tk,tl>gov<tm>com,co,org,net,nom,gov,mil,edu<tn>com,ens,fin,gov,ind,info,intl,mincom,nat,net,org,perso,tourism<to>com,gov,net,org,edu,mil<tr>av,bbs,bel,biz,com,dr,edu,gen,gov,info,mil,k12,kep,name,net,org,pol,tel,tsk,tv,web,nc>gov<<tt>co,com,org,net,biz,info,pro,int,coop,jobs,mobi,travel,museum,aero,name,gov,edu<tv,tw>edu,gov,mil,com,net,org,idv,game,ebiz,club,xn--zf0ao64a,xn--uc0atv,xn--czrw28b<tz>ac,co,go,hotel,info,me,mil,mobi,ne,or,sc,tv<ua>com,edu,gov,in,net,org,cherkassy,cherkasy,chernigov,chernihiv,chernivtsi,chernovtsy,ck,cn,cr,crimea,cv,dn,dnepropetrovsk,dnipropetrovsk,donetsk,dp,if,ivano-frankivsk,kh,kharkiv,kharkov,kherson,khmelnitskiy,khmelnytskyi,kiev,kirovograd,km,kr,krym,ks,kv,kyiv,lg,lt,lugansk,lutsk,lv,lviv,mk,mykolaiv,nikolaev,od,odesa,odessa,pl,poltava,rivne,rovno,rv,sb,sebastopol,sevastopol,sm,sumy,te,ternopil,uz,uzhgorod,vinnica,vinnytsia,vn,volyn,yalta,zaporizhzhe,zaporizhzhia,zhitomir,zhytomyr,zp,zt<ug>co,or,ac,sc,go,ne,com,org<uk>ac,co,gov,ltd,me,net,nhs,org,plc,police,sch>*<<us>dni,fed,isa,kids,nsn,ak>k12,cc,lib<al>k12,cc,lib<ar>k12,cc,lib<as>k12,cc,lib<az>k12,cc,lib<ca>k12,cc,lib<co>k12,cc,lib<ct>k12,cc,lib<dc>k12,cc,lib<de>k12,cc<fl>k12,cc,lib<ga>k12,cc,lib<gu>k12,cc,lib<hi>cc,lib<ia>k12,cc,lib<id>k12,cc,lib<il>k12,cc,lib<in>k12,cc,lib<ks>k12,cc,lib<ky>k12,cc,lib<la>k12,cc,lib<ma>k12>pvt,chtr,paroch<cc,lib<md>k12,cc,lib<me>k12,cc,lib<mi>k12,cc,lib,ann-arbor,cog,dst,eaton,gen,mus,tec,washtenaw<mn>k12,cc,lib<mo>k12,cc,lib<ms>k12,cc,lib<mt>k12,cc,lib<nc>k12,cc,lib<nd>cc,lib<ne>k12,cc,lib<nh>k12,cc,lib<nj>k12,cc,lib<nm>k12,cc,lib<nv>k12,cc,lib<ny>k12,cc,lib<oh>k12,cc,lib<ok>k12,cc,lib<or>k12,cc,lib<pa>k12,cc,lib<pr>k12,cc,lib<ri>cc,lib<sc>k12,cc,lib<sd>cc,lib<tn>k12,cc,lib<tx>k12,cc,lib<ut>k12,cc,lib<vi>k12,cc,lib<vt>k12,cc,lib<va>k12,cc,lib<wa>k12,cc,lib<wi>k12,cc,lib<wv>cc<wy>k12,cc,lib<<uy>com,edu,gub,mil,net,org<uz>co,com,net,org<va,vc>com,net,org,gov,mil,edu<ve>arts,bib,co,com,e12,edu,firm,gob,gov,info,int,mil,net,nom,org,rar,rec,store,tec,web<vg,vi>co,com,k12,net,org<vn>com,net,org,edu,gov,int,ac,biz,info,name,pro,health<vu>com,edu,net,org<wf,ws>com,net,org,gov,edu<yt,xn--mgbaam7a8h,xn--y9a3aq,xn--54b7fta0cc,xn--90ae,xn--mgbcpq6gpa1a,xn--90ais,xn--fiqs8s,xn--fiqz9s,xn--lgbbat1ad8j,xn--wgbh1c,xn--e1a4c,xn--qxa6a,xn--mgbah1a3hjkrd,xn--node,xn--qxam,xn--j6w193g>xn--55qx5d,xn--wcvs22d,xn--mxtq1m,xn--gmqw5a,xn--od0alg,xn--uc0atv<xn--2scrj9c,xn--3hcrj9c,xn--45br5cyl,xn--h2breg3eve,xn--h2brj9c8c,xn--mgbgu82a,xn--rvc1e0am3e,xn--h2brj9c,xn--mgbbh1a,xn--mgbbh1a71e,xn--fpcrj9c3d,xn--gecrj9c,xn--s9brj9c,xn--45brj9c,xn--xkc2dl3a5ee0h,xn--mgba3a4f16a,xn--mgba3a4fra,xn--mgbtx2b,xn--mgbayh7gpa,xn--3e0b707e,xn--80ao21a,xn--q7ce6a,xn--fzc2c9e2c,xn--xkc2al3hye2a,xn--mgbc0a9azcg,xn--d1alf,xn--l1acc,xn--mix891f,xn--mix082f,xn--mgbx4cd0ab,xn--mgb9awbf,xn--mgbai9azgqp6j,xn--mgbai9a5eva00b,xn--ygbi2ammx,xn--90a3ac>xn--o1ac,xn--c1avg,xn--90azh,xn--d1at,xn--o1ach,xn--80au<xn--p1ai,xn--wgbl6a,xn--mgberp4a5d4ar,xn--mgberp4a5d4a87g,xn--mgbqly7c0a67fbc,xn--mgbqly7cvafr,xn--mgbpl2fh,xn--yfro4i67o,xn--clchc0ea0b2g2a9gcd,xn--ogbpf8fl,xn--mgbtf8fl,xn--o3cw4h>xn--12c1fe0br,xn--12co0c3b4eva,xn--h3cuzk1di,xn--o3cyx2a,xn--m3ch0j3a,xn--12cfi8ixb8l<xn--pgbs0dh,xn--kpry57d,xn--kprw13d,xn--nnx388a,xn--j1amh,xn--mgb2ddes,xxx,ye>com,edu,gov,net,mil,org<za>ac,agric,alt,co,edu,gov,grondar,law,mil,net,ngo,nic,nis,nom,org,school,tm,web<zm>ac,biz,co,com,edu,gov,info,mil,net,org,sch<zw>ac,co,gov,mil,org<aaa,aarp,abarth,abb,abbott,abbvie,abc,able,abogado,abudhabi,academy,accenture,accountant,accountants,aco,actor,adac,ads,adult,aeg,aetna,afl,africa,agakhan,agency,aig,airbus,airforce,airtel,akdn,alfaromeo,alibaba,alipay,allfinanz,allstate,ally,alsace,alstom,amazon,americanexpress,americanfamily,amex,amfam,amica,amsterdam,analytics,android,anquan,anz,aol,apartments,app,apple,aquarelle,arab,aramco,archi,army,art,arte,asda,associates,athleta,attorney,auction,audi,audible,audio,auspost,author,auto,autos,avianca,aws,axa,azure,baby,baidu,banamex,bananarepublic,band,bank,bar,barcelona,barclaycard,barclays,barefoot,bargains,baseball,basketball,bauhaus,bayern,bbc,bbt,bbva,bcg,bcn,beats,beauty,beer,bentley,berlin,best,bestbuy,bet,bharti,bible,bid,bike,bing,bingo,bio,black,blackfriday,blockbuster,blog,bloomberg,blue,bms,bmw,bnpparibas,boats,boehringer,bofa,bom,bond,boo,book,booking,bosch,bostik,boston,bot,boutique,box,bradesco,bridgestone,broadway,broker,brother,brussels,bugatti,build,builders,business,buy,buzz,bzh,cab,cafe,cal,call,calvinklein,cam,camera,camp,cancerresearch,canon,capetown,capital,capitalone,car,caravan,cards,care,career,careers,cars,casa,case,cash,casino,catering,catholic,cba,cbn,cbre,cbs,center,ceo,cern,cfa,cfd,chanel,channel,charity,chase,chat,cheap,chintai,christmas,chrome,church,cipriani,circle,cisco,citadel,citi,citic,city,cityeats,claims,cleaning,click,clinic,clinique,clothing,cloud,club,clubmed,coach,codes,coffee,college,cologne,comcast,commbank,community,company,compare,computer,comsec,condos,construction,consulting,contact,contractors,cooking,cookingchannel,cool,corsica,country,coupon,coupons,courses,cpa,credit,creditcard,creditunion,cricket,crown,crs,cruise,cruises,cuisinella,cymru,cyou,dabur,dad,dance,data,date,dating,datsun,day,dclk,dds,deal,dealer,deals,degree,delivery,dell,deloitte,delta,democrat,dental,dentist,desi,design,dev,dhl,diamonds,diet,digital,direct,directory,discount,discover,dish,diy,dnp,docs,doctor,dog,domains,dot,download,drive,dtv,dubai,dunlop,dupont,durban,dvag,dvr,earth,eat,eco,edeka,education,email,emerck,energy,engineer,engineering,enterprises,epson,equipment,ericsson,erni,esq,estate,etisalat,eurovision,eus,events,exchange,expert,exposed,express,extraspace,fage,fail,fairwinds,faith,family,fan,fans,farm,farmers,fashion,fast,fedex,feedback,ferrari,ferrero,fiat,fidelity,fido,film,final,finance,financial,fire,firestone,firmdale,fish,fishing,fit,fitness,flickr,flights,flir,florist,flowers,fly,foo,food,foodnetwork,football,ford,forex,forsale,forum,foundation,fox,free,fresenius,frl,frogans,frontdoor,frontier,ftr,fujitsu,fun,fund,furniture,futbol,fyi,gal,gallery,gallo,gallup,game,games,gap,garden,gay,gbiz,gdn,gea,gent,genting,george,ggee,gift,gifts,gives,giving,glass,gle,global,globo,gmail,gmbh,gmo,gmx,godaddy,gold,goldpoint,golf,goo,goodyear,goog,google,gop,got,grainger,graphics,gratis,green,gripe,grocery,group,guardian,gucci,guge,guide,guitars,guru,hair,hamburg,hangout,haus,hbo,hdfc,hdfcbank,health,healthcare,help,helsinki,here,hermes,hgtv,hiphop,hisamitsu,hitachi,hiv,hkt,hockey,holdings,holiday,homedepot,homegoods,homes,homesense,honda,horse,hospital,host,hosting,hot,hoteles,hotels,hotmail,house,how,hsbc,hughes,hyatt,hyundai,ibm,icbc,ice,icu,ieee,ifm,ikano,imamat,imdb,immo,immobilien,inc,industries,infiniti,ing,ink,institute,insurance,insure,international,intuit,investments,ipiranga,irish,ismaili,ist,istanbul,itau,itv,jaguar,java,jcb,jeep,jetzt,jewelry,jio,jll,jmp,jnj,joburg,jot,joy,jpmorgan,jprs,juegos,juniper,kaufen,kddi,kerryhotels,kerrylogistics,kerryproperties,kfh,kia,kids,kim,kinder,kindle,kitchen,kiwi,koeln,komatsu,kosher,kpmg,kpn,krd,kred,kuokgroup,kyoto,lacaixa,lamborghini,lamer,lancaster,lancia,land,landrover,lanxess,lasalle,lat,latino,latrobe,law,lawyer,lds,lease,leclerc,lefrak,legal,lego,lexus,lgbt,lidl,life,lifeinsurance,lifestyle,lighting,like,lilly,limited,limo,lincoln,linde,link,lipsy,live,living,llc,llp,loan,loans,locker,locus,loft,lol,london,lotte,lotto,love,lpl,lplfinancial,ltd,ltda,lundbeck,luxe,luxury,macys,madrid,maif,maison,makeup,man,management,mango,map,market,marketing,markets,marriott,marshalls,maserati,mattel,mba,mckinsey,med,media,meet,melbourne,meme,memorial,men,menu,merckmsd,miami,microsoft,mini,mint,mit,mitsubishi,mlb,mls,mma,mobile,moda,moe,moi,mom,monash,money,monster,mormon,mortgage,moscow,moto,motorcycles,mov,movie,msd,mtn,mtr,music,mutual,nab,nagoya,natura,navy,nba,nec,netbank,netflix,network,neustar,new,news,next,nextdirect,nexus,nfl,ngo,nhk,nico,nike,nikon,ninja,nissan,nissay,nokia,northwesternmutual,norton,now,nowruz,nowtv,nra,nrw,ntt,nyc,obi,observer,office,okinawa,olayan,olayangroup,oldnavy,ollo,omega,one,ong,onl,online,ooo,open,oracle,orange,organic,origins,osaka,otsuka,ott,ovh,page,panasonic,paris,pars,partners,parts,party,passagens,pay,pccw,pet,pfizer,pharmacy,phd,philips,phone,photo,photography,photos,physio,pics,pictet,pictures,pid,pin,ping,pink,pioneer,pizza,place,play,playstation,plumbing,plus,pnc,pohl,poker,politie,porn,pramerica,praxi,press,prime,prod,productions,prof,progressive,promo,properties,property,protection,pru,prudential,pub,pwc,qpon,quebec,quest,racing,radio,read,realestate,realtor,realty,recipes,red,redstone,redumbrella,rehab,reise,reisen,reit,reliance,ren,rent,rentals,repair,report,republican,rest,restaurant,review,reviews,rexroth,rich,richardli,ricoh,ril,rio,rip,rocher,rocks,rodeo,rogers,room,rsvp,rugby,ruhr,run,rwe,ryukyu,saarland,safe,safety,sakura,sale,salon,samsclub,samsung,sandvik,sandvikcoromant,sanofi,sap,sarl,sas,save,saxo,sbi,sbs,sca,scb,schaeffler,schmidt,scholarships,school,schule,schwarz,science,scot,search,seat,secure,security,seek,select,sener,services,ses,seven,sew,sex,sexy,sfr,shangrila,sharp,shaw,shell,shia,shiksha,shoes,shop,shopping,shouji,show,showtime,silk,sina,singles,site,ski,skin,sky,skype,sling,smart,smile,sncf,soccer,social,softbank,software,sohu,solar,solutions,song,sony,soy,spa,space,sport,spot,srl,stada,staples,star,statebank,statefarm,stc,stcgroup,stockholm,storage,store,stream,studio,study,style,sucks,supplies,supply,support,surf,surgery,suzuki,swatch,swiss,sydney,systems,tab,taipei,talk,taobao,target,tatamotors,tatar,tattoo,tax,taxi,tci,tdk,team,tech,technology,temasek,tennis,teva,thd,theater,theatre,tiaa,tickets,tienda,tiffany,tips,tires,tirol,tjmaxx,tjx,tkmaxx,tmall,today,tokyo,tools,top,toray,toshiba,total,tours,town,toyota,toys,trade,trading,training,travel,travelchannel,travelers,travelersinsurance,trust,trv,tube,tui,tunes,tushu,tvs,ubank,ubs,unicom,university,uno,uol,ups,vacations,vana,vanguard,vegas,ventures,verisign,versicherung,vet,viajes,video,vig,viking,villas,vin,vip,virgin,visa,vision,viva,vivo,vlaanderen,vodka,volkswagen,volvo,vote,voting,voto,voyage,vuelos,wales,walmart,walter,wang,wanggou,watch,watches,weather,weatherchannel,webcam,weber,website,wedding,weibo,weir,whoswho,wien,wiki,williamhill,win,windows,wine,winners,wme,wolterskluwer,woodside,work,works,world,wow,wtc,wtf,xbox,xerox,xfinity,xihuan,xin,xn--11b4c3d,xn--1ck2e1b,xn--1qqw23a,xn--30rr7y,xn--3bst00m,xn--3ds443g,xn--3pxu8k,xn--42c2d9a,xn--45q11c,xn--4gbrim,xn--55qw42g,xn--55qx5d,xn--5su34j936bgsg,xn--5tzm5g,xn--6frz82g,xn--6qq986b3xl,xn--80adxhks,xn--80aqecdr1a,xn--80asehdb,xn--80aswg,xn--8y0a063a,xn--9dbq2a,xn--9et52u,xn--9krt00a,xn--b4w605ferd,xn--bck1b9a5dre4c,xn--c1avg,xn--c2br7g,xn--cck2b3b,xn--cckwcxetd,xn--cg4bki,xn--czr694b,xn--czrs0t,xn--czru2d,xn--d1acj3b,xn--eckvdtc9d,xn--efvy88h,xn--fct429k,xn--fhbei,xn--fiq228c5hs,xn--fiq64b,xn--fjq720a,xn--flw351e,xn--fzys8d69uvgm,xn--g2xx48c,xn--gckr3f0f,xn--gk3at1e,xn--hxt814e,xn--i1b6b1a6a2e,xn--imr513n,xn--io0a7i,xn--j1aef,xn--jlq480n2rg,xn--jlq61u9w7b,xn--jvr189m,xn--kcrx77d1x4a,xn--kput3i,xn--mgba3a3ejt,xn--mgba7c0bbn0a,xn--mgbaakc7dvf,xn--mgbab2bd,xn--mgbca7dzdo,xn--mgbi4ecexp,xn--mgbt3dhd,xn--mk1bu44c,xn--mxtq1m,xn--ngbc5azd,xn--ngbe9e0a,xn--ngbrx,xn--nqv7f,xn--nqv7fs00ema,xn--nyqy26a,xn--otu796d,xn--p1acf,xn--pssy2u,xn--q9jyb4c,xn--qcka1pmc,xn--rhqv96g,xn--rovu88b,xn--ses554g,xn--t60b56a,xn--tckwe,xn--tiq49xqyj,xn--unup4y,xn--vermgensberater-ctb,xn--vermgensberatung-pwb,xn--vhquv,xn--vuq861b,xn--w4r85el8fhu5dnra,xn--w4rs40l,xn--xhq521b,xn--zfr164b,xyz,yachts,yahoo,yamaxun,yandex,yodobashi,yoga,yokohama,you,youtube,yun,zappos,zara,zero,zip,zone,zuerich";

// node_modules/parse-domain/serialized-tries/private.js
var private_default = "ua>cc,inf,ltd,cx,biz,co,pp,v<to>611,oya,rdv,vpnplus,quickconnect>direct<nyan<us>graphox,cloudns,drud,is-by,land-4-sale,stuff-4-sale,enscaled>phx<mircloud,freeddns,golffan,noip,pointto,platterp,de>lib<<com>devcdnaccesso>*<adobeaemcloud>dev>*<<airkitapps,airkitapps-au,aivencloud,kasserver,amazonaws>compute>*<compute-1>*<us-east-1>dualstack>s3<<elb>*<s3,s3-ap-northeast-1,s3-ap-northeast-2,s3-ap-south-1,s3-ap-southeast-1,s3-ap-southeast-2,s3-ca-central-1,s3-eu-central-1,s3-eu-west-1,s3-eu-west-2,s3-eu-west-3,s3-external-1,s3-fips-us-gov-west-1,s3-sa-east-1,s3-us-gov-west-1,s3-us-east-2,s3-us-west-1,s3-us-west-2,ap-northeast-2>s3,dualstack>s3<s3-website<ap-south-1>s3,dualstack>s3<s3-website<ca-central-1>s3,dualstack>s3<s3-website<eu-central-1>s3,dualstack>s3<s3-website<eu-west-2>s3,dualstack>s3<s3-website<eu-west-3>s3,dualstack>s3<s3-website<us-east-2>s3,dualstack>s3<s3-website<ap-northeast-1>dualstack>s3<<ap-southeast-1>dualstack>s3<<ap-southeast-2>dualstack>s3<<eu-west-1>dualstack>s3<<sa-east-1>dualstack>s3<<s3-website-us-east-1,s3-website-us-west-1,s3-website-us-west-2,s3-website-ap-northeast-1,s3-website-ap-southeast-1,s3-website-ap-southeast-2,s3-website-eu-west-1,s3-website-sa-east-1<elasticbeanstalk>ap-northeast-1,ap-northeast-2,ap-northeast-3,ap-south-1,ap-southeast-1,ap-southeast-2,ca-central-1,eu-central-1,eu-west-1,eu-west-2,eu-west-3,sa-east-1,us-east-1,us-east-2,us-gov-west-1,us-west-1,us-west-2<awsglobalaccelerator,siiites,appspacehosted,appspaceusercontent,on-aptible,myasustor,balena-devices,betainabox,boutir,bplaced,cafjs,br,cn,de,eu,jpn,mex,ru,sa,uk,us,za,ar,hu,kr,no,qc,uy,africa,gr,co,jdevcloud,wpdevcloud,cloudcontrolled,cloudcontrolapp,trycloudflare,customer-oci>*,oci>*<ocp>*<ocs>*<<dattolocal,dattorelay,dattoweb,mydatto,builtwithdark,datadetect>demo,instance<ddns5,discordsays,discordsez,drayddns,dreamhosters,mydrobo,dyndns-at-home,dyndns-at-work,dyndns-blog,dyndns-free,dyndns-home,dyndns-ip,dyndns-mail,dyndns-office,dyndns-pics,dyndns-remote,dyndns-server,dyndns-web,dyndns-wiki,dyndns-work,blogdns,cechire,dnsalias,dnsdojo,doesntexist,dontexist,doomdns,dyn-o-saur,dynalias,est-a-la-maison,est-a-la-masion,est-le-patron,est-mon-blogueur,from-ak,from-al,from-ar,from-ca,from-ct,from-dc,from-de,from-fl,from-ga,from-hi,from-ia,from-id,from-il,from-in,from-ks,from-ky,from-ma,from-md,from-mi,from-mn,from-mo,from-ms,from-mt,from-nc,from-nd,from-ne,from-nh,from-nj,from-nm,from-nv,from-oh,from-ok,from-or,from-pa,from-pr,from-ri,from-sc,from-sd,from-tn,from-tx,from-ut,from-va,from-vt,from-wa,from-wi,from-wv,from-wy,getmyip,gotdns,hobby-site,homelinux,homeunix,iamallama,is-a-anarchist,is-a-blogger,is-a-bookkeeper,is-a-bulls-fan,is-a-caterer,is-a-chef,is-a-conservative,is-a-cpa,is-a-cubicle-slave,is-a-democrat,is-a-designer,is-a-doctor,is-a-financialadvisor,is-a-geek,is-a-green,is-a-guru,is-a-hard-worker,is-a-hunter,is-a-landscaper,is-a-lawyer,is-a-liberal,is-a-libertarian,is-a-llama,is-a-musician,is-a-nascarfan,is-a-nurse,is-a-painter,is-a-personaltrainer,is-a-photographer,is-a-player,is-a-republican,is-a-rockstar,is-a-socialist,is-a-student,is-a-teacher,is-a-techie,is-a-therapist,is-an-accountant,is-an-actor,is-an-actress,is-an-anarchist,is-an-artist,is-an-engineer,is-an-entertainer,is-certified,is-gone,is-into-anime,is-into-cars,is-into-cartoons,is-into-games,is-leet,is-not-certified,is-slick,is-uberleet,is-with-theband,isa-geek,isa-hockeynut,issmarterthanyou,likes-pie,likescandy,neat-url,saves-the-whales,selfip,sells-for-less,sells-for-u,servebbs,simple-url,space-to-rent,teaches-yoga,writesthisblog,digitaloceanspaces>*<ddnsfree,ddnsgeek,giize,gleeze,kozow,loseyourip,ooguy,theworkpc,mytuleap,tuleap-partners,encoreapi,evennode>eu-1,eu-2,eu-3,eu-4,us-1,us-2,us-3,us-4<onfabrica,fbsbx>apps<fastly-terrarium,fastvps-server,mydobiss,firebaseapp,fldrv,forgeblocks,framercanvas,freebox-os,freeboxos,freemyip,gentapps,gentlentapis,githubusercontent,0emm>*<appspot>r>*<<codespot,googleapis,googlecode,pagespeedmobilizer,publishproxy,withgoogle,withyoutube,blogspot,awsmppl,herokuapp,herokussl,myravendb,impertrixcdn,impertrix,smushcdn,wphostedmail,wpmucdn,pixolino,amscompute,clicketcloud,dopaas,hidora,hosted-by-previder>paas<hosteur>rag-cloud,rag-cloud-ch<ik-server>jcloud,jcloud-ver-jpc<jelastic>demo<kilatiron,massivegrid>paas<wafaicloud>jed,lon,ryd<joyent>cns>*<<ktistory,lpusercontent,lmpm>app<linode>members,nodebalancer>*<<linodeobjects>*<linodeusercontent>ip<barsycenter,barsyonline,mazeplay,miniserver,meteorapp>eu<hostedpi,mythic-beasts>customer,caracal,fentiger,lynx,ocelot,oncilla,onza,sphinx,vs,x,yali<nospamproxy>cloud<4u,nfshost,001www,ddnslive,myiphost,blogsyte,ciscofreak,damnserver,ditchyourip,dnsiskinky,dynns,geekgalaxy,health-carereform,homesecuritymac,homesecuritypc,myactivedirectory,mysecuritycamera,net-freaks,onthewifi,point2this,quicksytes,securitytactics,serveexchange,servehumour,servep2p,servesarcasm,stufftoread,unusualperson,workisboring,3utilities,ddnsking,myvnc,servebeer,servecounterstrike,serveftp,servegame,servehalflife,servehttp,serveirc,servemp3,servepics,servequake,observableusercontent>static<orsites,operaunite,authgear-staging,authgearapps,skygearapp,outsystemscloud,ownprovider,pgfog,pagefrontapp,pagexl,paywhirl>*<gotpantheon,platter-app,pleskns,postman-echo,prgmr>xen<pythonanywhere>eu<qualifioapp,qbuser,qa2,dev-myqnapcloud,alpha-myqnapcloud,myqnapcloud,quipelements>*<rackmaze,rhcloud,render>app<onrender,code>builder>*<dev-builder>*<stg-builder>*<<logoip,scrysec,firewall-gateway,myshopblocks,myshopify,shopitsite,1kapp,appchizi,applinzi,sinaapp,vipsinaapp,bounty-full>alpha,beta<try-snowplow,stackhero-network,playstation-cloud,myspreadshop,stdlib>api<temp-dns,dsmynas,familyds,tb-hosting>site<reservd,thingdustdata,bloxcms,townnews-staging,typeform>pro<hk,vultrobjects>*<wafflecell,reserve-online,hotelwithflight,remotewd,wiardweb>pages<messwithdns,woltlab-demo,wpenginepowered>js<wixsite,xnbay>u2,u2-local<yolasite<live>hlx<net>adobeaemcloud,alwaysdata,cloudfront,t3l3p0rt,appudo,atlassian-dev>prod>cdn<<myfritz,onavstack,shopselect,blackbaudcdn,boomla,bplaced,square7,gb,hu,jp,se,uk,in,clickrising,cloudaccess,cdn77-ssl,cdn77>r<feste-ip,knx-server,static-access,cryptonomic>*<dattolocal,mydatto,debian,bitbridge,at-band-camp,blogdns,broke-it,buyshouses,dnsalias,dnsdojo,does-it,dontexist,dynalias,dynathome,endofinternet,from-az,from-co,from-la,from-ny,gets-it,ham-radio-op,homeftp,homeip,homelinux,homeunix,in-the-band,is-a-chef,is-a-geek,isa-geek,kicks-ass,office-on-the,podzone,scrapper-site,selfip,sells-it,servebbs,serveftp,thruhere,webhop,definima,casacam,dynu,dynv6,twmail,ru,channelsdvr>u<fastlylb>map<fastly>freetls,map,prod>a,global<ssl>a,b,global<<edgeapp,flynnhosting,cdn-edges,heteml,cloudfunctions,moonscale,in-dsl,in-vpn,ipifony,iobb,cloudjiffy>fra1-de,west1-us<elastx>jls-sto1,jls-sto2,jls-sto3<faststacks,massivegrid>paas>fr-1,lon-1,lon-2,ny-1,ny-2,sg-1<<saveincloud>jelastic,nordeste-idc<scaleforce>j<tsukaeru>jelastic<kinghost,uni5,krellian,barsy,memset,azurewebsites,azure-mobile,cloudapp,azurestaticapps>1,centralus,eastasia,eastus2,westeurope,westus2<dnsup,hicam,now-dns,ownip,vpndns,eating-organic,mydissent,myeffect,mymediapc,mypsx,mysecuritycamera,nhlfan,no-ip,pgafan,privatizehealthinsurance,bounceme,ddns,redirectme,serveblog,serveminecraft,sytes,cloudycluster,ovh>webpaas>*<hosting>*<<bar0,bar1,bar2,rackmaze,schokokeks,firewall-gateway,seidat,senseering,siteleaf,vps-host>jelastic>atl,njs,ric<<myspreadshop,srcf>soc,user<supabase,dsmynas,familyds,tailscale>beta<ts,torproject>pages<reserve-online,community-pro,meinforum,yandexcloud>storage,website<za<page>hlx,hlx3,translated,codeberg,pdns,plesk,prvcy,rocky,magnet<pl>beep,ecommerce-shop,shoparena,homesklep,sdscloud,unicloud,krasnik,leczna,lubartow,lublin,poniatowa,swidnik,co,art,gliwice,krakow,poznan,wroc,zakopane,myspreadshop,gda,gdansk,gdynia,med,sopot<eu>airkitapps,mycd,cloudns,dogado>jelastic<barsy,wellbeingzone,spdns,transurl>*<diskstation<ca>barsy,awdev>*<co,blogspot,no-ip,myspreadshop<estate>compute>*<<network>alces>*<co,arvo,azimuth,tlon<org>altervista,amune>tele<pimienta,poivron,potager,sweetpepper,ae,us,certmgr,cdn77>c,rsc<cdn77-secure>origin>ssl<<cloudns,duckdns,tunk,dyndns>go,home<blogdns,blogsite,boldlygoingnowhere,dnsalias,dnsdojo,doesntexist,dontexist,doomdns,dvrdns,dynalias,endofinternet,endoftheinternet,from-me,game-host,gotdns,hobby-site,homedns,homeftp,homelinux,homeunix,is-a-bruinsfan,is-a-candidate,is-a-celticsfan,is-a-chef,is-a-geek,is-a-knight,is-a-linux-user,is-a-patsfan,is-a-soxfan,is-found,is-lost,is-saved,is-very-bad,is-very-evil,is-very-good,is-very-nice,is-very-sweet,isa-geek,kicks-ass,misconfused,podzone,readmyblog,selfip,sellsyourhome,servebbs,serveftp,servegame,stuff-4-sale,webhop,ddnss,accesscam,camdvr,freeddns,mywire,webredirect,eu>al,asso,at,au,be,bg,ca,cd,ch,cn,cy,cz,de,dk,edu,ee,es,fi,fr,gr,hr,hu,ie,il,in,int,is,it,jp,kr,lt,lu,lv,mc,me,mk,mt,my,net,ng,nl,no,nz,paris,pl,pt,q-a,ro,ru,se,si,sk,tr,uk,us<twmail,fedorainfracloud,fedorapeople,fedoraproject>cloud,os>app<stg>os>app<<<freedesktop,hepforge,in-dsl,in-vpn,js,barsy,mayfirst,mozilla-iot,bmoattachments,dynserv,now-dns,cable-modem,collegefan,couchpotatofries,mlbfan,mysecuritycamera,nflfan,read-books,ufcfan,hopto,myftp,no-ip,zapto,httpbin,pubtls,my-firewall,myfirewall,spdns,small-web,dsmynas,familyds,teckids>s3<tuxfamily,diskstation,hk,wmflabs,toolforge,wmcloud,za<cn>com>amazonaws>compute>*<eb>cn-north-1,cn-northwest-1<elb>*<cn-north-1>s3<<<instantcloud,quickconnect>direct<<io>apigee,b-data,backplaneapp,banzaicloud>app,backyards>*<<bitbucket,bluebite,boxfuse,browsersafetymark,bigv>uk0<cleverapps,dappnode>dyndns<dedyn,drud,definima,fh-muenster,shw,forgerock>id<ghost,github,gitlab,lolipop,hasura-app,hostyhosting,moonscale>*<beebyte>paas<beebyteapp>sekd1<jele,unispace>cloud-fr1<webthings,loginline,barsy,azurecontainer>*<ngrok,nodeart>stage<nid,pantheonsite,dyn53,pstmn>mock<protonet,qoto,qcx>sys>*<<vaporcloud,vbrplsbx>g<on-k3s>*<on-rio>*<readthedocs,resindevice,resinstaging>devices<hzc,sandcats,shiftcrypto,shiftedit,mo-siemens,musician,lair>apps<stolos>*<spacekit,utwente,s5y>*<edugit,telebit,thingdust>dev>cust,reservd<disrec>cust,reservd<prod>cust<testing>cust,reservd<<tickets,upli,2038,wedeploy,editorx,basicserver,virtualserver<jp>ne>aseinet>user<gehirn<buyshop,fashionstore,handcrafted,kawaiishop,supersale,theshop,usercontent,angry,babyblue,babymilk,backdrop,bambina,bitter,blush,boo,boy,boyfriend,but,candypop,capoo,catfood,cheap,chicappa,chillout,chips,chowder,chu,ciao,cocotte,coolblog,cranky,cutegirl,daa,deca,deci,digick,egoism,fakefur,fem,flier,floppy,fool,frenchkiss,girlfriend,girly,gloomy,gonna,greater,hacca,heavy,her,hiho,hippy,holy,hungry,icurus,itigo,jellybean,kikirara,kill,kilo,kuron,littlestar,lolipopmc,lolitapunk,lomo,lovepop,lovesick,main,mods,mond,mongolian,moo,namaste,nikita,nobushi,noor,oops,parallel,parasite,pecori,peewee,penne,pepper,perma,pigboat,pinoko,punyu,pupu,pussycat,pya,raindrop,readymade,sadist,schoolbus,secret,staba,stripper,sub,sunnyday,thick,tonkotsu,under,upper,velvet,verse,versus,vivian,watson,weblike,whitesnow,zombie,blogspot<vc>gv>d<0e<eus>party>user<<ws>advisor>*<cloud66,dyndns,mypets<ba>rs,blogspot<cloud>banzai>*<elementor,encoway>eu<statics>*<ravendb,axarnet>es-1<diadem,jelastic>vip<jele,jenv-aruba>aruba>eur>it1<<it1<keliweb>cs<oxa>tn,uk<primetel>uk<reclaim>ca,uk,us<trendhosting>ch,de<jotelulu,kuleuven,linkyard,magentosite>*<perspecta,vapor,on-rancher>*<scw>baremetal>fr-par-1,fr-par-2,nl-ams-1<fr-par>fnc>functions<k8s>nodes<s3,s3-website,whm<instances>priv,pub<k8s,nl-ams>k8s>nodes<s3,s3-website,whm<pl-waw>k8s>nodes<s3,s3-website<scalebook,smartlabeling<sensiosite>*<trafficplex,urown,voorloper<ec>base,official<shop>base,hoplix,barsy<app>beget>*<clerk,clerkstage,wnext,platform0,deta,ondigitalocean,encr,edgecompute,fireweb,onflashdrive,framer,run>a<web,hasura,loginline,messerli,netlify,developer>*<noop,northflank>*<telebit,typedream,vercel,bookonline<la>bnr,c<je>of<ch>square7,blogspot,flow>ae>alp1<appengine<linkyard-cloud,dnsking,gotdns,myspreadshop,firenet>*,svc>*<<12hp,2ix,4lima,lima-city<de>bplaced,square7,com,cosidns>dyn<dynamisches-dns,dnsupdater,internet-dns,l-o-g-i-n,dnshome,fuettertdasnetz,isteingeek,istmein,lebtimnetz,leitungsen,traeumtgerade,ddnss>dyn,dyndns<dyndns1,dyn-ip24,home-webserver>dyn<myhome-server,frusky>*<goip,blogspot,xn--gnstigbestellen-zvb,xn--gnstigliefern-wob,hs-heilbronn>it>pages<<dyn-berlin,in-berlin,in-brb,in-butter,in-dsl,in-vpn,iservschule,mein-iserv,schulplattform,schulserver,test-iserv,keymachine,git-repos,lcube-server,svn-repos,barsy,logoip,firewall-gateway,my-gateway,my-router,spdns,speedpartner>customer<myspreadshop,taifun-dns,12hp,2ix,4lima,lima-city,dd-dns,dray-dns,draydns,dyn-vpn,dynvpn,mein-vigor,my-vigor,my-wan,syno-ds,synology-diskstation,synology-ds,uberspace>*<virtualuser,virtual-user,community-pro,diskussionsbereich<rs>brendly>shop<blogspot,ua,ox<uk>co>bytemark>dh,vm<blogspot,layershift>j<barsy,barsyonline,retrosnub>cust<nh-serv,no-ip,wellbeingzone,adimo,myspreadshop,gwiddle<conn,copro,hosp,independent-commission,independent-inquest,independent-inquiry,independent-panel,independent-review,public-inquiry,royal-commission,gov>campaign,service,api,homeoffice<pymnt,org>glug,lug,lugs,affinitylottery,raffleentry,weeklylottery<barsy<ac>drr<ai>uwu<co>carrd,crd,otap>*<com>blogspot<leadpages,lpages,mypi,n4t,repl>id<supabase<mp>ju<se>com,blogspot,conf,iopsys,itcouldbewor,myspreadshop,paba>su<<bz>za,gsj<in>web,cloudns,blogspot,barsy,supabase<basketball>aus,nz<am>radio,blogspot,neko,nyaa<fm>radio<group>discourse<team>discourse,jelastic<dev>lcl>*<lclstage>*<stg>*<stgstage>*<pages,workers,curv,deno,deno-staging,deta,fly,githubpreview,gateway>*<iserv,localcert>user>*<<loginline,mediatech,platter-app,shiftcrypto,vercel,webhare>*<<me>c66,daplie>localhost<edgestack,filegear,filegear-au,filegear-de,filegear-gb,filegear-ie,filegear-jp,filegear-sg,glitch,ravendb,lohmus,barsy,mcpe,mcdir,soundcast,tcp4,brasilia,ddns,dnsfor,hopto,loginto,noip,webhop,vp4,diskstation,dscloud,i234,myds,synology,tbits,transip>site<wedeploy,yombo,nohost<zone>cloud66,hs,triton>*<lima<host>cloudaccess,freesite,fastvps,myfast,tempurl,wpmudev,jele,mircloud,pcloud,half<site>cloudera>*<cyon,fnwk,folionetwork,fastvps,jele,lelux,loginline,barsy,mintere,omniwe,opensocial,platformsh>*<tst>*<byen,srht,novecore<cz>co,realm,e4,blogspot,metacentrum>cloud>*<custom<muni>cloud>flt,usr<<<asia>cloudns<biz>cloudns,jozi,dyndns,for-better,for-more,for-some,for-the,selfip,webhop,orx,mmafan,myftp,no-ip,dscloud<club>cloudns,jele,barsy,pony<cc>cloudns,ftpaccess,game-server,myphotos,scrapping,twmail,csx,fantasyleague,spawn>instances<<info>cloudns,dynamic-dns,dyndns,barrel-of-knowledge,barrell-of-knowledge,for-our,groks-the,groks-this,here-for-more,knowsitall,selfip,webhop,barsy,mayfirst,forumz,nsupdate,dvrcam,ilovecollege,no-ip,dnsupdate,v-info<pro>cloudns,dnstrace>bci<barsy<pw>cloudns,x443<gdn>cnpy<nl>co,hosting-cluster,blogspot,gov,khplay,myspreadshop,transurl>*<cistron,demon<no>co,blogspot,myspreadshop<be>webhosting,blogspot,interhostsolutions>cloud<kuleuven>ezproxy<myspreadshop,transurl>*<<ru>ac,edu,gov,int,mil,test,eurodir,adygeya,bashkiria,bir,cbg,com,dagestan,grozny,kalmykia,kustanai,marine,mordovia,msk,mytis,nalchik,nov,pyatigorsk,spb,vladikavkaz,vladimir,blogspot,na4u,mircloud,regruhosting>jelastic<myjino>hosting>*<landing>*<spectrum>*<vps>*<<cldmail>hb<mcdir>vps<mcpre,net,org,pp,lk3,ras<is>cupcake,blogspot<link>cyon,mypep,dweb>*<<dk>biz,co,firm,reg,store,blogspot,myspreadshop<earth>dapps>*,bzz>*<<<id>my>rss>*<<flap,co>blogspot<forte<solutions>diher>*<<th>online,shop<sh>bip,hashbang,platform>bc,ent,eu,us<now,vxl,wedeploy<fi>dy,blogspot,xn--hkkinen-5wa,iki,cloudplatform>fi<datacenter>demo,paas<kapsi,myspreadshop<tv>dyndns,better-than,on-the-web,worse-than<cx>ath,info<name>her>forgot<his>forgot<<nu>merseine,mine,shacknet,enterprisecloud<rocks>myddns,lima-city,webspace<xyz>blogsite,localzone,crafting,zapto,telebit>*<<online>eero,eero-stage,barsy<cool>elementor,de<fr>en-root,fbx-os,fbxos,freebox-os,freeboxos,blogspot,goupile,on-web,chirurgiens-dentistes-en-france,dedibox,myspreadshop,ynh<one>onred>staging<for,under,service,homelink<tw>com>mymailer<url,blogspot<su>abkhazia,adygeya,aktyubinsk,arkhangelsk,armenia,ashgabad,azerbaijan,balashov,bashkiria,bryansk,bukhara,chimkent,dagestan,east-kazakhstan,exnet,georgia,grozny,ivanovo,jambyl,kalmykia,kaluga,karacol,karaganda,karelia,khakassia,krasnodar,kurgan,kustanai,lenug,mangyshlak,mordovia,msk,murmansk,nalchik,navoi,north-kazakhstan,nov,obninsk,penza,pokrovsk,sochi,spb,tashkent,termez,togliatti,troitsk,tselinograd,tula,tuva,vladikavkaz,vladimir,vologda<space>myfast,uber,xs4all<il>co>ravpage,blogspot,tabitorder<<at>funkfeuer>wien<futurecms>*,ex>*<in>*<<futurehosting,futuremailing,ortsinfo>ex>*<kunden>*<<co>blogspot<biz,info,priv,myspreadshop,12hp,2ix,4lima,lima-city<ms>lab,minisite<si>gitapp,gitpage,blogspot<community>nog,ravendb,myforum<ro>co,shop,blogspot,barsy<digital>cloudapps>london<<im>ro<goog>cloud,translate,usercontent>*<<ae>blogspot<al>blogspot<bg>blogspot,barsy<bj>blogspot<cf>blogspot<cl>blogspot<ke>co>blogspot<<nz>co>blogspot<<za>co>blogspot<<ar>com>blogspot<<au>com>blogspot,cloudlets>mel<myspreadshop<<br>com>blogspot,virtualcloud>scale>users<<<leg>ac,al,am,ap,ba,ce,df,es,go,ma,mg,ms,mt,pa,pb,pe,pi,pr,rj,rn,ro,rr,rs,sc,se,sp,to<<by>com>blogspot<mycloud,mediatech<cy>com>blogspot,scaleforce>j<<<ee>com>blogspot<<eg>com>blogspot<<es>com>blogspot<myspreadshop<mt>com>blogspot<<ng>com>blogspot<col,firm,gen,ltd,ngo<tr>com>blogspot<<uy>com>blogspot<<cv>blogspot<gr>blogspot<hk>blogspot,secaas,ltd,inc<hr>blogspot,free<hu>blogspot<ie>blogspot,myspreadshop<it>blogspot,ibxos,iliadboxos,neen>jc<tim>open>jelastic>cloud<<<16-b,32-b,64-b,myspreadshop,syncloud<kr>blogspot<li>blogspot,caa<lt>blogspot<lu>blogspot<md>blogspot,at,de,jp,to<mk>blogspot<mr>blogspot<mx>blogspot<my>blogspot<pe>blogspot<pt>blogspot<qa>blogspot<re>blogspot<sg>blogspot,enscaled<sk>blogspot<sn>blogspot<td>blogspot<ug>blogspot<vn>blogspot<ci>fin,nl<run>hs,development,ravendb,servers,build>*<code>*<database>*<migration>*<onporter,repl<gl>biz,xx<scot>edu,gov>service<<so>sch<kz>jcloud,kazteleport>upaas<<tn>orangecloud<gg>kaas,cya,panel>daemon<<systems>knightpoint<events>koobin,co<krd>co,edu<business>co<education>co<financial>co<place>co<technology>co<bs>we<services>loginline<menu>barsy<mobi>barsy,dscloud<pub>barsy<support>barsy<vu>cn,blog,dev,me<health>hra<casa>nabu>ui<<fashion>of<london>in,of<marketing>from,with<men>for,repair<mom>and,for<sale>for<win>that<work>from,to<news>noticeable<top>now-dns,ntdll<ovh>nerdpol<mn>nyc<lol>omg<hosting>opencraft<orange>tech<pm>own,name<codes>owo>*<<lc>oy<bn>co<today>prequalifyme<builders>cloudsite<edu>rit>git-pages<<xn--p1acf>xn--90amc,xn--j1aef,xn--j1ael8b,xn--h1ahn,xn--j1adp,xn--c1avg,xn--80aaa0cvac,xn--h1aliz,xn--90a1af,xn--41a<store>sellfy,shopware,storebase<land>static>dev,sites<<farm>storj<pictures>1337<rip>clan<tf>sch<wf>biz,sch<yt>org<management>router<ax>be,cat,es,eu,gg,mc,us,xy<gp>app<gt>blog,de,to<gy>be<hn>cc<kg>blog,io,jp,tv,uk,us<ls>de<porn>indie<tc>ch,me,we<vg>at<academy>official<faith>ybo<party>ybo<review>ybo<science>ybo<trade>ybo<st>noho<design>bss";

// node_modules/parse-domain/build/trie/characters.js
var UP = "<";
var SAME = ",";
var DOWN = ">";
var RESET = "|";
var WILDCARD = "*";
var EXCEPTION = "!";

// node_modules/parse-domain/build/trie/look-up.js
var lookUpTldsInTrie = (labels, trie) => {
  const labelsToCheck = labels.slice();
  const tlds = [];
  let node = trie;
  while (labelsToCheck.length !== 0) {
    const label = labelsToCheck.pop();
    const labelLowerCase = label.toLowerCase();
    if (node.children.has(WILDCARD)) {
      if (node.children.has(EXCEPTION + labelLowerCase)) {
        break;
      }
      node = node.children.get(WILDCARD);
    } else {
      if (node.children.has(labelLowerCase) === false) {
        break;
      }
      node = node.children.get(labelLowerCase);
    }
    tlds.unshift(label);
  }
  return tlds;
};

// node_modules/ip-regex/index.js
var word = "[a-fA-F\\d:]";
var boundry = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6segment = "[a-fA-F\\d]{1,4}";
var v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
var v4exact = new RegExp(`^${v4}$`);
var v6exact = new RegExp(`^${v6}$`);
var ipRegex = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${boundry(options)}${v4}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, "g");
ipRegex.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v4}${boundry(options)}`, "g");
ipRegex.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, "g");
var ip_regex_default = ipRegex;

// node_modules/is-ip/index.js
function isIP(string) {
  return ip_regex_default({ exact: true }).test(string);
}
function isIPv6(string) {
  return ip_regex_default.v6({ exact: true }).test(string);
}
function ipVersion(string) {
  return isIP(string) ? isIPv6(string) ? 6 : 4 : void 0;
}

// node_modules/parse-domain/build/sanitize.js
var LABEL_SEPARATOR = ".";
var LABEL_LENGTH_MIN = 1;
var LABEL_LENGTH_MAX = 63;
var DOMAIN_LENGTH_MAX = 253;
var textEncoder = new TextEncoder();
var Validation;
(function(Validation2) {
  Validation2["Lax"] = "LAX";
  Validation2["Strict"] = "STRICT";
})(Validation || (Validation = {}));
var ValidationErrorType;
(function(ValidationErrorType2) {
  ValidationErrorType2["NoHostname"] = "NO_HOSTNAME";
  ValidationErrorType2["DomainMaxLength"] = "DOMAIN_MAX_LENGTH";
  ValidationErrorType2["LabelMinLength"] = "LABEL_MIN_LENGTH";
  ValidationErrorType2["LabelMaxLength"] = "LABEL_MAX_LENGTH";
  ValidationErrorType2["LabelInvalidCharacter"] = "LABEL_INVALID_CHARACTER";
  ValidationErrorType2["LastLabelInvalid"] = "LAST_LABEL_INVALID";
})(ValidationErrorType || (ValidationErrorType = {}));
var SanitizationResultType;
(function(SanitizationResultType2) {
  SanitizationResultType2["ValidIp"] = "VALID_IP";
  SanitizationResultType2["ValidDomain"] = "VALID_DOMAIN";
  SanitizationResultType2["Error"] = "ERROR";
})(SanitizationResultType || (SanitizationResultType = {}));
var createNoHostnameError = (input) => {
  return {
    type: ValidationErrorType.NoHostname,
    message: `The given input ${String(input)} does not look like a hostname.`,
    column: 1
  };
};
var createDomainMaxLengthError = (domain, length) => {
  return {
    type: ValidationErrorType.DomainMaxLength,
    message: `Domain "${domain}" is too long. Domain is ${length} octets long but should not be longer than ${DOMAIN_LENGTH_MAX}.`,
    column: length
  };
};
var createLabelMinLengthError = (label, column) => {
  const length = label.length;
  return {
    type: ValidationErrorType.LabelMinLength,
    message: `Label "${label}" is too short. Label is ${length} octets long but should be at least ${LABEL_LENGTH_MIN}.`,
    column
  };
};
var createLabelMaxLengthError = (label, column) => {
  const length = label.length;
  return {
    type: ValidationErrorType.LabelMaxLength,
    message: `Label "${label}" is too long. Label is ${length} octets long but should not be longer than ${LABEL_LENGTH_MAX}.`,
    column
  };
};
var createLabelInvalidCharacterError = (label, invalidCharacter, column) => {
  return {
    type: ValidationErrorType.LabelInvalidCharacter,
    message: `Label "${label}" contains invalid character "${invalidCharacter}" at column ${column}.`,
    column
  };
};
var createLastLabelInvalidError = (label, column) => {
  return {
    type: ValidationErrorType.LabelInvalidCharacter,
    message: `Last label "${label}" must not be all-numeric.`,
    column
  };
};
var sanitize = (input, options = {}) => {
  if (typeof input !== "string") {
    return {
      type: SanitizationResultType.Error,
      errors: [createNoHostnameError(input)]
    };
  }
  if (input === "") {
    return {
      type: SanitizationResultType.ValidDomain,
      domain: input,
      labels: []
    };
  }
  const inputTrimmedAsIp = input.replace(/^\[|]$/g, "");
  const ipVersionOfInput = ipVersion(inputTrimmedAsIp);
  if (ipVersionOfInput !== void 0) {
    return {
      type: SanitizationResultType.ValidIp,
      ip: inputTrimmedAsIp,
      ipVersion: ipVersionOfInput
    };
  }
  const lastChar = input.charAt(input.length - 1);
  const canonicalInput = lastChar === LABEL_SEPARATOR ? input.slice(0, -1) : input;
  const octets = new TextEncoder().encode(canonicalInput);
  if (octets.length > DOMAIN_LENGTH_MAX) {
    return {
      type: SanitizationResultType.Error,
      errors: [createDomainMaxLengthError(input, octets.length)]
    };
  }
  const labels = canonicalInput.split(LABEL_SEPARATOR);
  const { validation = Validation.Strict } = options;
  const labelValidationErrors = validateLabels[validation](labels);
  if (labelValidationErrors.length > 0) {
    return {
      type: SanitizationResultType.Error,
      errors: labelValidationErrors
    };
  }
  return {
    type: SanitizationResultType.ValidDomain,
    domain: input,
    labels
  };
};
var validateLabels = {
  [Validation.Lax]: (labels) => {
    const labelValidationErrors = [];
    let column = 1;
    for (const label of labels) {
      const octets = textEncoder.encode(label);
      if (octets.length < LABEL_LENGTH_MIN) {
        labelValidationErrors.push(createLabelMinLengthError(label, column));
      } else if (octets.length > LABEL_LENGTH_MAX) {
        labelValidationErrors.push(createLabelMaxLengthError(label, column));
      }
      column += label.length + LABEL_SEPARATOR.length;
    }
    return labelValidationErrors;
  },
  [Validation.Strict]: (labels) => {
    const labelValidationErrors = [];
    let column = 1;
    let lastLabel;
    for (const label of labels) {
      const invalidCharacter = /[^\da-z-]/i.exec(label);
      if (invalidCharacter) {
        labelValidationErrors.push(createLabelInvalidCharacterError(label, invalidCharacter[0], invalidCharacter.index + 1));
      }
      if (label.startsWith("-")) {
        labelValidationErrors.push(createLabelInvalidCharacterError(label, "-", column));
      } else if (label.endsWith("-")) {
        labelValidationErrors.push(createLabelInvalidCharacterError(label, "-", column + label.length - 1));
      }
      if (label.length < LABEL_LENGTH_MIN) {
        labelValidationErrors.push(createLabelMinLengthError(label, column));
      } else if (label.length > LABEL_LENGTH_MAX) {
        labelValidationErrors.push(createLabelMaxLengthError(label, column));
      }
      column += label.length + LABEL_SEPARATOR.length;
      lastLabel = label;
    }
    if (lastLabel !== void 0 && /[a-z-]/iu.test(lastLabel) === false) {
      labelValidationErrors.push(createLastLabelInvalidError(lastLabel, column - lastLabel.length - LABEL_SEPARATOR.length));
    }
    return labelValidationErrors;
  }
};

// node_modules/parse-domain/build/trie/nodes.js
var NODE_TYPE_ROOT = Symbol("ROOT");
var NODE_TYPE_CHILD = Symbol("CHILD");
var createRootNode = () => {
  return {
    type: NODE_TYPE_ROOT,
    children: /* @__PURE__ */ new Map()
  };
};
var createOrGetChild = (parent, label) => {
  let child = parent.children.get(label);
  if (child === void 0) {
    child = {
      type: NODE_TYPE_CHILD,
      label,
      children: /* @__PURE__ */ new Map(),
      parent
    };
    parent.children.set(label, child);
  }
  return child;
};

// node_modules/parse-domain/build/trie/parse-trie.js
var parseTrie = (serializedTrie) => {
  const rootNode = createRootNode();
  let domain = "";
  let parentNode = rootNode;
  let node = rootNode;
  const addDomain = () => {
    node = createOrGetChild(parentNode, domain);
    domain = "";
  };
  for (let i = 0; i < serializedTrie.length; i++) {
    const char = serializedTrie.charAt(i);
    switch (char) {
      case SAME: {
        addDomain();
        continue;
      }
      case DOWN: {
        addDomain();
        parentNode = node;
        continue;
      }
      case RESET: {
        addDomain();
        parentNode = rootNode;
        continue;
      }
      case UP: {
        if (parentNode.type === NODE_TYPE_ROOT) {
          throw new Error(`Error in serialized trie at position ${i}: Cannot go up, current parent node is already root`);
        }
        addDomain();
        parentNode = parentNode.parent;
        continue;
      }
    }
    domain += char;
  }
  if (domain !== "") {
    addDomain();
  }
  return rootNode;
};

// node_modules/parse-domain/build/parse-domain.js
var RESERVED_TOP_LEVEL_DOMAINS = [
  "localhost",
  "local",
  "example",
  "invalid",
  "test"
];
var ParseResultType;
(function(ParseResultType2) {
  ParseResultType2["Invalid"] = "INVALID";
  ParseResultType2["Ip"] = "IP";
  ParseResultType2["Reserved"] = "RESERVED";
  ParseResultType2["NotListed"] = "NOT_LISTED";
  ParseResultType2["Listed"] = "LISTED";
})(ParseResultType || (ParseResultType = {}));
var getAtIndex = (array, index) => {
  return index >= 0 && index < array.length ? array[index] : void 0;
};
var splitLabelsIntoDomains = (labels, index) => {
  return {
    subDomains: labels.slice(0, Math.max(0, index)),
    domain: getAtIndex(labels, index),
    topLevelDomains: labels.slice(index + 1)
  };
};
var parsedIcannTrie;
var parsedPrivateTrie;
var parseDomain = (hostname, options) => {
  const sanitizationResult = sanitize(hostname, options);
  if (sanitizationResult.type === SanitizationResultType.Error) {
    return {
      type: ParseResultType.Invalid,
      hostname,
      errors: sanitizationResult.errors
    };
  }
  if (sanitizationResult.type === SanitizationResultType.ValidIp) {
    return {
      type: ParseResultType.Ip,
      hostname: sanitizationResult.ip,
      ipVersion: sanitizationResult.ipVersion
    };
  }
  const { labels, domain } = sanitizationResult;
  if (hostname === "" || RESERVED_TOP_LEVEL_DOMAINS.includes(labels[labels.length - 1])) {
    return {
      type: ParseResultType.Reserved,
      hostname: domain,
      labels
    };
  }
  parsedIcannTrie = parsedIcannTrie !== null && parsedIcannTrie !== void 0 ? parsedIcannTrie : parseTrie(icann_default);
  parsedPrivateTrie = parsedPrivateTrie !== null && parsedPrivateTrie !== void 0 ? parsedPrivateTrie : parseTrie(private_default);
  const icannTlds = lookUpTldsInTrie(labels, parsedIcannTrie);
  const privateTlds = lookUpTldsInTrie(labels, parsedPrivateTrie);
  if (icannTlds.length === 0 && privateTlds.length === 0) {
    return {
      type: ParseResultType.NotListed,
      hostname: domain,
      labels
    };
  }
  const indexOfPublicSuffixDomain = labels.length - Math.max(privateTlds.length, icannTlds.length) - 1;
  const indexOfIcannDomain = labels.length - icannTlds.length - 1;
  return Object.assign({ type: ParseResultType.Listed, hostname: domain, labels, icann: splitLabelsIntoDomains(labels, indexOfIcannDomain) }, splitLabelsIntoDomains(labels, indexOfPublicSuffixDomain));
};

// node_modules/parse-domain/build/from-url.js
var urlPattern = /^[a-z][*+.a-z-]+:\/\//i;
var invalidIpv6Pattern = /^([a-z][*+.a-z-]+:\/\/)([^[][^/?]*:[^/?]*:[^/?]*)(.*)/i;
var NO_HOSTNAME = Symbol("NO_HOSTNAME");
var fromUrl = (urlLike) => {
  if (typeof URL !== "function") {
    throw new Error("Looks like the new URL() constructor is not globally available in your environment. Please make sure to use a polyfill.");
  }
  if (typeof urlLike !== "string") {
    return NO_HOSTNAME;
  }
  let url = urlLike.startsWith("//") ? `http:${urlLike}` : urlLike.startsWith("/") ? urlLike : urlPattern.test(urlLike) ? urlLike : `http://${urlLike}`;
  url = url.replace(invalidIpv6Pattern, "$1[$2]$3");
  try {
    return new URL(url).hostname;
  } catch (_a) {
    return NO_HOSTNAME;
  }
};

// src/utils/utility.ts
var Utility = class {
  static assertNotNull(value) {
    if (!value) {
      throw new Error("Value is null");
    }
  }
  static parseDomainFromUrl(Url) {
    return parseDomain(fromUrl(Url)).hostname.toString();
  }
  static cleanHeading(heading) {
    let cleanHeading = heading;
    if (heading.startsWith("#") && heading[1] == " ") {
      cleanHeading = heading.substring(2);
    }
    return cleanHeading;
  }
};

// src/periodicnotes/filewriter.ts
var FileWriter = class {
  constructor(app, openFileOnWrite) {
    this.app = app;
    this.openFileOnWrite = openFileOnWrite;
  }
  async write(file, clippedData, heading) {
    const fileData = await this.app.vault.read(file);
    const fileLines = fileData.split("\n");
    if (!heading) {
      const startLine = this.getEndOfFrontmatter(file);
      return this.writeAndOpenFile(file.path, this.positionDataWithNoHeader(fileData, clippedData, startLine));
    } else {
      let insertSection = {
        firstLine: 0,
        lastLine: 0
      };
      try {
        insertSection = this.getEndAndBeginningOfHeading(file, heading);
      } catch (e) {
        throw Error("Missing Expected Heading");
      }
      const preSectionContent = fileLines.slice(0, insertSection.firstLine);
      let targetSection = fileLines.slice(insertSection.firstLine, insertSection.lastLine);
      targetSection = this.positionDataWithHeader(targetSection, clippedData);
      let lines = [];
      if (insertSection.lastLine !== -1) {
        const postSectionContent = fileLines.slice(insertSection.lastLine);
        lines = [...preSectionContent, ...targetSection, ...postSectionContent];
      } else {
        lines = [...preSectionContent, ...targetSection];
      }
      return this.writeAndOpenFile(file.path, lines.join("\n"));
    }
  }
  async writeAndOpenFile(outputFileName, text2) {
    const file = this.app.vault.getAbstractFileByPath(outputFileName);
    if (file instanceof import_obsidian2.TFile) {
      await this.app.vault.modify(file, text2);
    } else {
      const parts = outputFileName.split("/");
      const dir = parts.slice(0, parts.length - 1).join("/");
      if (parts.length > 1 && !(this.app.vault.getAbstractFileByPath(dir) instanceof import_obsidian2.TFolder)) {
        await this.app.vault.createFolder(dir);
      }
      const base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
      if (base64regex.test(text2)) {
        await this.app.vault.createBinary(outputFileName, (0, import_obsidian2.base64ToArrayBuffer)(text2));
      } else {
        await this.app.vault.create(outputFileName, text2);
      }
    }
    if (this.openFileOnWrite) {
      let fileIsAlreadyOpened = false;
      this.app.workspace.iterateAllLeaves((leaf) => {
        var _a;
        if (((_a = leaf.view.file) == null ? void 0 : _a.path) === outputFileName) {
          fileIsAlreadyOpened = true;
          this.app.workspace.setActiveLeaf(leaf, { focus: true });
        }
      });
      if (!fileIsAlreadyOpened)
        await this.app.workspace.openLinkText(outputFileName, "", false);
    }
    return this.app.vault.getAbstractFileByPath(outputFileName);
  }
  getEndAndBeginningOfHeading(file, heading) {
    const cache = this.app.metadataCache.getFileCache(file);
    Utility.assertNotNull(cache);
    heading = Utility.cleanHeading(heading);
    try {
      const cachedHeadings = cache.headings;
      Utility.assertNotNull(cachedHeadings);
      const foundHeadingIndex = cachedHeadings.findIndex((cachedHeading) => {
        return cachedHeading.heading === heading && cachedHeading.level === 1;
      });
      if (foundHeadingIndex !== -1) {
        const foundHeading = cachedHeadings[foundHeadingIndex];
        let nextHeading = null;
        for (let i = foundHeadingIndex + 1; i < (cachedHeadings == null ? void 0 : cachedHeadings.length); i++) {
          const cachedHeading = cachedHeadings[i];
          if (cachedHeading.level === 1) {
            nextHeading = cachedHeading;
            break;
          }
        }
        const prependLine = foundHeading.position.start.line;
        let appendLine = -1;
        if (nextHeading) {
          appendLine = nextHeading.position.start.line;
        }
        return { lastLine: appendLine, firstLine: prependLine };
      } else {
        throw Error("Heading not found");
      }
    } catch (e) {
      new import_obsidian2.Notice("Can't find heading");
      throw Error("Heading not found");
    }
  }
  getEndOfFrontmatter(file) {
    var _a;
    let endLine = 0;
    if (file) {
      const cache = this.app.metadataCache;
      if (cache) {
        const sections = (_a = cache.getFileCache(file)) == null ? void 0 : _a.sections;
        const frontmatter = sections == null ? void 0 : sections.find((item) => {
          return item.type === "yaml";
        });
        if (frontmatter) {
          endLine = frontmatter.position.end.line;
        }
      }
    }
    return endLine + 1;
  }
};

// src/periodicnotes/appendwriter.ts
var AppendWriter = class extends FileWriter {
  positionDataWithNoHeader(fileData, clippedData) {
    return fileData + "\n" + clippedData;
  }
  positionDataWithHeader(targetSection, clippedData) {
    targetSection.push(clippedData);
    return targetSection;
  }
};

// src/periodicnotes/prependwriter.ts
var PrependWriter = class extends FileWriter {
  positionDataWithNoHeader(fileData, clippedData, startLine = 0) {
    const fileLines = fileData.split("\n");
    const preSectionContent = fileLines.slice(0, startLine);
    const restOfContent = fileLines.slice(startLine);
    return [...preSectionContent, clippedData, ...restOfContent].join("\n");
  }
  positionDataWithHeader(targetSection, clippedData) {
    targetSection.splice(1, 0, clippedData);
    return targetSection;
  }
};

// src/abstracts/noteentry.ts
var NoteEntry = class {
  constructor(app, openFileOnWrite, sectionPosition, template) {
    this.app = app;
    this.openFileOnWrite = openFileOnWrite;
    this.sectionPosition = sectionPosition;
    this.template = template;
  }
  async handleWrite(noteFilePath, data, heading) {
    const file = this.app.vault.getAbstractFileByPath(noteFilePath);
    if (file instanceof import_obsidian3.TFile) {
      if (this.sectionPosition === SectionPosition.PREPEND) {
        new PrependWriter(this.app, this.openFileOnWrite).write(file, data, heading);
      } else {
        new AppendWriter(this.app, this.openFileOnWrite).write(file, data, heading);
      }
    } else {
      new import_obsidian3.Notice(`Obsidian Clipper couldn't find the note to ${this.sectionPosition} to`);
    }
  }
};

// src/periodicnotes/periodicnoteentry.ts
var PeriodicNoteEntry = class extends NoteEntry {
  constructor(app, openFileOnWrite, sectionPosition, template) {
    super(app, openFileOnWrite, sectionPosition, template);
    this.template = template;
  }
  async writeToPeriodicNote(noteEntry, heading) {
    if (!this.hasPeriodicNoteEnabled()) {
      new import_obsidian4.Notice(this.notice);
      return;
    }
    const note = await this.getNote();
    this.handleWrite(note.path, await noteEntry.formattedEntry(this.template), heading);
  }
  async getNote() {
    const now2 = globalThis.moment();
    const allNotes = this.getAllNotes();
    const periodicNote = this.getPeriodicNote(now2, allNotes);
    if (!periodicNote) {
      return await this.waitForNoteCreation(now2);
    }
    return periodicNote;
  }
};

// src/periodicnotes/dailyperiodicnoteentry.ts
var DailyPeriodicNoteEntry = class extends PeriodicNoteEntry {
  constructor(app, openFileOnWrite, sectionPosition, template) {
    super(app, openFileOnWrite, sectionPosition, template);
    this.notice = "To use a daily note with Obsidian Clipper the daily note needs to be enabled from the periodic-notes plugin";
  }
  getPeriodicNote(moment, allNotes) {
    return (0, import_obsidian_daily_notes_interface.getDailyNote)(moment, allNotes);
  }
  hasPeriodicNoteEnabled() {
    return (0, import_obsidian_daily_notes_interface.appHasDailyNotesPluginLoaded)();
  }
  async waitForNoteCreation(moment) {
    const dailyNote = await (0, import_obsidian_daily_notes_interface.createDailyNote)(moment);
    await new Promise((r) => setTimeout(r, 50));
    return dailyNote;
  }
  getAllNotes() {
    return (0, import_obsidian_daily_notes_interface.getAllDailyNotes)();
  }
};

// src/periodicnotes/weeklyperiodicnoteentry.ts
var import_obsidian_daily_notes_interface2 = __toESM(require_main());
var WeeklyPeriodicNoteEntry = class extends PeriodicNoteEntry {
  constructor(app, openFileOnWrite, sectionPosition, template) {
    super(app, openFileOnWrite, sectionPosition, template);
    this.notice = "To use a weekly note with Obsidian Clipper the weekly note needs to be enabled from the periodic-notes plugin";
  }
  getPeriodicNote(moment, allNotes) {
    return (0, import_obsidian_daily_notes_interface2.getWeeklyNote)(moment, allNotes);
  }
  hasPeriodicNoteEnabled() {
    return (0, import_obsidian_daily_notes_interface2.appHasWeeklyNotesPluginLoaded)();
  }
  async waitForNoteCreation(moment) {
    const weeklyNote = await (0, import_obsidian_daily_notes_interface2.createWeeklyNote)(moment);
    await new Promise((r) => setTimeout(r, 50));
    return weeklyNote;
  }
  getAllNotes() {
    return (0, import_obsidian_daily_notes_interface2.getAllWeeklyNotes)();
  }
};

// node_modules/svelte/internal/index.mjs
function noop() {
}
var identity = (x) => x;
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn2) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn2);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn2) {
  return definition[1] && fn2 ? assign($$scope.ctx.slice(), definition[1](fn2(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn2) {
  if (definition[2] && fn2) {
    const lets = definition[2](fn2(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
function select_value(select) {
  const selected_option = select.querySelector(":checked") || select.options[0];
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
function construct_svelte_component(component, props) {
  return new component(props);
}
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash(str) {
  let hash4 = 5381;
  let i = str.length;
  while (i--)
    hash4 = (hash4 << 5) - hash4 ^ str.charCodeAt(i);
  return hash4 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn2, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn2(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn2(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1);
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onDestroy(fn2) {
  get_current_component().$$.on_destroy.push(fn2);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn2) => fn2.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_in_transition(node, fn2, params) {
  const options = { direction: "in" };
  let config = fn2(node, params, options);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function go() {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick2(0, 1);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, "start"));
    task = loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(1, 0);
          dispatch(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(t, 1 - t);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function(config)) {
        config = config(options);
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_out_transition(node, fn2, params) {
  const options = { direction: "out" };
  let config = fn2(node, params, options);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;
  function go() {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    add_render_callback(() => dispatch(node, false, "start"));
    loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(0, 1);
          dispatch(node, false, "end");
          if (!--group.r) {
            run_all(group.c);
          }
          return false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(1 - t, t);
        }
      }
      return running;
    });
  }
  if (is_function(config)) {
    wait().then(() => {
      config = config(options);
      go();
    });
  } else {
    go();
  }
  return {
    end(reset) {
      if (reset && config.tick) {
        config.tick(1, 0);
      }
      if (running) {
        if (animation_name)
          delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance16, create_fragment16, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance16 ? instance16(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment16 ? create_fragment16($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/easing/index.mjs
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}

// node_modules/svelte/transition/index.mjs
function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const height = parseFloat(style.height);
  const padding_top = parseFloat(style.paddingTop);
  const padding_bottom = parseFloat(style.paddingBottom);
  const margin_top = parseFloat(style.marginTop);
  const margin_bottom = parseFloat(style.marginBottom);
  const border_top_width = parseFloat(style.borderTopWidth);
  const border_bottom_width = parseFloat(style.borderBottomWidth);
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};height: ${t * height}px;padding-top: ${t * padding_top}px;padding-bottom: ${t * padding_bottom}px;margin-top: ${t * margin_top}px;margin-bottom: ${t * margin_bottom}px;border-top-width: ${t * border_top_width}px;border-bottom-width: ${t * border_bottom_width}px;`
  };
}

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance16 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance16.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance16.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance16.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance16.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash2 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash3 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash3[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance16 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance16.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance16
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance16.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance16;
    }
    instance16.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance16,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance16;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/svelte-popperjs/dist/index.es.js
function createPopperActions(initOptions) {
  let popperInstance = null;
  let referenceNode;
  let contentNode;
  let options = initOptions;
  const initPopper = () => {
    if (referenceNode !== void 0 && contentNode !== void 0) {
      popperInstance = createPopper(referenceNode, contentNode, options);
    }
  };
  const deinitPopper = () => {
    if (popperInstance !== null) {
      popperInstance.destroy();
      popperInstance = null;
    }
  };
  const referenceAction = (node) => {
    if ("subscribe" in node) {
      setupVirtualElementObserver(node);
      return {};
    } else {
      referenceNode = node;
      initPopper();
      return {
        destroy() {
          deinitPopper();
        }
      };
    }
  };
  const setupVirtualElementObserver = (node) => {
    const unsubscribe = node.subscribe(($node) => {
      if (referenceNode === void 0) {
        referenceNode = $node;
        initPopper();
      } else {
        Object.assign(referenceNode, $node);
        popperInstance == null ? void 0 : popperInstance.update();
      }
    });
    onDestroy(unsubscribe);
  };
  const contentAction = (node, contentOptions) => {
    contentNode = node;
    options = { ...initOptions, ...contentOptions };
    initPopper();
    return {
      update(newContentOptions) {
        options = { ...initOptions, ...newContentOptions };
        popperInstance == null ? void 0 : popperInstance.setOptions(options);
      },
      destroy() {
        deinitPopper();
      }
    };
  };
  return [referenceAction, contentAction, () => popperInstance];
}

// src/settings/components/TemplateSuggest.svelte
function add_css(target) {
  append_styles(target, "svelte-153zjst", ".search_input.svelte-153zjst{width:calc(100% - 20px)}.suggestion-container.svelte-153zjst{text-align:left}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function create_if_block(ctx) {
  let div2;
  let div1;
  let div0;
  let t1;
  let popperContent_action;
  let mounted;
  let dispose;
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "None";
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "suggestion-item");
      attr(div1, "class", "suggestion");
      attr(div2, "class", "suggestion-container svelte-153zjst");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div1, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      if (!mounted) {
        dispose = [
          listen(div0, "keydown", ctx[16]),
          listen(div0, "focus", ctx[17]),
          listen(div0, "blur", ctx[18]),
          listen(div0, "click", ctx[20]),
          listen(div0, "mouseover", ctx[8]),
          listen(div0, "mouseout", ctx[9]),
          action_destroyer(popperContent_action = ctx[5].call(null, div2, ctx[6]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 904) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block(ctx) {
  let div;
  let t0_value = ctx[22] + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[21](ctx[22]);
  }
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      attr(div, "class", "suggestion-item");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (!mounted) {
        dispose = [
          listen(div, "keydown", ctx[13]),
          listen(div, "focus", ctx[14]),
          listen(div, "blur", ctx[15]),
          listen(div, "click", click_handler_1),
          listen(div, "mouseover", ctx[8]),
          listen(div, "mouseout", ctx[9])
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 8 && t0_value !== (t0_value = ctx[22] + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment(ctx) {
  let div3;
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let a;
  let t5;
  let div6;
  let div5;
  let div4;
  let input;
  let popperRef_action;
  let t6;
  let mounted;
  let dispose;
  let if_block = ctx[3].length > 0 && create_if_block(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[1]);
      t1 = space();
      div1 = element("div");
      t2 = text(ctx[2]);
      t3 = space();
      a = element("a");
      a.textContent = "Template Example";
      t5 = space();
      div6 = element("div");
      div5 = element("div");
      div4 = element("div");
      input = element("input");
      t6 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(a, "href", "https://raw.githubusercontent.com/jgchristopher/obsidian-clipper/main/docs/example-template.md");
      attr(div2, "class", "setting-item-info");
      attr(div3, "class", "setting-item align-start");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "class", "search_input svelte-153zjst");
      attr(div4, "class", "search_input svelte-153zjst");
      attr(div5, "class", "setting-item-control");
      attr(div6, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div2, t3);
      append(div2, a);
      insert(target, t5, anchor);
      insert(target, div6, anchor);
      append(div6, div5);
      append(div5, div4);
      append(div4, input);
      set_input_value(input, ctx[0]);
      append(div5, t6);
      if (if_block)
        if_block.m(div5, null);
      if (!mounted) {
        dispose = [
          action_destroyer(popperRef_action = ctx[4].call(null, input)),
          listen(input, "input", ctx[19]),
          listen(input, "input", ctx[10]),
          listen(input, "focusin", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        set_data(t0, ctx2[1]);
      if (dirty & 4)
        set_data(t2, ctx2[2]);
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (ctx2[3].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div5, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div6);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { name } = $$props;
  let { description } = $$props;
  let { initialValue } = $$props;
  let { onChange } = $$props;
  let { dataProvider } = $$props;
  const [popperRef, popperContent] = createPopperActions({
    placement: "bottom-start",
    strategy: "fixed"
  });
  const extraOpts = {
    modifiers: [
      {
        name: "offset",
        options: { offset: [0, 5] }
      },
      {
        name: "sameWidth",
        enabled: true,
        fn: ({ state, instance: instance16 }) => {
          const targetWidth = `${state.rects.reference.width}px`;
          if (state.styles.popper.width === targetWidth) {
            return;
          }
          state.styles.popper.width = targetWidth;
          instance16.update();
        },
        phase: "beforeWrite",
        requires: ["computeStyles"]
      }
    ]
  };
  let templateOptions = [];
  const setInputVal = (templateOption) => {
    $$invalidate(3, templateOptions = []);
    $$invalidate(0, initialValue = templateOption);
    onChange(templateOption);
  };
  const handleMouseOver = (e) => {
    if (e && e.target) {
      const target = e.target;
      target.addClass("is-selected");
    }
  };
  const handleMouseOut = (e) => {
    if (e && e.target) {
      const target = e.target;
      target.removeClass("is-selected");
    }
  };
  const filterFiles = () => {
    let storageArr = [];
    dataProvider().forEach((file) => {
      if (initialValue) {
        if (file.path.toLowerCase().startsWith(initialValue.toLowerCase())) {
          storageArr = [...storageArr, file.path];
        }
      } else {
        storageArr = [...storageArr, file.path];
      }
    });
    $$invalidate(3, templateOptions = storageArr);
  };
  function keydown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler() {
    initialValue = this.value;
    $$invalidate(0, initialValue);
  }
  const click_handler = () => setInputVal("");
  const click_handler_1 = (templateOption) => setInputVal(templateOption);
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(1, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("initialValue" in $$props2)
      $$invalidate(0, initialValue = $$props2.initialValue);
    if ("onChange" in $$props2)
      $$invalidate(11, onChange = $$props2.onChange);
    if ("dataProvider" in $$props2)
      $$invalidate(12, dataProvider = $$props2.dataProvider);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        if (!initialValue) {
          $$invalidate(3, templateOptions = []);
        }
    }
  };
  return [
    initialValue,
    name,
    description,
    templateOptions,
    popperRef,
    popperContent,
    extraOpts,
    setInputVal,
    handleMouseOver,
    handleMouseOut,
    filterFiles,
    onChange,
    dataProvider,
    keydown_handler_1,
    focus_handler_1,
    blur_handler_1,
    keydown_handler,
    focus_handler,
    blur_handler,
    input_input_handler,
    click_handler,
    click_handler_1
  ];
}
var TemplateSuggest = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      name: 1,
      description: 2,
      initialValue: 0,
      onChange: 11,
      dataProvider: 12
    }, add_css);
  }
};
var TemplateSuggest_default = TemplateSuggest;

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start2 = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn2) {
    set(fn2(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/settings/settingsstore.ts
var settings;
function init2(plugin) {
  if (settings) {
    return;
  }
  const { subscribe: subscribe2, set, update: update2 } = writable(plugin.settings);
  settings = {
    subscribe: subscribe2,
    update: update2,
    set: (value) => {
      set(value);
      plugin.saveSettings();
    }
  };
}

// src/settings/DailySettingsGroup.svelte
function create_if_block2(ctx) {
  let div15;
  let div4;
  let div2;
  let t3;
  let div3;
  let input;
  let t4;
  let div9;
  let div7;
  let t8;
  let div8;
  let select0;
  let option0;
  let option1;
  let t11;
  let div14;
  let div12;
  let t15;
  let div13;
  let select1;
  let option2;
  let option2_value_value;
  let option3;
  let option3_value_value;
  let t18;
  let suggest;
  let div15_intro;
  let div15_outro;
  let current;
  let mounted;
  let dispose;
  suggest = new TemplateSuggest_default({
    props: {
      name: "Clipped Entry Template - Daily",
      description: "Choose the template to use as for the clipped entry in the daily \n			periodic note",
      initialValue: ctx[1].dailyEntryTemplateLocation,
      dataProvider: ctx[7],
      onChange: ctx[2]
    }
  });
  return {
    c() {
      div15 = element("div");
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name">Daily Note Header</div> 
					<div class="setting-item-description">What header should highlight data be prepended/appended under in the
						daily note?</div>`;
      t3 = space();
      div3 = element("div");
      input = element("input");
      t4 = space();
      div9 = element("div");
      div7 = element("div");
      div7.innerHTML = `<div class="setting-item-name">Daily Note Position</div> 
					<div class="setting-item-description">Prepend clippings to the top of the section or append them to the
						bottom of the section?</div>`;
      t8 = space();
      div8 = element("div");
      select0 = element("select");
      option0 = element("option");
      option0.textContent = "prepend";
      option1 = element("option");
      option1.textContent = "append";
      t11 = space();
      div14 = element("div");
      div12 = element("div");
      div12.innerHTML = `<div class="setting-item-name">Open Note After Adding Clipping?</div> 
					<div class="setting-item-description">Open the daily note after adding the clipping?</div>`;
      t15 = space();
      div13 = element("div");
      select1 = element("select");
      option2 = element("option");
      option2.textContent = "Yes";
      option3 = element("option");
      option3.textContent = "No";
      t18 = space();
      create_component(suggest.$$.fragment);
      attr(div2, "class", "setting-item-info");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
      attr(div7, "class", "setting-item-info");
      option0.__value = "prepend";
      option0.value = option0.__value;
      option1.__value = "append";
      option1.value = option1.__value;
      attr(select0, "class", "dropdown");
      if (ctx[1].dailyPosition === void 0)
        add_render_callback(() => ctx[5].call(select0));
      attr(div8, "class", "setting-item-control");
      attr(div9, "class", "setting-item");
      attr(div12, "class", "setting-item-info");
      option2.__value = option2_value_value = true;
      option2.value = option2.__value;
      option3.__value = option3_value_value = false;
      option3.value = option3.__value;
      attr(select1, "class", "dropdown");
      if (ctx[1].dailyOpenOnWrite === void 0)
        add_render_callback(() => ctx[6].call(select1));
      attr(div13, "class", "setting-item-control");
      attr(div14, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div15, anchor);
      append(div15, div4);
      append(div4, div2);
      append(div4, t3);
      append(div4, div3);
      append(div3, input);
      set_input_value(input, ctx[1].dailyNoteHeading);
      append(div15, t4);
      append(div15, div9);
      append(div9, div7);
      append(div9, t8);
      append(div9, div8);
      append(div8, select0);
      append(select0, option0);
      append(select0, option1);
      select_option(select0, ctx[1].dailyPosition);
      append(div15, t11);
      append(div15, div14);
      append(div14, div12);
      append(div14, t15);
      append(div14, div13);
      append(div13, select1);
      append(select1, option2);
      append(select1, option3);
      select_option(select1, ctx[1].dailyOpenOnWrite);
      append(div15, t18);
      mount_component(suggest, div15, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[4]),
          listen(select0, "change", ctx[5]),
          listen(select1, "change", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1].dailyNoteHeading) {
        set_input_value(input, ctx2[1].dailyNoteHeading);
      }
      if (dirty & 2) {
        select_option(select0, ctx2[1].dailyPosition);
      }
      if (dirty & 2) {
        select_option(select1, ctx2[1].dailyOpenOnWrite);
      }
      const suggest_changes = {};
      if (dirty & 2)
        suggest_changes.initialValue = ctx2[1].dailyEntryTemplateLocation;
      if (dirty & 1)
        suggest_changes.dataProvider = ctx2[7];
      suggest.$set(suggest_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(suggest.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (div15_outro)
            div15_outro.end(1);
          div15_intro = create_in_transition(div15, slide, { duration: 300 });
          div15_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(suggest.$$.fragment, local);
      if (div15_intro)
        div15_intro.invalidate();
      if (local) {
        div15_outro = create_out_transition(div15, slide, { duration: 300 });
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div15);
      destroy_component(suggest);
      if (detaching && div15_outro)
        div15_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment2(ctx) {
  let div3;
  let div2;
  let div0;
  let t1;
  let div1;
  let label;
  let input;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1].useDailyNote && create_if_block2(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h1 class="setting-item-name">Daily Note Entry</h1>`;
      t1 = space();
      div1 = element("div");
      label = element("label");
      input = element("input");
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "setting-item-info");
      attr(input, "type", "checkbox");
      attr(label, "class", "checkbox-container");
      toggle_class(label, "is-enabled", ctx[1].useDailyNote);
      attr(div1, "class", "setting-item-control");
      attr(div2, "class", "setting-item mod-toggle");
      attr(div3, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, label);
      append(label, input);
      input.checked = ctx[1].useDailyNote;
      append(div3, t2);
      if (if_block)
        if_block.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        input.checked = ctx2[1].useDailyNote;
      }
      if (!current || dirty & 2) {
        toggle_class(label, "is-enabled", ctx2[1].useDailyNote);
      }
      if (ctx2[1].useDailyNote) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let $settings;
  component_subscribe($$self, settings, ($$value) => $$invalidate(1, $settings = $$value));
  let { app } = $$props;
  const onChange = (entry) => {
    set_store_value(settings, $settings.dailyEntryTemplateLocation = entry, $settings);
  };
  function input_change_handler() {
    $settings.useDailyNote = this.checked;
    settings.set($settings);
  }
  function input_input_handler() {
    $settings.dailyNoteHeading = this.value;
    settings.set($settings);
  }
  function select0_change_handler() {
    $settings.dailyPosition = select_value(this);
    settings.set($settings);
  }
  function select1_change_handler() {
    $settings.dailyOpenOnWrite = select_value(this);
    settings.set($settings);
  }
  const func = () => app.vault.getMarkdownFiles();
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [
    app,
    $settings,
    onChange,
    input_change_handler,
    input_input_handler,
    select0_change_handler,
    select1_change_handler,
    func
  ];
}
var DailySettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { app: 0 });
  }
};
var DailySettingsGroup_default = DailySettingsGroup;

// src/settings/WeeklySettingsGroup.svelte
function create_if_block3(ctx) {
  let div15;
  let div4;
  let div2;
  let t3;
  let div3;
  let input;
  let t4;
  let div9;
  let div7;
  let t8;
  let div8;
  let select0;
  let option0;
  let option1;
  let t11;
  let div14;
  let div12;
  let t15;
  let div13;
  let select1;
  let option2;
  let option2_value_value;
  let option3;
  let option3_value_value;
  let t18;
  let suggest;
  let div15_intro;
  let div15_outro;
  let current;
  let mounted;
  let dispose;
  suggest = new TemplateSuggest_default({
    props: {
      name: "Clipped Entry Template - Weekly",
      description: "Choose the template to use as for the clipped entry in the weekly\n			periodic note",
      initialValue: ctx[1].weeklyEntryTemplateLocation,
      dataProvider: ctx[7],
      onChange: ctx[2]
    }
  });
  return {
    c() {
      div15 = element("div");
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name">Weekly Note Header</div> 
					<div class="setting-item-description">What header should highlight data be prepended/appended under in the
						weekly note?</div>`;
      t3 = space();
      div3 = element("div");
      input = element("input");
      t4 = space();
      div9 = element("div");
      div7 = element("div");
      div7.innerHTML = `<div class="setting-item-name">Weekly Note Position</div> 
					<div class="setting-item-description">Prepend clippings to the top of the section or append them to the
						bottom of the section?</div>`;
      t8 = space();
      div8 = element("div");
      select0 = element("select");
      option0 = element("option");
      option0.textContent = "prepend";
      option1 = element("option");
      option1.textContent = "append";
      t11 = space();
      div14 = element("div");
      div12 = element("div");
      div12.innerHTML = `<div class="setting-item-name">Open Note After Adding Clipping?</div> 
					<div class="setting-item-description">Open the weekly note after adding the clipping?</div>`;
      t15 = space();
      div13 = element("div");
      select1 = element("select");
      option2 = element("option");
      option2.textContent = "Yes";
      option3 = element("option");
      option3.textContent = "No";
      t18 = space();
      create_component(suggest.$$.fragment);
      attr(div2, "class", "setting-item-info");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
      attr(div7, "class", "setting-item-info");
      option0.__value = "prepend";
      option0.value = option0.__value;
      option1.__value = "append";
      option1.value = option1.__value;
      attr(select0, "class", "dropdown");
      if (ctx[1].weeklyPosition === void 0)
        add_render_callback(() => ctx[5].call(select0));
      attr(div8, "class", "setting-item-control");
      attr(div9, "class", "setting-item");
      attr(div12, "class", "setting-item-info");
      option2.__value = option2_value_value = true;
      option2.value = option2.__value;
      option3.__value = option3_value_value = false;
      option3.value = option3.__value;
      attr(select1, "class", "dropdown");
      if (ctx[1].weeklyOpenOnWrite === void 0)
        add_render_callback(() => ctx[6].call(select1));
      attr(div13, "class", "setting-item-control");
      attr(div14, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div15, anchor);
      append(div15, div4);
      append(div4, div2);
      append(div4, t3);
      append(div4, div3);
      append(div3, input);
      set_input_value(input, ctx[1].weeklyNoteHeading);
      append(div15, t4);
      append(div15, div9);
      append(div9, div7);
      append(div9, t8);
      append(div9, div8);
      append(div8, select0);
      append(select0, option0);
      append(select0, option1);
      select_option(select0, ctx[1].weeklyPosition);
      append(div15, t11);
      append(div15, div14);
      append(div14, div12);
      append(div14, t15);
      append(div14, div13);
      append(div13, select1);
      append(select1, option2);
      append(select1, option3);
      select_option(select1, ctx[1].weeklyOpenOnWrite);
      append(div15, t18);
      mount_component(suggest, div15, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[4]),
          listen(select0, "change", ctx[5]),
          listen(select1, "change", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1].weeklyNoteHeading) {
        set_input_value(input, ctx2[1].weeklyNoteHeading);
      }
      if (dirty & 2) {
        select_option(select0, ctx2[1].weeklyPosition);
      }
      if (dirty & 2) {
        select_option(select1, ctx2[1].weeklyOpenOnWrite);
      }
      const suggest_changes = {};
      if (dirty & 2)
        suggest_changes.initialValue = ctx2[1].weeklyEntryTemplateLocation;
      if (dirty & 1)
        suggest_changes.dataProvider = ctx2[7];
      suggest.$set(suggest_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(suggest.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (div15_outro)
            div15_outro.end(1);
          div15_intro = create_in_transition(div15, slide, { duration: 300 });
          div15_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(suggest.$$.fragment, local);
      if (div15_intro)
        div15_intro.invalidate();
      if (local) {
        div15_outro = create_out_transition(div15, slide, { duration: 300 });
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div15);
      destroy_component(suggest);
      if (detaching && div15_outro)
        div15_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment3(ctx) {
  let div3;
  let div2;
  let div0;
  let t1;
  let div1;
  let label;
  let input;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1].useWeeklyNote && create_if_block3(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h1 class="setting-item-name">Weekly Note Entry</h1>`;
      t1 = space();
      div1 = element("div");
      label = element("label");
      input = element("input");
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "setting-item-info");
      attr(input, "type", "checkbox");
      attr(label, "class", "checkbox-container");
      toggle_class(label, "is-enabled", ctx[1].useWeeklyNote);
      attr(div1, "class", "setting-item-control");
      attr(div2, "class", "setting-item mod-toggle");
      attr(div3, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, label);
      append(label, input);
      input.checked = ctx[1].useWeeklyNote;
      append(div3, t2);
      if (if_block)
        if_block.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        input.checked = ctx2[1].useWeeklyNote;
      }
      if (!current || dirty & 2) {
        toggle_class(label, "is-enabled", ctx2[1].useWeeklyNote);
      }
      if (ctx2[1].useWeeklyNote) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let $settings;
  component_subscribe($$self, settings, ($$value) => $$invalidate(1, $settings = $$value));
  let { app } = $$props;
  const onChange = (entry) => set_store_value(settings, $settings.weeklyEntryTemplateLocation = entry, $settings);
  function input_change_handler() {
    $settings.useWeeklyNote = this.checked;
    settings.set($settings);
  }
  function input_input_handler() {
    $settings.weeklyNoteHeading = this.value;
    settings.set($settings);
  }
  function select0_change_handler() {
    $settings.weeklyPosition = select_value(this);
    settings.set($settings);
  }
  function select1_change_handler() {
    $settings.weeklyOpenOnWrite = select_value(this);
    settings.set($settings);
  }
  const func = () => app.vault.getMarkdownFiles();
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [
    app,
    $settings,
    onChange,
    input_change_handler,
    input_input_handler,
    select0_change_handler,
    select1_change_handler,
    func
  ];
}
var WeeklySettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { app: 0 });
  }
};
var WeeklySettingsGroup_default = WeeklySettingsGroup;

// src/settings/CommonSettingsGroup.svelte
function create_fragment4(ctx) {
  let div17;
  let h1;
  let t1;
  let div4;
  let div2;
  let t5;
  let div3;
  let input0;
  let t6;
  let div10;
  let div8;
  let t12;
  let div9;
  let input1;
  let t13;
  let div16;
  let div14;
  let t19;
  let div15;
  let input2;
  let mounted;
  let dispose;
  return {
    c() {
      div17 = element("div");
      h1 = element("h1");
      h1.textContent = "Common Settings";
      t1 = space();
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name">Tags</div> 
			<div class="setting-item-description">Tags to add to captured highlights?</div>`;
      t5 = space();
      div3 = element("div");
      input0 = element("input");
      t6 = space();
      div10 = element("div");
      div8 = element("div");
      div8.innerHTML = `<div class="setting-item-name">Time Format</div> 
			<div class="setting-item-description"><div>Format to use for the {{ time }} template in
					clippings. See</div> 
				<a href="https://momentjs.com/docs/#/displaying/format/">format reference</a></div>`;
      t12 = space();
      div9 = element("div");
      input1 = element("input");
      t13 = space();
      div16 = element("div");
      div14 = element("div");
      div14.innerHTML = `<div class="setting-item-name">Date Format</div> 
			<div class="setting-item-description"><div>Format to use for the {{ date }} template in
					clippings. See</div> 
				<a href="https://momentjs.com/docs/#/displaying/format/">format reference</a></div>`;
      t19 = space();
      div15 = element("div");
      input2 = element("input");
      attr(div2, "class", "setting-item-info");
      attr(input0, "type", "text");
      attr(input0, "spellcheck", "false");
      attr(input0, "placeholder", "tags,seperated,by,commas");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
      attr(div8, "class", "setting-item-info");
      attr(input1, "type", "text");
      attr(input1, "spellcheck", "false");
      attr(input1, "placeholder", "HH:mm");
      attr(div9, "class", "setting-item-control");
      attr(div10, "class", "setting-item");
      attr(div14, "class", "setting-item-info");
      attr(input2, "type", "text");
      attr(input2, "spellcheck", "false");
      attr(input2, "placeholder", "MM/DD/YY");
      attr(div15, "class", "setting-item-control");
      attr(div16, "class", "setting-item");
      attr(div17, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div17, anchor);
      append(div17, h1);
      append(div17, t1);
      append(div17, div4);
      append(div4, div2);
      append(div4, t5);
      append(div4, div3);
      append(div3, input0);
      set_input_value(input0, ctx[0].tags);
      append(div17, t6);
      append(div17, div10);
      append(div10, div8);
      append(div10, t12);
      append(div10, div9);
      append(div9, input1);
      set_input_value(input1, ctx[0].timestampFormat);
      append(div17, t13);
      append(div17, div16);
      append(div16, div14);
      append(div16, t19);
      append(div16, div15);
      append(div15, input2);
      set_input_value(input2, ctx[0].dateFormat);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[1]),
          listen(input1, "input", ctx[2]),
          listen(input2, "input", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input0.value !== ctx2[0].tags) {
        set_input_value(input0, ctx2[0].tags);
      }
      if (dirty & 1 && input1.value !== ctx2[0].timestampFormat) {
        set_input_value(input1, ctx2[0].timestampFormat);
      }
      if (dirty & 1 && input2.value !== ctx2[0].dateFormat) {
        set_input_value(input2, ctx2[0].dateFormat);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div17);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let $settings;
  component_subscribe($$self, settings, ($$value) => $$invalidate(0, $settings = $$value));
  function input0_input_handler() {
    $settings.tags = this.value;
    settings.set($settings);
  }
  function input1_input_handler() {
    $settings.timestampFormat = this.value;
    settings.set($settings);
  }
  function input2_input_handler() {
    $settings.dateFormat = this.value;
    settings.set($settings);
  }
  return [$settings, input0_input_handler, input1_input_handler, input2_input_handler];
}
var CommonSettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
  }
};
var CommonSettingsGroup_default = CommonSettingsGroup;

// src/settings/BaseSettingsTab.svelte
function create_fragment5(ctx) {
  let dailysettingsgroup;
  let t0;
  let weeklysettingsgroup;
  let t1;
  let commonsettingsgroup;
  let current;
  dailysettingsgroup = new DailySettingsGroup_default({ props: { app: ctx[0] } });
  weeklysettingsgroup = new WeeklySettingsGroup_default({ props: { app: ctx[0] } });
  commonsettingsgroup = new CommonSettingsGroup_default({});
  return {
    c() {
      create_component(dailysettingsgroup.$$.fragment);
      t0 = space();
      create_component(weeklysettingsgroup.$$.fragment);
      t1 = space();
      create_component(commonsettingsgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dailysettingsgroup, target, anchor);
      insert(target, t0, anchor);
      mount_component(weeklysettingsgroup, target, anchor);
      insert(target, t1, anchor);
      mount_component(commonsettingsgroup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const dailysettingsgroup_changes = {};
      if (dirty & 1)
        dailysettingsgroup_changes.app = ctx2[0];
      dailysettingsgroup.$set(dailysettingsgroup_changes);
      const weeklysettingsgroup_changes = {};
      if (dirty & 1)
        weeklysettingsgroup_changes.app = ctx2[0];
      weeklysettingsgroup.$set(weeklysettingsgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dailysettingsgroup.$$.fragment, local);
      transition_in(weeklysettingsgroup.$$.fragment, local);
      transition_in(commonsettingsgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dailysettingsgroup.$$.fragment, local);
      transition_out(weeklysettingsgroup.$$.fragment, local);
      transition_out(commonsettingsgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dailysettingsgroup, detaching);
      if (detaching)
        detach(t0);
      destroy_component(weeklysettingsgroup, detaching);
      if (detaching)
        detach(t1);
      destroy_component(commonsettingsgroup, detaching);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { app } = $$props;
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app];
}
var BaseSettingsTab = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { app: 0 });
  }
};
var BaseSettingsTab_default = BaseSettingsTab;

// src/settings/Tabs.svelte
function add_css2(target) {
  append_styles(target, "svelte-126qfyk", ".obs_clp_box.svelte-126qfyk.svelte-126qfyk{margin-bottom:10px;padding:40px;border:1px solid var(--tab-divider-color);border-radius:0 0 0.5rem 0.5rem;border-top:0}ul.svelte-126qfyk.svelte-126qfyk{display:flex;flex-wrap:wrap;padding-left:0;margin-bottom:0;list-style:none;border-bottom:1px solid var(--tab-divider-color)}span.svelte-126qfyk.svelte-126qfyk{border:1px solid var(--tab-divider-color);border-top-left-radius:0.25rem;border-top-right-radius:0.25rem;display:block;padding:0.5rem 1rem;cursor:pointer;color:var(--tab-text-color)}span.svelte-126qfyk.svelte-126qfyk:hover{border-color:#e9ecef #e9ecef #dee2e6;background-color:var(--background-modifier-hover);color:var(--tab-text-color-active)}li.svelte-126qfyk.svelte-126qfyk:hover{background-color:var(--background-modifier-hover)}li.active.svelte-126qfyk>span.svelte-126qfyk{background-color:var(--tab-background-active);border-color:#e9ecef #e9ecef #dee2e6;color:var(--tab-text-color-active)}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let li;
  let span;
  let t0_value = ctx[5].label + "";
  let t0;
  let t1;
  let li_class_value;
  let mounted;
  let dispose;
  function keypress_handler() {
    return ctx[3](ctx[5]);
  }
  function click_handler() {
    return ctx[4](ctx[5]);
  }
  return {
    c() {
      li = element("li");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      attr(span, "class", "svelte-126qfyk");
      attr(li, "class", li_class_value = null_to_empty(ctx[0] === ctx[5].value ? "active" : "") + " svelte-126qfyk");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span);
      append(span, t0);
      append(li, t1);
      if (!mounted) {
        dispose = [
          listen(span, "keypress", keypress_handler),
          listen(span, "click", click_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t0_value !== (t0_value = ctx[5].label + ""))
        set_data(t0, t0_value);
      if (dirty & 3 && li_class_value !== (li_class_value = null_to_empty(ctx[0] === ctx[5].value ? "active" : "") + " svelte-126qfyk")) {
        attr(li, "class", li_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block4(ctx) {
  let div;
  let switch_instance;
  let t;
  let current;
  const switch_instance_spread_levels = [ctx[5].props];
  var switch_value = ctx[5].component;
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      attr(div, "class", "obs_clp_box svelte-126qfyk");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & 2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[5].props)]) : {};
      if (switch_value !== (switch_value = ctx2[5].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_each_block2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] == ctx[5].value && create_if_block4(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0] == ctx2[5].value) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment6(ctx) {
  let div1;
  let div0;
  let ul;
  let t;
  let current;
  let each_value_1 = ctx[1];
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(ul, "class", "svelte-126qfyk");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, ul);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(ul, null);
      }
      append(div1, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value_1 = ctx2[1];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(ul, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & 3) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { tabs } = $$props;
  let { activeTabValue = 1 } = $$props;
  const handleClick = (tabValue) => $$invalidate(0, activeTabValue = tabValue);
  const keypress_handler = (tab) => handleClick(tab.value);
  const click_handler = (tab) => handleClick(tab.value);
  $$self.$$set = ($$props2) => {
    if ("tabs" in $$props2)
      $$invalidate(1, tabs = $$props2.tabs);
    if ("activeTabValue" in $$props2)
      $$invalidate(0, activeTabValue = $$props2.activeTabValue);
  };
  return [activeTabValue, tabs, handleClick, keypress_handler, click_handler];
}
var Tabs = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { tabs: 1, activeTabValue: 0 }, add_css2);
  }
};
var Tabs_default = Tabs;

// src/settings/Notice.svelte
var get_calloutLink_slot_changes = (dirty) => ({});
var get_calloutLink_slot_context = (ctx) => ({});
var get_noticeText_slot_changes = (dirty) => ({});
var get_noticeText_slot_context = (ctx) => ({});
function fallback_block(ctx) {
  let span;
  return {
    c() {
      span = element("span");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment7(ctx) {
  let div3;
  let div2;
  let div0;
  let t0;
  let div1;
  let p0;
  let t1;
  let p1;
  let current;
  const noticeText_slot_template = ctx[1].noticeText;
  const noticeText_slot = create_slot(noticeText_slot_template, ctx, ctx[0], get_noticeText_slot_context);
  const noticeText_slot_or_fallback = noticeText_slot || fallback_block(ctx);
  const calloutLink_slot_template = ctx[1].calloutLink;
  const calloutLink_slot = create_slot(calloutLink_slot_template, ctx, ctx[0], get_calloutLink_slot_context);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<svg class="h-5 w-5 text-blue-400" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z" clip-rule="evenodd"></path></svg>`;
      t0 = space();
      div1 = element("div");
      p0 = element("p");
      if (noticeText_slot_or_fallback)
        noticeText_slot_or_fallback.c();
      t1 = space();
      p1 = element("p");
      if (calloutLink_slot)
        calloutLink_slot.c();
      attr(div0, "class", "flex-shrink-0");
      attr(p0, "class", "text-sm text-blue-700");
      attr(p1, "class", "mt-3 text-sm md:mt-0 md:ml-6");
      attr(div1, "class", "ml-3 flex-1 md:flex md:justify-between");
      attr(div2, "class", "flex");
      attr(div3, "class", "rounded-md bg-blue-50 p-4");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t0);
      append(div2, div1);
      append(div1, p0);
      if (noticeText_slot_or_fallback) {
        noticeText_slot_or_fallback.m(p0, null);
      }
      append(div1, t1);
      append(div1, p1);
      if (calloutLink_slot) {
        calloutLink_slot.m(p1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (noticeText_slot) {
        if (noticeText_slot.p && (!current || dirty & 1)) {
          update_slot_base(noticeText_slot, noticeText_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(noticeText_slot_template, ctx2[0], dirty, get_noticeText_slot_changes), get_noticeText_slot_context);
        }
      }
      if (calloutLink_slot) {
        if (calloutLink_slot.p && (!current || dirty & 1)) {
          update_slot_base(calloutLink_slot, calloutLink_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(calloutLink_slot_template, ctx2[0], dirty, get_calloutLink_slot_changes), get_calloutLink_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(noticeText_slot_or_fallback, local);
      transition_in(calloutLink_slot, local);
      current = true;
    },
    o(local) {
      transition_out(noticeText_slot_or_fallback, local);
      transition_out(calloutLink_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (noticeText_slot_or_fallback)
        noticeText_slot_or_fallback.d(detaching);
      if (calloutLink_slot)
        calloutLink_slot.d(detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Notice5 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
  }
};
var Notice_default = Notice5;

// src/settings/TopicSettingsGroup.svelte
function create_fragment8(ctx) {
  let div10;
  let div4;
  let div2;
  let t3;
  let div3;
  let select0;
  let option0;
  let option1;
  let t6;
  let div9;
  let div7;
  let t10;
  let div8;
  let select1;
  let option2;
  let option2_value_value;
  let option3;
  let option3_value_value;
  let t13;
  let suggest;
  let current;
  let mounted;
  let dispose;
  suggest = new TemplateSuggest_default({
    props: {
      name: "Clipped Entry Template",
      description: "Choose the template to use for the clipped entry in a topic note",
      initialValue: ctx[1].topicEntryTemplateLocation,
      dataProvider: ctx[5],
      onChange: ctx[2]
    }
  });
  return {
    c() {
      div10 = element("div");
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name">Topic Note Position</div> 
			<div class="setting-item-description">Prepend clippings or append them to the bottom?</div>`;
      t3 = space();
      div3 = element("div");
      select0 = element("select");
      option0 = element("option");
      option0.textContent = "prepend";
      option1 = element("option");
      option1.textContent = "append";
      t6 = space();
      div9 = element("div");
      div7 = element("div");
      div7.innerHTML = `<div class="setting-item-name">Open Note After Adding Clipping?</div> 
			<div class="setting-item-description">Open the note after adding the clipping?</div>`;
      t10 = space();
      div8 = element("div");
      select1 = element("select");
      option2 = element("option");
      option2.textContent = "Yes";
      option3 = element("option");
      option3.textContent = "No";
      t13 = space();
      create_component(suggest.$$.fragment);
      attr(div2, "class", "setting-item-info");
      option0.__value = "prepend";
      option0.value = option0.__value;
      option1.__value = "append";
      option1.value = option1.__value;
      attr(select0, "class", "dropdown");
      if (ctx[1].topicPosition === void 0)
        add_render_callback(() => ctx[3].call(select0));
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
      attr(div7, "class", "setting-item-info");
      option2.__value = option2_value_value = true;
      option2.value = option2.__value;
      option3.__value = option3_value_value = false;
      option3.value = option3.__value;
      attr(select1, "class", "dropdown");
      if (ctx[1].topicOpenOnWrite === void 0)
        add_render_callback(() => ctx[4].call(select1));
      attr(div8, "class", "setting-item-control");
      attr(div9, "class", "setting-item");
      attr(div10, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div10, anchor);
      append(div10, div4);
      append(div4, div2);
      append(div4, t3);
      append(div4, div3);
      append(div3, select0);
      append(select0, option0);
      append(select0, option1);
      select_option(select0, ctx[1].topicPosition);
      append(div10, t6);
      append(div10, div9);
      append(div9, div7);
      append(div9, t10);
      append(div9, div8);
      append(div8, select1);
      append(select1, option2);
      append(select1, option3);
      select_option(select1, ctx[1].topicOpenOnWrite);
      append(div10, t13);
      mount_component(suggest, div10, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(select0, "change", ctx[3]),
          listen(select1, "change", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        select_option(select0, ctx2[1].topicPosition);
      }
      if (dirty & 2) {
        select_option(select1, ctx2[1].topicOpenOnWrite);
      }
      const suggest_changes = {};
      if (dirty & 2)
        suggest_changes.initialValue = ctx2[1].topicEntryTemplateLocation;
      if (dirty & 1)
        suggest_changes.dataProvider = ctx2[5];
      suggest.$set(suggest_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(suggest.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggest.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div10);
      destroy_component(suggest);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let $settings;
  component_subscribe($$self, settings, ($$value) => $$invalidate(1, $settings = $$value));
  let { app } = $$props;
  const onChange = (entry) => {
    set_store_value(settings, $settings.topicEntryTemplateLocation = entry, $settings);
  };
  function select0_change_handler() {
    $settings.topicPosition = select_value(this);
    settings.set($settings);
  }
  function select1_change_handler() {
    $settings.topicOpenOnWrite = select_value(this);
    settings.set($settings);
  }
  const func = () => app.vault.getMarkdownFiles();
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app, $settings, onChange, select0_change_handler, select1_change_handler, func];
}
var TopicSettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, { app: 0 });
  }
};
var TopicSettingsGroup_default = TopicSettingsGroup;

// src/settings/TopicSettingsTab.svelte
function create_fragment9(ctx) {
  let topicsettingsgroup;
  let current;
  topicsettingsgroup = new TopicSettingsGroup_default({ props: { app: ctx[0] } });
  return {
    c() {
      create_component(topicsettingsgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topicsettingsgroup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const topicsettingsgroup_changes = {};
      if (dirty & 1)
        topicsettingsgroup_changes.app = ctx2[0];
      topicsettingsgroup.$set(topicsettingsgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topicsettingsgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topicsettingsgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topicsettingsgroup, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { app } = $$props;
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
  };
  return [app];
}
var TopicSettingsTab = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, { app: 0 });
  }
};
var TopicSettingsTab_default = TopicSettingsTab;

// src/utils/fileutils.ts
function getFileName(filePath) {
  const lastSlashIndex = filePath.lastIndexOf("/");
  let fileName = filePath;
  if (lastSlashIndex !== -1) {
    fileName = filePath.substring(lastSlashIndex + 1);
  }
  return fileName;
}

// src/bookmarkletlink/bookmarkletgenerator.ts
var BookmarketlGenerator = class {
  constructor(vaultName, notePath = "", markdownSettings, captureComments) {
    this.vaultName = vaultName;
    this.notePath = notePath;
    this.markdownSettings = markdownSettings;
    this.captureComments = captureComments;
  }
  generateBookmarklet() {
    return `javascript:(function()%7B(()%3D%3E%7B%22use%20strict%22%3Bvar%20e%2Cn%2Ct%3D%7B36%3A(e%2Cn%2Ct)%3D%3E%7Bfunction%20r(e%2Cn)%7Breturn%20Array(n%2B1).join(e)%7Dt.r(n)%2Ct.d(n%2C%7Bdefault%3A()%3D%3EL%7D)%3Bvar%20i%3D%5B%22ADDRESS%22%2C%22ARTICLE%22%2C%22ASIDE%22%2C%22AUDIO%22%2C%22BLOCKQUOTE%22%2C%22BODY%22%2C%22CANVAS%22%2C%22CENTER%22%2C%22DD%22%2C%22DIR%22%2C%22DIV%22%2C%22DL%22%2C%22DT%22%2C%22FIELDSET%22%2C%22FIGCAPTION%22%2C%22FIGURE%22%2C%22FOOTER%22%2C%22FORM%22%2C%22FRAMESET%22%2C%22H1%22%2C%22H2%22%2C%22H3%22%2C%22H4%22%2C%22H5%22%2C%22H6%22%2C%22HEADER%22%2C%22HGROUP%22%2C%22HR%22%2C%22HTML%22%2C%22ISINDEX%22%2C%22LI%22%2C%22MAIN%22%2C%22MENU%22%2C%22NAV%22%2C%22NOFRAMES%22%2C%22NOSCRIPT%22%2C%22OL%22%2C%22OUTPUT%22%2C%22P%22%2C%22PRE%22%2C%22SECTION%22%2C%22TABLE%22%2C%22TBODY%22%2C%22TD%22%2C%22TFOOT%22%2C%22TH%22%2C%22THEAD%22%2C%22TR%22%2C%22UL%22%5D%3Bfunction%20o(e)%7Breturn%20c(e%2Ci)%7Dvar%20a%3D%5B%22AREA%22%2C%22BASE%22%2C%22BR%22%2C%22COL%22%2C%22COMMAND%22%2C%22EMBED%22%2C%22HR%22%2C%22IMG%22%2C%22INPUT%22%2C%22KEYGEN%22%2C%22LINK%22%2C%22META%22%2C%22PARAM%22%2C%22SOURCE%22%2C%22TRACK%22%2C%22WBR%22%5D%3Bfunction%20l(e)%7Breturn%20c(e%2Ca)%7Dvar%20d%3D%5B%22A%22%2C%22TABLE%22%2C%22THEAD%22%2C%22TBODY%22%2C%22TFOOT%22%2C%22TH%22%2C%22TD%22%2C%22IFRAME%22%2C%22SCRIPT%22%2C%22AUDIO%22%2C%22VIDEO%22%5D%3Bfunction%20c(e%2Cn)%7Breturn%20n.indexOf(e.nodeName)%3E%3D0%7Dfunction%20u(e%2Cn)%7Breturn%20e.getElementsByTagName%26%26n.some((function(n)%7Breturn%20e.getElementsByTagName(n).length%7D))%7Dvar%20s%3D%7B%7D%3Bfunction%20p(e)%7Breturn%20e%3Fe.replace(%2F(%5Cn%2B%5Cs*)%2B%2Fg%2C%22%5Cn%22)%3A%22%22%7Dfunction%20f(e)%7Bfor(var%20n%20in%20this.options%3De%2Cthis._keep%3D%5B%5D%2Cthis._remove%3D%5B%5D%2Cthis.blankRule%3D%7Breplacement%3Ae.blankReplacement%7D%2Cthis.keepReplacement%3De.keepReplacement%2Cthis.defaultRule%3D%7Breplacement%3Ae.defaultReplacement%7D%2Cthis.array%3D%5B%5D%2Ce.rules)this.array.push(e.rules%5Bn%5D)%7Dfunction%20m(e%2Cn%2Ct)%7Bfor(var%20r%3D0%3Br%3Ce.length%3Br%2B%2B)%7Bvar%20i%3De%5Br%5D%3Bif(h(i%2Cn%2Ct))return%20i%7D%7Dfunction%20h(e%2Cn%2Ct)%7Bvar%20r%3De.filter%3Bif(%22string%22%3D%3Dtypeof%20r)%7Bif(r%3D%3D%3Dn.nodeName.toLowerCase())return!0%7Delse%20if(Array.isArray(r))%7Bif(r.indexOf(n.nodeName.toLowerCase())%3E-1)return!0%7Delse%7Bif(%22function%22!%3Dtypeof%20r)throw%20new%20TypeError(%22%60filter%60%20needs%20to%20be%20a%20string%2C%20array%2C%20or%20function%22)%3Bif(r.call(e%2Cn%2Ct))return!0%7D%7Dfunction%20g(e)%7Bvar%20n%3De.nextSibling%7C%7Ce.parentNode%3Breturn%20e.parentNode.removeChild(e)%2Cn%7Dfunction%20b(e%2Cn%2Ct)%7Breturn%20e%26%26e.parentNode%3D%3D%3Dn%7C%7Ct(n)%3Fn.nextSibling%7C%7Cn.parentNode%3An.firstChild%7C%7Cn.nextSibling%7C%7Cn.parentNode%7Ds.paragraph%3D%7Bfilter%3A%22p%22%2Creplacement%3Afunction(e)%7Breturn%22%5Cn%5Cn%22%2Be%2B%22%5Cn%5Cn%22%7D%7D%2Cs.lineBreak%3D%7Bfilter%3A%22br%22%2Creplacement%3Afunction(e%2Cn%2Ct)%7Breturn%20t.br%2B%22%5Cn%22%7D%7D%2Cs.heading%3D%7Bfilter%3A%5B%22h1%22%2C%22h2%22%2C%22h3%22%2C%22h4%22%2C%22h5%22%2C%22h6%22%5D%2Creplacement%3Afunction(e%2Cn%2Ct)%7Bvar%20i%3DNumber(n.nodeName.charAt(1))%3Breturn%22setext%22%3D%3D%3Dt.headingStyle%26%26i%3C3%3F%22%5Cn%5Cn%22%2Be%2B%22%5Cn%22%2Br(1%3D%3D%3Di%3F%22%3D%22%3A%22-%22%2Ce.length)%2B%22%5Cn%5Cn%22%3A%22%5Cn%5Cn%22%2Br(%22%23%22%2Ci)%2B%22%20%22%2Be%2B%22%5Cn%5Cn%22%7D%7D%2Cs.blockquote%3D%7Bfilter%3A%22blockquote%22%2Creplacement%3Afunction(e)%7Breturn%22%5Cn%5Cn%22%2B(e%3D(e%3De.replace(%2F%5E%5Cn%2B%7C%5Cn%2B%24%2Fg%2C%22%22)).replace(%2F%5E%2Fgm%2C%22%3E%20%22))%2B%22%5Cn%5Cn%22%7D%7D%2Cs.list%3D%7Bfilter%3A%5B%22ul%22%2C%22ol%22%5D%2Creplacement%3Afunction(e%2Cn)%7Bvar%20t%3Dn.parentNode%3Breturn%22LI%22%3D%3D%3Dt.nodeName%26%26t.lastElementChild%3D%3D%3Dn%3F%22%5Cn%22%2Be%3A%22%5Cn%5Cn%22%2Be%2B%22%5Cn%5Cn%22%7D%7D%2Cs.listItem%3D%7Bfilter%3A%22li%22%2Creplacement%3Afunction(e%2Cn%2Ct)%7Be%3De.replace(%2F%5E%5Cn%2B%2F%2C%22%22).replace(%2F%5Cn%2B%24%2F%2C%22%5Cn%22).replace(%2F%5Cn%2Fgm%2C%22%5Cn%20%20%20%20%22)%3Bvar%20r%3Dt.bulletListMarker%2B%22%20%20%20%22%2Ci%3Dn.parentNode%3Bif(%22OL%22%3D%3D%3Di.nodeName)%7Bvar%20o%3Di.getAttribute(%22start%22)%2Ca%3DArray.prototype.indexOf.call(i.children%2Cn)%3Br%3D(o%3FNumber(o)%2Ba%3Aa%2B1)%2B%22.%20%20%22%7Dreturn%20r%2Be%2B(n.nextSibling%26%26!%2F%5Cn%24%2F.test(e)%3F%22%5Cn%22%3A%22%22)%7D%7D%2Cs.indentedCodeBlock%3D%7Bfilter%3Afunction(e%2Cn)%7Breturn%22indented%22%3D%3D%3Dn.codeBlockStyle%26%26%22PRE%22%3D%3D%3De.nodeName%26%26e.firstChild%26%26%22CODE%22%3D%3D%3De.firstChild.nodeName%7D%2Creplacement%3Afunction(e%2Cn%2Ct)%7Breturn%22%5Cn%5Cn%20%20%20%20%22%2Bn.firstChild.textContent.replace(%2F%5Cn%2Fg%2C%22%5Cn%20%20%20%20%22)%2B%22%5Cn%5Cn%22%7D%7D%2Cs.fencedCodeBlock%3D%7Bfilter%3Afunction(e%2Cn)%7Breturn%22fenced%22%3D%3D%3Dn.codeBlockStyle%26%26%22PRE%22%3D%3D%3De.nodeName%26%26e.firstChild%26%26%22CODE%22%3D%3D%3De.firstChild.nodeName%7D%2Creplacement%3Afunction(e%2Cn%2Ct)%7Bfor(var%20i%2Co%3D((n.firstChild.getAttribute(%22class%22)%7C%7C%22%22).match(%2Flanguage-(%5CS%2B)%2F)%7C%7C%5Bnull%2C%22%22%5D)%5B1%5D%2Ca%3Dn.firstChild.textContent%2Cl%3Dt.fence.charAt(0)%2Cd%3D3%2Cc%3Dnew%20RegExp(%22%5E%22%2Bl%2B%22%7B3%2C%7D%22%2C%22gm%22)%3Bi%3Dc.exec(a)%3B)i%5B0%5D.length%3E%3Dd%26%26(d%3Di%5B0%5D.length%2B1)%3Bvar%20u%3Dr(l%2Cd)%3Breturn%22%5Cn%5Cn%22%2Bu%2Bo%2B%22%5Cn%22%2Ba.replace(%2F%5Cn%24%2F%2C%22%22)%2B%22%5Cn%22%2Bu%2B%22%5Cn%5Cn%22%7D%7D%2Cs.horizontalRule%3D%7Bfilter%3A%22hr%22%2Creplacement%3Afunction(e%2Cn%2Ct)%7Breturn%22%5Cn%5Cn%22%2Bt.hr%2B%22%5Cn%5Cn%22%7D%7D%2Cs.inlineLink%3D%7Bfilter%3Afunction(e%2Cn)%7Breturn%22inlined%22%3D%3D%3Dn.linkStyle%26%26%22A%22%3D%3D%3De.nodeName%26%26e.getAttribute(%22href%22)%7D%2Creplacement%3Afunction(e%2Cn)%7Bvar%20t%3Dn.getAttribute(%22href%22)%2Cr%3Dp(n.getAttribute(%22title%22))%3Breturn%20r%26%26(r%3D'%20%22'%2Br%2B'%22')%2C%22%5B%22%2Be%2B%22%5D(%22%2Bt%2Br%2B%22)%22%7D%7D%2Cs.referenceLink%3D%7Bfilter%3Afunction(e%2Cn)%7Breturn%22referenced%22%3D%3D%3Dn.linkStyle%26%26%22A%22%3D%3D%3De.nodeName%26%26e.getAttribute(%22href%22)%7D%2Creplacement%3Afunction(e%2Cn%2Ct)%7Bvar%20r%2Ci%2Co%3Dn.getAttribute(%22href%22)%2Ca%3Dp(n.getAttribute(%22title%22))%3Bswitch(a%26%26(a%3D'%20%22'%2Ba%2B'%22')%2Ct.linkReferenceStyle)%7Bcase%22collapsed%22%3Ar%3D%22%5B%22%2Be%2B%22%5D%5B%5D%22%2Ci%3D%22%5B%22%2Be%2B%22%5D%3A%20%22%2Bo%2Ba%3Bbreak%3Bcase%22shortcut%22%3Ar%3D%22%5B%22%2Be%2B%22%5D%22%2Ci%3D%22%5B%22%2Be%2B%22%5D%3A%20%22%2Bo%2Ba%3Bbreak%3Bdefault%3Avar%20l%3Dthis.references.length%2B1%3Br%3D%22%5B%22%2Be%2B%22%5D%5B%22%2Bl%2B%22%5D%22%2Ci%3D%22%5B%22%2Bl%2B%22%5D%3A%20%22%2Bo%2Ba%7Dreturn%20this.references.push(i)%2Cr%7D%2Creferences%3A%5B%5D%2Cappend%3Afunction(e)%7Bvar%20n%3D%22%22%3Breturn%20this.references.length%26%26(n%3D%22%5Cn%5Cn%22%2Bthis.references.join(%22%5Cn%22)%2B%22%5Cn%5Cn%22%2Cthis.references%3D%5B%5D)%2Cn%7D%7D%2Cs.emphasis%3D%7Bfilter%3A%5B%22em%22%2C%22i%22%5D%2Creplacement%3Afunction(e%2Cn%2Ct)%7Breturn%20e.trim()%3Ft.emDelimiter%2Be%2Bt.emDelimiter%3A%22%22%7D%7D%2Cs.strong%3D%7Bfilter%3A%5B%22strong%22%2C%22b%22%5D%2Creplacement%3Afunction(e%2Cn%2Ct)%7Breturn%20e.trim()%3Ft.strongDelimiter%2Be%2Bt.strongDelimiter%3A%22%22%7D%7D%2Cs.code%3D%7Bfilter%3Afunction(e)%7Bvar%20n%3De.previousSibling%7C%7Ce.nextSibling%2Ct%3D%22PRE%22%3D%3D%3De.parentNode.nodeName%26%26!n%3Breturn%22CODE%22%3D%3D%3De.nodeName%26%26!t%7D%2Creplacement%3Afunction(e)%7Bif(!e)return%22%22%3Be%3De.replace(%2F%5Cr%3F%5Cn%7C%5Cr%2Fg%2C%22%20%22)%3Bfor(var%20n%3D%2F%5E%60%7C%5E%20.*%3F%5B%5E%20%5D.*%20%24%7C%60%24%2F.test(e)%3F%22%20%22%3A%22%22%2Ct%3D%22%60%22%2Cr%3De.match(%2F%60%2B%2Fgm)%7C%7C%5B%5D%3B-1!%3D%3Dr.indexOf(t)%3B)t%2B%3D%22%60%22%3Breturn%20t%2Bn%2Be%2Bn%2Bt%7D%7D%2Cs.image%3D%7Bfilter%3A%22img%22%2Creplacement%3Afunction(e%2Cn)%7Bvar%20t%3Dp(n.getAttribute(%22alt%22))%2Cr%3Dn.getAttribute(%22src%22)%7C%7C%22%22%2Ci%3Dp(n.getAttribute(%22title%22))%3Breturn%20r%3F%22!%5B%22%2Bt%2B%22%5D(%22%2Br%2B(i%3F'%20%22'%2Bi%2B'%22'%3A%22%22)%2B%22)%22%3A%22%22%7D%7D%2Cf.prototype%3D%7Badd%3Afunction(e%2Cn)%7Bthis.array.unshift(n)%7D%2Ckeep%3Afunction(e)%7Bthis._keep.unshift(%7Bfilter%3Ae%2Creplacement%3Athis.keepReplacement%7D)%7D%2Cremove%3Afunction(e)%7Bthis._remove.unshift(%7Bfilter%3Ae%2Creplacement%3Afunction()%7Breturn%22%22%7D%7D)%7D%2CforNode%3Afunction(e)%7Breturn%20e.isBlank%3Fthis.blankRule%3A(n%3Dm(this.array%2Ce%2Cthis.options))%7C%7C(n%3Dm(this._keep%2Ce%2Cthis.options))%7C%7C(n%3Dm(this._remove%2Ce%2Cthis.options))%3Fn%3Athis.defaultRule%3Bvar%20n%7D%2CforEach%3Afunction(e)%7Bfor(var%20n%3D0%3Bn%3Cthis.array.length%3Bn%2B%2B)e(this.array%5Bn%5D%2Cn)%7D%7D%3Bvar%20v%2Cy%2CC%3D%22undefined%22!%3Dtypeof%20window%3Fwindow%3A%7B%7D%2CN%3Dfunction()%7Bvar%20e%3DC.DOMParser%2Cn%3D!1%3Btry%7B(new%20e).parseFromString(%22%22%2C%22text%2Fhtml%22)%26%26(n%3D!0)%7Dcatch(e)%7B%7Dreturn%20n%7D()%3FC.DOMParser%3A(v%3Dfunction()%7B%7D%2Cfunction()%7Bvar%20e%3D!1%3Btry%7Bdocument.implementation.createHTMLDocument(%22%22).open()%7Dcatch(n)%7Bwindow.ActiveXObject%26%26(e%3D!0)%7Dreturn%20e%7D()%3Fv.prototype.parseFromString%3Dfunction(e)%7Bvar%20n%3Dnew%20window.ActiveXObject(%22htmlfile%22)%3Breturn%20n.designMode%3D%22on%22%2Cn.open()%2Cn.write(e)%2Cn.close()%2Cn%7D%3Av.prototype.parseFromString%3Dfunction(e)%7Bvar%20n%3Ddocument.implementation.createHTMLDocument(%22%22)%3Breturn%20n.open()%2Cn.write(e)%2Cn.close()%2Cn%7D%2Cv)%3Bfunction%20T(e%2Cn)%7Bvar%20t%3Breturn%20function(e)%7Bvar%20n%3De.element%2Ct%3De.isBlock%2Cr%3De.isVoid%2Ci%3De.isPre%7C%7Cfunction(e)%7Breturn%22PRE%22%3D%3D%3De.nodeName%7D%3Bif(n.firstChild%26%26!i(n))%7Bfor(var%20o%3Dnull%2Ca%3D!1%2Cl%3Dnull%2Cd%3Db(l%2Cn%2Ci)%3Bd!%3D%3Dn%3B)%7Bif(3%3D%3D%3Dd.nodeType%7C%7C4%3D%3D%3Dd.nodeType)%7Bvar%20c%3Dd.data.replace(%2F%5B%20%5Cr%5Cn%5Ct%5D%2B%2Fg%2C%22%20%22)%3Bif(o%26%26!%2F%20%24%2F.test(o.data)%7C%7Ca%7C%7C%22%20%22!%3D%3Dc%5B0%5D%7C%7C(c%3Dc.substr(1))%2C!c)%7Bd%3Dg(d)%3Bcontinue%7Dd.data%3Dc%2Co%3Dd%7Delse%7Bif(1!%3D%3Dd.nodeType)%7Bd%3Dg(d)%3Bcontinue%7Dt(d)%7C%7C%22BR%22%3D%3D%3Dd.nodeName%3F(o%26%26(o.data%3Do.data.replace(%2F%20%24%2F%2C%22%22))%2Co%3Dnull%2Ca%3D!1)%3Ar(d)%7C%7Ci(d)%3F(o%3Dnull%2Ca%3D!0)%3Ao%26%26(a%3D!1)%7Dvar%20u%3Db(l%2Cd%2Ci)%3Bl%3Dd%2Cd%3Du%7Do%26%26(o.data%3Do.data.replace(%2F%20%24%2F%2C%22%22)%2Co.data%7C%7Cg(o))%7D%7D(%7Belement%3At%3D%22string%22%3D%3Dtypeof%20e%3F(y%3Dy%7C%7Cnew%20N).parseFromString('%3Cx-turndown%20id%3D%22turndown-root%22%3E'%2Be%2B%22%3C%2Fx-turndown%3E%22%2C%22text%2Fhtml%22).getElementById(%22turndown-root%22)%3Ae.cloneNode(!0)%2CisBlock%3Ao%2CisVoid%3Al%2CisPre%3An.preformattedCode%3FA%3Anull%7D)%2Ct%7Dfunction%20A(e)%7Breturn%22PRE%22%3D%3D%3De.nodeName%7C%7C%22CODE%22%3D%3D%3De.nodeName%7Dfunction%20w(e%2Cn)%7Breturn%20e.isBlock%3Do(e)%2Ce.isCode%3D%22CODE%22%3D%3D%3De.nodeName%7C%7Ce.parentNode.isCode%2Ce.isBlank%3Dfunction(e)%7Breturn!l(e)%26%26!function(e)%7Breturn%20c(e%2Cd)%7D(e)%26%26%2F%5E%5Cs*%24%2Fi.test(e.textContent)%26%26!function(e)%7Breturn%20u(e%2Ca)%7D(e)%26%26!function(e)%7Breturn%20u(e%2Cd)%7D(e)%7D(e)%2Ce.flankingWhitespace%3Dfunction(e%2Cn)%7Bif(e.isBlock%7C%7Cn.preformattedCode%26%26e.isCode)return%7Bleading%3A%22%22%2Ctrailing%3A%22%22%7D%3Bvar%20t%2Cr%3D%7Bleading%3A(t%3De.textContent.match(%2F%5E((%5B%20%5Ct%5Cr%5Cn%5D*)(%5Cs*))%5B%5Cs%5CS%5D*%3F((%5Cs*%3F)(%5B%20%5Ct%5Cr%5Cn%5D*))%24%2F))%5B1%5D%2CleadingAscii%3At%5B2%5D%2CleadingNonAscii%3At%5B3%5D%2Ctrailing%3At%5B4%5D%2CtrailingNonAscii%3At%5B5%5D%2CtrailingAscii%3At%5B6%5D%7D%3Breturn%20r.leadingAscii%26%26E(%22left%22%2Ce%2Cn)%26%26(r.leading%3Dr.leadingNonAscii)%2Cr.trailingAscii%26%26E(%22right%22%2Ce%2Cn)%26%26(r.trailing%3Dr.trailingNonAscii)%2C%7Bleading%3Ar.leading%2Ctrailing%3Ar.trailing%7D%7D(e%2Cn)%2Ce%7Dfunction%20E(e%2Cn%2Ct)%7Bvar%20r%2Ci%2Ca%3Breturn%22left%22%3D%3D%3De%3F(r%3Dn.previousSibling%2Ci%3D%2F%20%24%2F)%3A(r%3Dn.nextSibling%2Ci%3D%2F%5E%20%2F)%2Cr%26%26(3%3D%3D%3Dr.nodeType%3Fa%3Di.test(r.nodeValue)%3At.preformattedCode%26%26%22CODE%22%3D%3D%3Dr.nodeName%3Fa%3D!1%3A1!%3D%3Dr.nodeType%7C%7Co(r)%7C%7C(a%3Di.test(r.textContent)))%2Ca%7Dvar%20R%3DArray.prototype.reduce%2CS%3D%5B%5B%2F%5C%5C%2Fg%2C%22%5C%5C%5C%5C%22%5D%2C%5B%2F%5C*%2Fg%2C%22%5C%5C*%22%5D%2C%5B%2F%5E-%2Fg%2C%22%5C%5C-%22%5D%2C%5B%2F%5E%5C%2B%20%2Fg%2C%22%5C%5C%2B%20%22%5D%2C%5B%2F%5E(%3D%2B)%2Fg%2C%22%5C%5C%241%22%5D%2C%5B%2F%5E(%23%7B1%2C6%7D)%20%2Fg%2C%22%5C%5C%241%20%22%5D%2C%5B%2F%60%2Fg%2C%22%5C%5C%60%22%5D%2C%5B%2F%5E~~~%2Fg%2C%22%5C%5C~~~%22%5D%2C%5B%2F%5C%5B%2Fg%2C%22%5C%5C%5B%22%5D%2C%5B%2F%5C%5D%2Fg%2C%22%5C%5C%5D%22%5D%2C%5B%2F%5E%3E%2Fg%2C%22%5C%5C%3E%22%5D%2C%5B%2F_%2Fg%2C%22%5C%5C_%22%5D%2C%5B%2F%5E(%5Cd%2B)%5C.%20%2Fg%2C%22%241%5C%5C.%20%22%5D%5D%3Bfunction%20k(e)%7Bif(!(this%20instanceof%20k))return%20new%20k(e)%3Bvar%20n%3D%7Brules%3As%2CheadingStyle%3A%22setext%22%2Chr%3A%22*%20*%20*%22%2CbulletListMarker%3A%22*%22%2CcodeBlockStyle%3A%22indented%22%2Cfence%3A%22%60%60%60%22%2CemDelimiter%3A%22_%22%2CstrongDelimiter%3A%22**%22%2ClinkStyle%3A%22inlined%22%2ClinkReferenceStyle%3A%22full%22%2Cbr%3A%22%20%20%22%2CpreformattedCode%3A!1%2CblankReplacement%3Afunction(e%2Cn)%7Breturn%20n.isBlock%3F%22%5Cn%5Cn%22%3A%22%22%7D%2CkeepReplacement%3Afunction(e%2Cn)%7Breturn%20n.isBlock%3F%22%5Cn%5Cn%22%2Bn.outerHTML%2B%22%5Cn%5Cn%22%3An.outerHTML%7D%2CdefaultReplacement%3Afunction(e%2Cn)%7Breturn%20n.isBlock%3F%22%5Cn%5Cn%22%2Be%2B%22%5Cn%5Cn%22%3Ae%7D%7D%3Bthis.options%3Dfunction(e)%7Bfor(var%20n%3D1%3Bn%3Carguments.length%3Bn%2B%2B)%7Bvar%20t%3Darguments%5Bn%5D%3Bfor(var%20r%20in%20t)t.hasOwnProperty(r)%26%26(e%5Br%5D%3Dt%5Br%5D)%7Dreturn%20e%7D(%7B%7D%2Cn%2Ce)%2Cthis.rules%3Dnew%20f(this.options)%7Dfunction%20x(e)%7Bvar%20n%3Dthis%3Breturn%20R.call(e.childNodes%2C(function(e%2Ct)%7Bvar%20r%3D%22%22%3Breturn%203%3D%3D%3D(t%3Dnew%20w(t%2Cn.options)).nodeType%3Fr%3Dt.isCode%3Ft.nodeValue%3An.escape(t.nodeValue)%3A1%3D%3D%3Dt.nodeType%26%26(r%3DB.call(n%2Ct))%2CD(e%2Cr)%7D)%2C%22%22)%7Dfunction%20O(e)%7Bvar%20n%3Dthis%3Breturn%20this.rules.forEach((function(t)%7B%22function%22%3D%3Dtypeof%20t.append%26%26(e%3DD(e%2Ct.append(n.options)))%7D))%2Ce.replace(%2F%5E%5B%5Ct%5Cr%5Cn%5D%2B%2F%2C%22%22).replace(%2F%5B%5Ct%5Cr%5Cn%5Cs%5D%2B%24%2F%2C%22%22)%7Dfunction%20B(e)%7Bvar%20n%3Dthis.rules.forNode(e)%2Ct%3Dx.call(this%2Ce)%2Cr%3De.flankingWhitespace%3Breturn(r.leading%7C%7Cr.trailing)%26%26(t%3Dt.trim())%2Cr.leading%2Bn.replacement(t%2Ce%2Cthis.options)%2Br.trailing%7Dfunction%20D(e%2Cn)%7Bvar%20t%3Dfunction(e)%7Bfor(var%20n%3De.length%3Bn%3E0%26%26%22%5Cn%22%3D%3D%3De%5Bn-1%5D%3B)n--%3Breturn%20e.substring(0%2Cn)%7D(e)%2Cr%3Dn.replace(%2F%5E%5Cn*%2F%2C%22%22)%2Ci%3DMath.max(e.length-t.length%2Cn.length-r.length)%3Breturn%20t%2B%22%5Cn%5Cn%22.substring(0%2Ci)%2Br%7Dk.prototype%3D%7Bturndown%3Afunction(e)%7Bif(!function(e)%7Breturn%20null!%3De%26%26(%22string%22%3D%3Dtypeof%20e%7C%7Ce.nodeType%26%26(1%3D%3D%3De.nodeType%7C%7C9%3D%3D%3De.nodeType%7C%7C11%3D%3D%3De.nodeType))%7D(e))throw%20new%20TypeError(e%2B%22%20is%20not%20a%20string%2C%20or%20an%20element%2Fdocument%2Ffragment%20node.%22)%3Bif(%22%22%3D%3D%3De)return%22%22%3Bvar%20n%3Dx.call(this%2Cnew%20T(e%2Cthis.options))%3Breturn%20O.call(this%2Cn)%7D%2Cuse%3Afunction(e)%7Bif(Array.isArray(e))for(var%20n%3D0%3Bn%3Ce.length%3Bn%2B%2B)this.use(e%5Bn%5D)%3Belse%7Bif(%22function%22!%3Dtypeof%20e)throw%20new%20TypeError(%22plugin%20must%20be%20a%20Function%20or%20an%20Array%20of%20Functions%22)%3Be(this)%7Dreturn%20this%7D%2CaddRule%3Afunction(e%2Cn)%7Breturn%20this.rules.add(e%2Cn)%2Cthis%7D%2Ckeep%3Afunction(e)%7Breturn%20this.rules.keep(e)%2Cthis%7D%2Cremove%3Afunction(e)%7Breturn%20this.rules.remove(e)%2Cthis%7D%2Cescape%3Afunction(e)%7Breturn%20S.reduce((function(e%2Cn)%7Breturn%20e.replace(n%5B0%5D%2Cn%5B1%5D)%7D)%2Ce)%7D%7D%3Bconst%20L%3Dk%7D%2C402%3A(e%2Cn)%3D%3E%7Bn.__esModule%3D!0%2Cn.MarkdownTables%3Dvoid%200%3Bvar%20t%3Dfunction()%7Bfunction%20e()%7B%7Dreturn%20e.tableShouldBeSkipped%3Dfunction(n)%7Breturn!n%7C%7C!n.rows%7C%7C1%3D%3D%3Dn.rows.length%26%26n.rows%5B0%5D.childNodes.length%3C%3D1%7C%7C!!e.nodeContainsTable(n)%7D%2Ce.isHeadingRow%3Dfunction(n)%7Bvar%20t%3Dn.parentNode%2Cr%3D!1%3Breturn%20t%26%26(%22THEAD%22%3D%3D%3Dt.nodeName%3Fr%3D!0%3At.firstChild!%3D%3Dn%3Fr%3D!1%3A(%22TABLE%22%3D%3D%3Dt.nodeName%7C%7Ce.isFirstTbody(t))%26%26(r%3DArray.prototype.every.call(n.childNodes%2C(function(e)%7Breturn%22TH%22%3D%3D%3De.nodeName%7D))))%2Cr%7D%2Ce.isFirstTbody%3Dfunction(e)%7Bvar%20n%3De.previousSibling%2Ct%3D!1%3Breturn%20n%26%26(t%3D!(%22TBODY%22!%3D%3De.nodeName%7C%7Cn%26%26(%22THEAD%22!%3D%3Dn.nodeName%7C%7C!n.textContent%7C%7C!%2F%5E%5Cs*%24%2Fi.test(n.textContent))))%2Ct%7D%2Ce.cell%3Dfunction(n%2Ct%2Cr)%7Bvoid%200%3D%3D%3Dt%26%26(t%3Dnull)%2Cvoid%200%3D%3D%3Dr%26%26(r%3Dnull)%2Cnull%3D%3D%3Dr%26%26null!%3Dt%26%26t.parentNode%26%26(r%3DArray.prototype.indexOf.call(t.parentNode.childNodes%2Ct))%3Bvar%20i%3D%22%20%22%3B0%3D%3D%3Dr%26%26(i%3D%22%7C%20%22)%3Bvar%20o%3Dn.trim().replace(%2F%5Cn%5Cr%2Fg%2C%22%3Cbr%3E%22).replace(%2F%5Cn%2Fg%2C%22%3Cbr%3E%22)%3Bfor(o%3Do.replace(%2F%5C%7C%2B%2Fg%2C%22%5C%5C%7C%22)%3Bo.length%3C3%3B)o%2B%3D%22%20%22%3Breturn%20t%26%26(o%3De.handleColSpan(o%2Ct%2C%22%20%22))%2Ci%2Bo%2B%22%20%7C%22%7D%2Ce.nodeContainsTable%3Dfunction(n)%7Bif(!n.childNodes)return!1%3Bfor(var%20t%3D0%3Bt%3Cn.childNodes.length%3Bt%2B%2B)%7Bvar%20r%3Dn.childNodes%5Bt%5D%3Bif(%22TABLE%22%3D%3D%3Dr.nodeName)return!0%3Bif(e.nodeContainsTable(r))return!0%7Dreturn!1%7D%2Ce.nodeParentTable%3Dfunction(e)%7Bvar%20n%3De.parentNode%3Bif(n)for(%3Bn%26%26%22TABLE%22!%3D%3Dn.nodeName%3B)n%3Dn.parentNode%3Breturn%20n%7D%2Ce.handleColSpan%3Dfunction(e%2Cn%2Ct)%7Bfor(var%20r%3Dn.getAttribute(%22colspan%22)%7C%7C%221%22%2Ci%3D1%3Bi%3CparseInt(r%2C10)%3Bi%2B%2B)e%2B%3D%22%20%7C%20%22%2Bt.repeat(3)%3Breturn%20e%7D%2Ce.tableColCount%3Dfunction(e)%7Bvar%20n%3D0%3Bif(e%26%26e.rows)for(var%20t%3D0%3Bt%3Ce.rows.length%3Bt%2B%2B)%7Bvar%20r%3De.rows%5Bt%5D.childNodes.length%3Br%3En%26%26(n%3Dr)%7Dreturn%20n%7D%2Ce%7D()%2Cr%3Dfunction()%7Bfunction%20e()%7B%7Dreturn%20e.prototype.tables%3Dfunction(e)%7Be.keep((function(e)%7Bvar%20n%3D!1%3Breturn%20e.nodeName%26%26(n%3D%22TABLE%22%3D%3D%3De.nodeName)%2Cn%7D))%3Bvar%20n%2Cr%3D%7BtableCell%3A%7Bfilter%3A%5B%22th%22%2C%22td%22%5D%2Creplacement%3Afunction(e%2Cn)%7Breturn%20t.tableShouldBeSkipped(t.nodeParentTable(n))%3Fe%3At.cell(e%2Cn)%7D%7D%2CtableRow%3A%7Bfilter%3A%22tr%22%2Creplacement%3Afunction(e%2Cn)%7Bvar%20r%3Dt.nodeParentTable(n)%3Bif(t.tableShouldBeSkipped(r))return%20e%3Bvar%20i%3D%22%22%2Co%3D%7Bleft%3A%22%3A--%22%2Cright%3A%22--%3A%22%2Ccenter%3A%22%3A-%3A%22%7D%3Bif(t.isHeadingRow(n))for(var%20a%3Dt.tableColCount(r)%2Cl%3D0%3Bl%3Ca%3Bl%2B%2B)%7Bvar%20d%3Da%3E%3Dn.childNodes.length%3Fnull%3An.childNodes%5Bl%5D%2Cc%3D%22---%22%2Cu%3Dd%3F(d.getAttribute(%22align%22)%7C%7C%22%22).toLowerCase()%3A%22%22%3Bu%26%26(c%3Do%5Bu%5D%7C%7Cc)%2Ci%2B%3Dd%3Ft.cell(c%2Cn.childNodes%5Bl%5D)%3At.cell(c%2Cnull%2Cl)%7Dreturn%22%5Cn%22%2Be%2B(i%3F%22%5Cn%22%2Bi%3A%22%22)%7D%7D%2Ctable%3A%7Bfilter%3Afunction(e)%7Breturn%22TABLE%22%3D%3D%3De.nodeName%7D%2Creplacement%3Afunction(e%2Cn)%7Bif(t.tableShouldBeSkipped(n))return%20e%3Bvar%20r%3D(e%3De.replace(%2F%5Cn%2B%2Fg%2C%22%5Cn%22)).trim().split(%22%5Cn%22)%3Br.length%3E%3D2%26%26(r%3Dr%5B1%5D)%3Bvar%20i%3D0%3D%3D%3Dr.indexOf(%22%7C%20---%22)%2Co%3Dt.tableColCount(n)%2Ca%3D%22%22%3Breturn%20o%26%26!i%26%26(a%3D%22%7C%22%2B%22%20%20%20%20%20%7C%22.repeat(o)%2B%22%5Cn%7C%22%2B%22%20---%20%7C%22.repeat(o))%2C%22%5Cn%5Cn%22%2Ba%2Be%2B%22%5Cn%5Cn%22%7D%7D%2CtableSection%3A%7Bfilter%3A%5B%22thead%22%2C%22tbody%22%2C%22tfoot%22%5D%2Creplacement%3Afunction(e)%7Breturn%20e%7D%7D%7D%3Bfor(n%20in%20r)e.addRule(n%2Cr%5Bn%5D)%7D%2Ce%7D()%3Bn.MarkdownTables%3Dr%7D%7D%2Cr%3D%7B%7D%3Bfunction%20i(e)%7Bvar%20n%3Dr%5Be%5D%3Bif(void%200!%3D%3Dn)return%20n.exports%3Bvar%20o%3Dr%5Be%5D%3D%7Bexports%3A%7B%7D%7D%3Breturn%20t%5Be%5D(o%2Co.exports%2Ci)%2Co.exports%7Di.d%3D(e%2Cn)%3D%3E%7Bfor(var%20t%20in%20n)i.o(n%2Ct)%26%26!i.o(e%2Ct)%26%26Object.defineProperty(e%2Ct%2C%7Benumerable%3A!0%2Cget%3An%5Bt%5D%7D)%7D%2Ci.o%3D(e%2Cn)%3D%3EObject.prototype.hasOwnProperty.call(e%2Cn)%2Ci.r%3De%3D%3E%7B%22undefined%22!%3Dtypeof%20Symbol%26%26Symbol.toStringTag%26%26Object.defineProperty(e%2CSymbol.toStringTag%2C%7Bvalue%3A%22Module%22%7D)%2CObject.defineProperty(e%2C%22__esModule%22%2C%7Bvalue%3A!0%7D)%7D%2Ce%3Di(36)%2Cn%3Di(402)%2Cfunction(t%2Cr%2Ci%2Co)%7Bvar%20a%3DencodeURIComponent(%22${this.vaultName}%22)%2Cl%3DencodeURIComponent(%22${this.notePath}%22)%2Cd%3DencodeURIComponent(%22${this.captureComments}%22)%2Cc%3D%22%22%2Cu%3Dnew%20e.default(%7BheadingStyle%3A%22atx%22%2Chr%3A%22---%22%2CbulletListMarker%3A%22-%22%2CcodeBlockStyle%3A%22fenced%22%2CemDelimiter%3A%22*%22%7D)%2Cs%3Dnew%20n.MarkdownTables%3Bu.use(s.tables)%2Cu.addRule(%22heading_1_update%22%2C%7Bfilter%3A%5B%22h1%22%5D%2Creplacement%3Afunction(e)%7Breturn%22%22.concat(i.h1%2C%22%20%22).concat(e)%7D%7D)%2Cu.addRule(%22heading_2_update%22%2C%7Bfilter%3A%5B%22h2%22%5D%2Creplacement%3Afunction(e)%7Breturn%22%22.concat(i.h2%2C%22%20%22).concat(e)%7D%7D)%2Cu.addRule(%22heading_3_update%22%2C%7Bfilter%3A%5B%22h3%22%5D%2Creplacement%3Afunction(e)%7Breturn%22%22.concat(i.h3%2C%22%20%22).concat(e)%7D%7D)%2Cu.addRule(%22heading_4_update%22%2C%7Bfilter%3A%5B%22h4%22%5D%2Creplacement%3Afunction(e)%7Breturn%22%22.concat(i.h4%2C%22%20%22).concat(e)%7D%7D)%2Cu.addRule(%22heading_5_update%22%2C%7Bfilter%3A%5B%22h5%22%5D%2Creplacement%3Afunction(e)%7Breturn%22%22.concat(i.h5%2C%22%20%22).concat(e)%7D%7D)%2Cu.addRule(%22heading_6_update%22%2C%7Bfilter%3A%5B%22h6%22%5D%2Creplacement%3Afunction(e)%7Breturn%22%22.concat(i.h6%2C%22%20%22).concat(e)%7D%7D)%2Cu.addRule(%22fix_relative_links%22%2C%7Bfilter%3A%5B%22a%22%5D%2Creplacement%3Afunction(e%2Cn)%7Bvar%20t%3Dn.href%3Breturn%20t.includes(%22%3A%2F%2F%22)%7C%7C(t%3Dwindow.location.protocol%2B%22%2F%2F%22%2Bwindow.location.host%2Bt)%2C%22%5B%22.concat(e%2C%22%5D(%22).concat(t%2C%22)%22)%7D%7D)%3Bvar%20p%3Du.turndown(function()%7Bvar%20e%3D%22%22%3Bif(void%200!%3D%3Dwindow.getSelection)%7Bvar%20n%3Dwindow.getSelection()%3Bif(n%26%26n.rangeCount)%7Bfor(var%20t%3Ddocument.createElement(%22div%22)%2Cr%3D0%2Ci%3Dn.rangeCount%3Br%3Ci%3B%2B%2Br)t.appendChild(n.getRangeAt(r).cloneContents())%3Be%3Dt.innerHTML%7D%7Dreturn%20e%7D())%3Bfunction%20f()%7Bvar%20e%3Ddocument.getElementsByClassName(%22obsidian-clipper-modal-overlay%22)%5B0%5D%3Bif(e)%7Bvar%20n%3Ddocument.getElementById(%22obsidian-clipper-comment%22)%3Bc%3Dn.value%2Cn.value%3D%22%22%2Ce.style.display%3D%22none%22%7Dvar%20t%3Ddocument.URL%2Cr%3Ddocument.title%2Ci%3D%22obsidian%3A%2F%2Fobsidian-clipper%3Fvault%3D%22.concat(a%2C%22%26notePath%3D%22).concat(l%2C%22%26url%3D%22).concat(encodeURIComponent(t)%2C%22%26format%3Dmd%26title%3D%22).concat(encodeURIComponent(r)%2C%22%26highlightdata%3D%22).concat(encodeURIComponent(p)%2C%22%26comments%3D%22).concat(encodeURIComponent(c))%3B-1!%3D%3Dnavigator.userAgent.indexOf(%22Chrome%22)%26%26-1!%3D%3Dnavigator.userAgent.indexOf(%22Windows%22)%26%26i.length%3E%3D2e3%26%26alert(%22Chrome%20on%20Windows%20doesn't%20allow%20a%20highlight%20this%20large.%20%22.concat(i.length%2C%22%20characters%20have%20been%20selected%20and%20it%20must%20be%20less%20than%202000%22))%2Cfunction(e)%7Breturn-1!%3D%3Dnavigator.userAgent.indexOf(%22Chrome%22)%26%26-1!%3D%3Dnavigator.userAgent.indexOf(%22Windows%22)%26%26e.length%3E%3D2e3%26%26(alert(%22Chrome%20on%20Windows%20doesn't%20allow%20a%20highlight%20this%20large.%5Cn%20%22.concat(e.length%2C%22%20characters%20have%20been%20selected%20and%20it%20must%20be%20less%20than%202000.%20%5Cn%5Cn%20Firefox%20on%20Windows%20doesn't%20seem%20to%20have%20this%20same%20problem.%22))%2C!0)%7D(i)%7C%7C(document.location.href%3Di)%7D%22true%22%3D%3D%3Dd%3Ffunction()%7Bvar%20e%2Cn%3Ddocument.getElementsByClassName(%22obsidian-clipper-modal-overlay%22)%5B0%5D%3Bif(n)n.style.display%3D%22block%22%3Belse%7Bvar%20t%3Ddocument.createElement(%22style%22)%2Cr%3Ddocument.createTextNode(%22%5Cn.obsidian-clipper-modal%20%7B%5Cn%5Ctz-index%3A%2010000%3B%5Cn%5Ctposition%3A%20fixed%3B%5Cn%5Cttop%3A%2050%25%3B%5Cn%5Ctleft%3A%2050%25%3B%5Cn%5Cttransform%3A%20translate(-50%25%2C%20-50%25)%3B%5Cn%5Ctdisplay%3A%20flex%3B%5Cn%20%20flex-direction%3A%20column%3B%5Cn%20%20gap%3A%200.4rem%3B%5Cn%20%20width%3A%20450px%3B%5Cn%20%20padding%3A%201.3rem%3B%5Cn%20%20background-color%3A%20white%3B%5Cn%20%20border%3A%201px%20solid%20%23ddd%3B%5Cn%20%20border-radius%3A%2015px%3B%5Cn%7D%5Cn.obsidian-clipper-modal%20.flex%20%7B%5Cn%20%20display%3A%20flex%3B%5Cn%20%20align-items%3A%20center%3B%5Cn%20%20justify-content%3A%20space-between%3B%5Cn%7D%5Cn%5Cn.obsidian-clipper-modal%20input%20%7B%5Cn%20%20padding%3A%200.7rem%201rem%3B%5Cn%20%20border%3A%201px%20solid%20%23ddd%3B%5Cn%20%20border-radius%3A%205px%3B%5Cn%20%20font-size%3A%200.9em%3B%5Cn%7D%5Cn%5Cn.obsidian-clipper-modal%20p%20%7B%5Cn%20%20font-size%3A%200.9rem%3B%5Cn%20%20color%3A%20%23777%3B%5Cn%20%20margin%3A%200.4rem%200%200.2rem%3B%5Cn%7D%5Cn%5Cn.obsidian-clipper-modal%20label%20%7B%5Cndisplay%3A%20block%3B%20%5Cnmargin-bottom%3A%200.5rem%3B%20%5Cncolor%3A%20%23111827%3B%20%5Cnfont-size%3A%200.875rem%3B%5Cnline-height%3A%201.25rem%3B%20%5Cnfont-weight%3A%20500%3B%5Cn%7D%5Cn%5Cn.obsidian-clipper-modal%20textarea%20%7B%5Cn%5Ctdisplay%3A%20block%3B%20!important%3B%20%5Cn%5Ctpadding%3A%200.625rem%20!important%3B%20%5Cn%5Ctbackground-color%3A%20%23F9FAFB%20!important%3B%20%5Cn%5Ctcolor%3A%20%23111827%20!important%3B%20%5Cn%5Ctfont-size%3A%200.875rem%20!important%3B%20%5Cn%5Ctline-height%3A%201.25rem%20!important%3B%20%5Cn%20%5Ctwidth%3A%20100%25%20!important%3B%20%5Cn%5Ctborder-radius%3A%200.5rem%20!important%3B%20%5Cn%5Ctborder-width%3A%201px%20!important%3B%20%5Cn%5Ctborder-color%3A%20%23D1D5DB%20!important%3B%20%5Cn%7D%5Cn%5Cn.obsidian-clipper-modal%20button%20%7B%5Cn%5Ctpadding-top%3A%200.625rem%20!important%3B%5Cnpadding-bottom%3A%200.625rem%20!important%3B%5Cnpadding-left%3A%201.25rem%20!important%3B%5Cnpadding-right%3A%201.25rem%20!important%3B%5Cnmargin-right%3A%200.5rem%20!important%3B%5Cnmargin-bottom%3A%200.5rem%20!important%3B%5Cnbackground-color%3A%20%231F2937%20!important%3B%5Cncolor%3A%20%23ffffff%20!important%3B%5Cnfont-size%3A%200.875rem%20!important%3B%5Cnline-height%3A%201.25rem%20!important%3B%5Cnfont-weight%3A%20500%20!important%3B%5Cnborder-radius%3A%200.5rem%20!important%3B%5Cn%7D%5Cn%5Cn.obsidian-clipper-modal-overlay%20%7B%5Cn%20%20background%3A%20rgba(0%2C%200%2C%200%2C%200.6)%3B%5Cn%20%20position%3A%20fixed%3B%5Cn%20%20top%3A%200%3B%5Cn%20%20left%3A%200%3B%5Cn%20%20right%3A%200%3B%5Cn%20%20bottom%3A%200%3B%5Cn%20%20z-index%3A%209999%3B%5Cn%7D%5Cn%5Cn%22)%3Bt.appendChild(r)%2Cdocument.getElementsByTagName(%22head%22)%5B0%5D.appendChild(t)%3Bvar%20i%3Ddocument.createElement(%22div%22)%2Co%3Ddocument.createElement(%22div%22)%3Bo.innerHTML%3D'%5Cn%5Ct%5Ct%3Cdiv%3E%5Cn%5Ct%5Ct%5Ct%3Clabel%3EObsidian%20Clipper%3C%2Flabel%3E%5Cn%5Ct%5Ct%5Ct%3Ctextarea%20id%3D%22obsidian-clipper-comment%22%20rows%3D%226%22%5Ctplaceholder%3D%22Add%20your%20thoughts...%22%3E%3C%2Ftextarea%3E%5Cn%5Ct%5Ct%3C%2Fdiv%3E'%3Bvar%20a%3Ddocument.createElement(%22button%22)%3Ba.appendChild(document.createTextNode(%22Submit%22))%2Ca.addEventListener(%22click%22%2Cf%2C!1)%2Co.appendChild(a)%2Co.classList.add(%22obsidian-clipper-modal%22)%2Ci.classList.add(%22obsidian-clipper-modal-overlay%22)%2Ci.appendChild(o)%2Cdocument.body.appendChild(i)%2Cnull%3D%3D%3D(e%3Ddocument.getElementById(%22obsidian-clipper-comment%22))%7C%7Cvoid%200%3D%3D%3De%7C%7Ce.focus()%7D%7D()%3Af()%7D(0%2C0%2C%7Bh1%3A%22${this.markdownSettings.h1}%22%2Ch2%3A%22${this.markdownSettings.h2}%22%2Ch3%3A%22${this.markdownSettings.h3}%22%2Ch4%3A%22${this.markdownSettings.h4}%22%2Ch5%3A%22${this.markdownSettings.h5}%22%2Ch6%3A%22${this.markdownSettings.h6}%22%7D)%7D)()%3B%7D)()`;
  }
};

// src/settings/BookmarkletSettingsGroup.svelte
function create_fragment10(ctx) {
  let div3;
  let div2;
  let div1;
  let div0;
  let t1;
  let a;
  let t2;
  let t3;
  let t4;
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "You can drag or copy the link below to your browser bookmark bar. This\n				bookmarklet will allow you to highlight information on the web and send\n				it to obsidian";
      t1 = space();
      a = element("a");
      t2 = text("Obsidian Clipper (");
      t3 = text(ctx[1]);
      t4 = text(")");
      attr(a, "href", ctx[0]);
      attr(div1, "class", "flex-1 basis-0");
      attr(div2, "class", "flex flex-row");
      attr(div3, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      append(div1, t1);
      append(div1, a);
      append(a, t2);
      append(a, t3);
      append(a, t4);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        set_data(t3, ctx2[1]);
      if (dirty & 1) {
        attr(a, "href", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { clipperHref } = $$props;
  let { noteOrVault } = $$props;
  $$self.$$set = ($$props2) => {
    if ("clipperHref" in $$props2)
      $$invalidate(0, clipperHref = $$props2.clipperHref);
    if ("noteOrVault" in $$props2)
      $$invalidate(1, noteOrVault = $$props2.noteOrVault);
  };
  return [clipperHref, noteOrVault];
}
var BookmarkletSettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, { clipperHref: 0, noteOrVault: 1 });
  }
};
var BookmarkletSettingsGroup_default = BookmarkletSettingsGroup;

// src/settings/ExtensionSettingsGroup.svelte
var import_obsidian5 = require("obsidian");
function create_fragment11(ctx) {
  let div3;
  let div2;
  let div0;
  let t0;
  let span;
  let t1;
  let t2;
  let t3;
  let div1;
  let button;
  let t4;
  let t5;
  let t6;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text("Click the button below to generate a personalized Chrome-based extension\n			for the ");
      span = element("span");
      t1 = text(ctx[0]);
      t2 = text(". After clicking\n			the button, use the link to download the .zip file.");
      t3 = space();
      div1 = element("div");
      button = element("button");
      t4 = text("Chrome Extension (");
      t5 = text(ctx[0]);
      t6 = text(")");
      attr(span, "class", "font-extrabold");
      attr(div1, "class", "my-4");
      attr(div3, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      append(div0, t2);
      append(div2, t3);
      append(div2, div1);
      append(div1, button);
      append(button, t4);
      append(button, t5);
      append(button, t6);
      ctx[4](div1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t1, ctx2[0]);
      if (dirty & 1)
        set_data(t5, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      ctx[4](null);
      mounted = false;
      dispose();
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { clipperHref } = $$props;
  let { noteOrVault } = $$props;
  let s3LinkContainer;
  const getExtension = async () => {
    const response = await (0, import_obsidian5.requestUrl)({
      url: "https://obsidianclipper.com/api/extension",
      contentType: "application/json",
      method: "POST",
      body: JSON.stringify({
        name: noteOrVault,
        bookmarklet_code: clipperHref
      })
    });
    const s3Link = window.document.createElement("a");
    s3Link.href = response.json.data.link;
    s3Link.textContent = "Download Chrome Extension";
    s3LinkContainer.replaceChildren(s3Link);
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      s3LinkContainer = $$value;
      $$invalidate(1, s3LinkContainer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("clipperHref" in $$props2)
      $$invalidate(3, clipperHref = $$props2.clipperHref);
    if ("noteOrVault" in $$props2)
      $$invalidate(0, noteOrVault = $$props2.noteOrVault);
  };
  return [noteOrVault, s3LinkContainer, getExtension, clipperHref, div1_binding];
}
var ExtensionSettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, { clipperHref: 3, noteOrVault: 0 });
  }
};
var ExtensionSettingsGroup_default = ExtensionSettingsGroup;

// src/settings/LinksSettingsGroup.svelte
function create_if_block5(ctx) {
  let div4;
  let div2;
  let t3;
  let div3;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name">Capture Comment in Browser</div> 
				<div class="setting-item-description">Display a modal in the browser to capture any comments before sending
					to Obsidian?</div>`;
      t3 = space();
      div3 = element("div");
      input = element("input");
      attr(div2, "class", "setting-item-info");
      attr(input, "type", "checkbox");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div4, t3);
      append(div4, div3);
      append(div3, input);
      input.checked = ctx[1].captureComments;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[6]),
          listen(input, "change", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        input.checked = ctx2[1].captureComments;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment12(ctx) {
  let div0;
  let bookmarkletsettingsgroup;
  let t0;
  let extensionsettingsgroup;
  let t1;
  let div28;
  let h10;
  let t3;
  let t4;
  let div2;
  let t6;
  let div7;
  let div5;
  let t10;
  let div6;
  let input0;
  let t11;
  let div12;
  let div10;
  let t15;
  let div11;
  let input1;
  let t16;
  let div17;
  let div15;
  let t20;
  let div16;
  let input2;
  let t21;
  let div22;
  let div20;
  let t25;
  let div21;
  let input3;
  let t26;
  let div27;
  let div25;
  let t30;
  let div26;
  let input4;
  let current;
  let mounted;
  let dispose;
  bookmarkletsettingsgroup = new BookmarkletSettingsGroup_default({
    props: {
      clipperHref: ctx[0],
      noteOrVault: ctx[2]
    }
  });
  extensionsettingsgroup = new ExtensionSettingsGroup_default({
    props: {
      clipperHref: ctx[0],
      noteOrVault: ctx[2]
    }
  });
  let if_block = ctx[1].experimentalBookmarkletComment && create_if_block5(ctx);
  return {
    c() {
      div0 = element("div");
      create_component(bookmarkletsettingsgroup.$$.fragment);
      t0 = space();
      create_component(extensionsettingsgroup.$$.fragment);
      t1 = space();
      div28 = element("div");
      h10 = element("h1");
      h10.textContent = "Bookmarklet Settings";
      t3 = space();
      if (if_block)
        if_block.c();
      t4 = space();
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-info"><h1 class="setting-item-name">Markdown Headings</h1></div>`;
      t6 = space();
      div7 = element("div");
      div5 = element("div");
      div5.innerHTML = `<div class="setting-item-name">H2</div> 
			<div class="setting-item-description">What should replace H2 elements found in the highlight data?</div>`;
      t10 = space();
      div6 = element("div");
      input0 = element("input");
      t11 = space();
      div12 = element("div");
      div10 = element("div");
      div10.innerHTML = `<div class="setting-item-name">H3</div> 
			<div class="setting-item-description">What should replace H3 elements found in the highlight data?</div>`;
      t15 = space();
      div11 = element("div");
      input1 = element("input");
      t16 = space();
      div17 = element("div");
      div15 = element("div");
      div15.innerHTML = `<div class="setting-item-name">H4</div> 
			<div class="setting-item-description">What should replace H4 elements found in the highlight data?</div>`;
      t20 = space();
      div16 = element("div");
      input2 = element("input");
      t21 = space();
      div22 = element("div");
      div20 = element("div");
      div20.innerHTML = `<div class="setting-item-name">H5</div> 
			<div class="setting-item-description">What should replace H5 elements found in the highlight data?</div>`;
      t25 = space();
      div21 = element("div");
      input3 = element("input");
      t26 = space();
      div27 = element("div");
      div25 = element("div");
      div25.innerHTML = `<div class="setting-item-name">H6</div> 
			<div class="setting-item-description">What should replace H6 elements found in the highlight data?</div>`;
      t30 = space();
      div26 = element("div");
      input4 = element("input");
      attr(div0, "class", "clp_section_margin");
      attr(div2, "class", "setting-item");
      attr(div5, "class", "setting-item-info");
      attr(input0, "type", "text");
      attr(input0, "spellcheck", "false");
      attr(input0, "placeholder", "");
      attr(div6, "class", "setting-item-control");
      attr(div7, "class", "setting-item");
      attr(div10, "class", "setting-item-info");
      attr(input1, "type", "text");
      attr(input1, "spellcheck", "false");
      attr(input1, "placeholder", "");
      attr(div11, "class", "setting-item-control");
      attr(div12, "class", "setting-item");
      attr(div15, "class", "setting-item-info");
      attr(input2, "type", "text");
      attr(input2, "spellcheck", "false");
      attr(input2, "placeholder", "");
      attr(div16, "class", "setting-item-control");
      attr(div17, "class", "setting-item");
      attr(div20, "class", "setting-item-info");
      attr(input3, "type", "text");
      attr(input3, "spellcheck", "false");
      attr(input3, "placeholder", "");
      attr(div21, "class", "setting-item-control");
      attr(div22, "class", "setting-item");
      attr(div25, "class", "setting-item-info");
      attr(input4, "type", "text");
      attr(input4, "spellcheck", "false");
      attr(input4, "placeholder", "");
      attr(div26, "class", "setting-item-control");
      attr(div27, "class", "setting-item");
      attr(div28, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(bookmarkletsettingsgroup, div0, null);
      append(div0, t0);
      mount_component(extensionsettingsgroup, div0, null);
      insert(target, t1, anchor);
      insert(target, div28, anchor);
      append(div28, h10);
      append(div28, t3);
      if (if_block)
        if_block.m(div28, null);
      append(div28, t4);
      append(div28, div2);
      append(div28, t6);
      append(div28, div7);
      append(div7, div5);
      append(div7, t10);
      append(div7, div6);
      append(div6, input0);
      set_input_value(input0, ctx[1].markdownSettings.h2);
      append(div28, t11);
      append(div28, div12);
      append(div12, div10);
      append(div12, t15);
      append(div12, div11);
      append(div11, input1);
      set_input_value(input1, ctx[1].markdownSettings.h3);
      append(div28, t16);
      append(div28, div17);
      append(div17, div15);
      append(div17, t20);
      append(div17, div16);
      append(div16, input2);
      set_input_value(input2, ctx[1].markdownSettings.h4);
      append(div28, t21);
      append(div28, div22);
      append(div22, div20);
      append(div22, t25);
      append(div22, div21);
      append(div21, input3);
      set_input_value(input3, ctx[1].markdownSettings.h5);
      append(div28, t26);
      append(div28, div27);
      append(div27, div25);
      append(div27, t30);
      append(div27, div26);
      append(div26, input4);
      set_input_value(input4, ctx[1].markdownSettings.h6);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[7]),
          listen(input1, "input", ctx[8]),
          listen(input2, "input", ctx[9]),
          listen(input3, "input", ctx[10]),
          listen(input4, "input", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const bookmarkletsettingsgroup_changes = {};
      if (dirty & 1)
        bookmarkletsettingsgroup_changes.clipperHref = ctx2[0];
      bookmarkletsettingsgroup.$set(bookmarkletsettingsgroup_changes);
      const extensionsettingsgroup_changes = {};
      if (dirty & 1)
        extensionsettingsgroup_changes.clipperHref = ctx2[0];
      extensionsettingsgroup.$set(extensionsettingsgroup_changes);
      if (ctx2[1].experimentalBookmarkletComment) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          if_block.m(div28, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 2 && input0.value !== ctx2[1].markdownSettings.h2) {
        set_input_value(input0, ctx2[1].markdownSettings.h2);
      }
      if (dirty & 2 && input1.value !== ctx2[1].markdownSettings.h3) {
        set_input_value(input1, ctx2[1].markdownSettings.h3);
      }
      if (dirty & 2 && input2.value !== ctx2[1].markdownSettings.h4) {
        set_input_value(input2, ctx2[1].markdownSettings.h4);
      }
      if (dirty & 2 && input3.value !== ctx2[1].markdownSettings.h5) {
        set_input_value(input3, ctx2[1].markdownSettings.h5);
      }
      if (dirty & 2 && input4.value !== ctx2[1].markdownSettings.h6) {
        set_input_value(input4, ctx2[1].markdownSettings.h6);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(bookmarkletsettingsgroup.$$.fragment, local);
      transition_in(extensionsettingsgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bookmarkletsettingsgroup.$$.fragment, local);
      transition_out(extensionsettingsgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(bookmarkletsettingsgroup);
      destroy_component(extensionsettingsgroup);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div28);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let $settings;
  component_subscribe($$self, settings, ($$value) => $$invalidate(1, $settings = $$value));
  let { vaultName = "" } = $$props;
  let { filePath = "" } = $$props;
  let fileName = "";
  if (filePath !== "") {
    fileName = getFileName(filePath);
  }
  let noteOrVault = fileName !== "" ? `${fileName} file` : `${vaultName} vault`;
  let clipperHref = new BookmarketlGenerator(vaultName, filePath, $settings.markdownSettings, ($settings.experimentalBookmarkletComment && $settings.captureComments).toString()).generateBookmarklet();
  let updateClipperHref = () => {
    $$invalidate(0, clipperHref = new BookmarketlGenerator(vaultName, filePath, $settings.markdownSettings, ($settings.experimentalBookmarkletComment && $settings.captureComments).toString()).generateBookmarklet());
  };
  function input_change_handler() {
    $settings.captureComments = this.checked;
    settings.set($settings);
  }
  function input0_input_handler() {
    $settings.markdownSettings.h2 = this.value;
    settings.set($settings);
  }
  function input1_input_handler() {
    $settings.markdownSettings.h3 = this.value;
    settings.set($settings);
  }
  function input2_input_handler() {
    $settings.markdownSettings.h4 = this.value;
    settings.set($settings);
  }
  function input3_input_handler() {
    $settings.markdownSettings.h5 = this.value;
    settings.set($settings);
  }
  function input4_input_handler() {
    $settings.markdownSettings.h6 = this.value;
    settings.set($settings);
  }
  $$self.$$set = ($$props2) => {
    if ("vaultName" in $$props2)
      $$invalidate(4, vaultName = $$props2.vaultName);
    if ("filePath" in $$props2)
      $$invalidate(5, filePath = $$props2.filePath);
  };
  return [
    clipperHref,
    $settings,
    noteOrVault,
    updateClipperHref,
    vaultName,
    filePath,
    input_change_handler,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler,
    input4_input_handler
  ];
}
var LinksSettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, { vaultName: 4, filePath: 5 });
  }
};
var LinksSettingsGroup_default = LinksSettingsGroup;

// src/settings/AdvancedSettingsGroup.svelte
function create_if_block6(ctx) {
  let div5;
  let div4;
  let div2;
  let t3;
  let div3;
  let input;
  let div5_intro;
  let div5_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name">Clipped Entry Storage Location</div> 
					<div class="setting-item-description">Choose the folder to store all of your clippings. A note per domain
						clipped from. Default is a \`clippings\`</div>`;
      t3 = space();
      div3 = element("div");
      input = element("input");
      attr(div2, "class", "setting-item-info");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div2);
      append(div4, t3);
      append(div4, div3);
      append(div3, input);
      set_input_value(input, ctx[0].advancedStorageFolder);
      current = true;
      if (!mounted) {
        dispose = listen(input, "input", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0].advancedStorageFolder) {
        set_input_value(input, ctx2[0].advancedStorageFolder);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (div5_outro)
            div5_outro.end(1);
          div5_intro = create_in_transition(div5, slide, { duration: 300 });
          div5_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      if (div5_intro)
        div5_intro.invalidate();
      if (local) {
        div5_outro = create_out_transition(div5, slide, { duration: 300 });
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (detaching && div5_outro)
        div5_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment13(ctx) {
  let div5;
  let h10;
  let t1;
  let div4;
  let div2;
  let t5;
  let div3;
  let label0;
  let input0;
  let t6;
  let t7;
  let div13;
  let h11;
  let t9;
  let div8;
  let div6;
  let t11;
  let div7;
  let label1;
  let input1;
  let t12;
  let div12;
  let div10;
  let t16;
  let div11;
  let label2;
  let input2;
  let mounted;
  let dispose;
  let if_block = ctx[0].advanced && create_if_block6(ctx);
  return {
    c() {
      div5 = element("div");
      h10 = element("h1");
      h10.textContent = "Advanced Settings";
      t1 = space();
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<div class="setting-item-name">Store Clippings Per Domain</div> 
			<div class="setting-item-description">Creates a note per top-level domain and stores all clippings from that
				domain within it. It will add an embedded document link in your Daily
				Note.</div>`;
      t5 = space();
      div3 = element("div");
      label0 = element("label");
      input0 = element("input");
      t6 = space();
      if (if_block)
        if_block.c();
      t7 = space();
      div13 = element("div");
      h11 = element("h1");
      h11.textContent = "Experimental Settings";
      t9 = space();
      div8 = element("div");
      div6 = element("div");
      div6.innerHTML = `<h1 class="setting-item-name">Support Canvas</h1>`;
      t11 = space();
      div7 = element("div");
      label1 = element("label");
      input1 = element("input");
      t12 = space();
      div12 = element("div");
      div10 = element("div");
      div10.innerHTML = `<h1 class="setting-item-name">Comment Support in Browser</h1> 
			<div class="setting-item-description">After enabling this option, you must go to the &#39;Browser&#39; tab, update
				your settings to turn on the &#39;Capture Comment in Browser&#39; setting and
				reinstall the bookmarklet.</div>`;
      t16 = space();
      div11 = element("div");
      label2 = element("label");
      input2 = element("input");
      attr(div2, "class", "setting-item-info");
      attr(input0, "type", "checkbox");
      attr(label0, "class", "checkbox-container");
      toggle_class(label0, "is-enabled", ctx[0].advanced);
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item mod-toggle");
      attr(div5, "class", "clp_section_margin");
      attr(div6, "class", "setting-item-info");
      attr(input1, "type", "checkbox");
      attr(label1, "class", "checkbox-container");
      toggle_class(label1, "is-enabled", ctx[0].experimentalCanvas);
      attr(div7, "class", "setting-item-control");
      attr(div8, "class", "setting-item mod-toggle");
      attr(div10, "class", "setting-item-info");
      attr(input2, "type", "checkbox");
      attr(label2, "class", "checkbox-container");
      toggle_class(label2, "is-enabled", ctx[0].experimentalBookmarkletComment);
      attr(div11, "class", "setting-item-control");
      attr(div12, "class", "setting-item mod-toggle");
      set_style(div12, "border-top", "none", 1);
      attr(div13, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, h10);
      append(div5, t1);
      append(div5, div4);
      append(div4, div2);
      append(div4, t5);
      append(div4, div3);
      append(div3, label0);
      append(label0, input0);
      input0.checked = ctx[0].advanced;
      append(div5, t6);
      if (if_block)
        if_block.m(div5, null);
      insert(target, t7, anchor);
      insert(target, div13, anchor);
      append(div13, h11);
      append(div13, t9);
      append(div13, div8);
      append(div8, div6);
      append(div8, t11);
      append(div8, div7);
      append(div7, label1);
      append(label1, input1);
      input1.checked = ctx[0].experimentalCanvas;
      append(div13, t12);
      append(div13, div12);
      append(div12, div10);
      append(div12, t16);
      append(div12, div11);
      append(div11, label2);
      append(label2, input2);
      input2.checked = ctx[0].experimentalBookmarkletComment;
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[1]),
          listen(input1, "change", ctx[3]),
          listen(input2, "change", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        input0.checked = ctx2[0].advanced;
      }
      if (dirty & 1) {
        toggle_class(label0, "is-enabled", ctx2[0].advanced);
      }
      if (ctx2[0].advanced) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div5, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 1) {
        input1.checked = ctx2[0].experimentalCanvas;
      }
      if (dirty & 1) {
        toggle_class(label1, "is-enabled", ctx2[0].experimentalCanvas);
      }
      if (dirty & 1) {
        input2.checked = ctx2[0].experimentalBookmarkletComment;
      }
      if (dirty & 1) {
        toggle_class(label2, "is-enabled", ctx2[0].experimentalBookmarkletComment);
      }
    },
    i(local) {
      transition_in(if_block);
    },
    o(local) {
      transition_out(if_block);
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (if_block)
        if_block.d();
      if (detaching)
        detach(t7);
      if (detaching)
        detach(div13);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let $settings;
  component_subscribe($$self, settings, ($$value) => $$invalidate(0, $settings = $$value));
  function input0_change_handler() {
    $settings.advanced = this.checked;
    settings.set($settings);
  }
  function input_input_handler() {
    $settings.advancedStorageFolder = this.value;
    settings.set($settings);
  }
  function input1_change_handler() {
    $settings.experimentalCanvas = this.checked;
    settings.set($settings);
  }
  function input2_change_handler() {
    $settings.experimentalBookmarkletComment = this.checked;
    settings.set($settings);
  }
  return [
    $settings,
    input0_change_handler,
    input_input_handler,
    input1_change_handler,
    input2_change_handler
  ];
}
var AdvancedSettingsGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {});
  }
};
var AdvancedSettingsGroup_default = AdvancedSettingsGroup;

// src/settings/SettingsComponent.svelte
function create_noticeText_slot(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${noticeText}`;
      attr(span, "slot", "noticeText");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_calloutLink_slot(ctx) {
  let span1;
  return {
    c() {
      span1 = element("span");
      span1.innerHTML = `<a href="https://docs.obsidianclipper.com" class="whitespace-nowrap font-medium text-blue-700 hover:text-blue-600">Details
			<span aria-hidden="true">\u2192</span></a>`;
      attr(span1, "slot", "calloutLink");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span1);
    }
  };
}
function create_fragment14(ctx) {
  let notice;
  let t0;
  let br;
  let t1;
  let tabs_1;
  let current;
  notice = new Notice_default({
    props: {
      $$slots: {
        calloutLink: [create_calloutLink_slot],
        noticeText: [create_noticeText_slot]
      },
      $$scope: { ctx }
    }
  });
  tabs_1 = new Tabs_default({ props: { tabs: ctx[0] } });
  return {
    c() {
      create_component(notice.$$.fragment);
      t0 = space();
      br = element("br");
      t1 = space();
      create_component(tabs_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      insert(target, t0, anchor);
      insert(target, br, anchor);
      insert(target, t1, anchor);
      mount_component(tabs_1, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const notice_changes = {};
      if (dirty & 8) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notice.$$.fragment, local);
      transition_in(tabs_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      transition_out(tabs_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(br);
      if (detaching)
        detach(t1);
      destroy_component(tabs_1, detaching);
    }
  };
}
var noticeText = "Lost on how to get started? Check out the new documentation website";
function instance14($$self, $$props, $$invalidate) {
  let { app } = $$props;
  const vaultName = app.vault.getName();
  let tabs = [
    {
      label: "Base",
      value: 1,
      component: BaseSettingsTab_default,
      props: { app }
    },
    {
      label: "Topic Note",
      value: 2,
      component: TopicSettingsTab_default,
      props: { app }
    },
    {
      label: "Browser",
      value: 3,
      component: LinksSettingsGroup_default,
      props: { vaultName }
    },
    {
      label: "Advanced",
      value: 4,
      component: AdvancedSettingsGroup_default,
      props: { app }
    }
  ];
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(1, app = $$props2.app);
  };
  return [tabs, app];
}
var SettingsComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, { app: 1 });
  }
};
var SettingsComponent_default = SettingsComponent;

// src/modals/BookmarkletModalComponent.svelte
function create_if_block7(ctx) {
  let notice;
  let current;
  notice = new Notice_default({
    props: {
      $$slots: { noticeText: [create_noticeText_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(notice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(notice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const notice_changes = {};
      if (dirty & 9) {
        notice_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notice.$set(notice_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notice, detaching);
    }
  };
}
function create_noticeText_slot2(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[0]);
      attr(span, "slot", "noticeText");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment15(ctx) {
  let div;
  let t;
  let linkssettingsgroup;
  let current;
  let if_block = ctx[0] && create_if_block7(ctx);
  linkssettingsgroup = new LinksSettingsGroup_default({
    props: {
      vaultName: ctx[1],
      filePath: ctx[2]
    }
  });
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      create_component(linkssettingsgroup.$$.fragment);
      attr(div, "class", "clp_section_margin");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      mount_component(linkssettingsgroup, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const linkssettingsgroup_changes = {};
      if (dirty & 2)
        linkssettingsgroup_changes.vaultName = ctx2[1];
      if (dirty & 4)
        linkssettingsgroup_changes.filePath = ctx2[2];
      linkssettingsgroup.$set(linkssettingsgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(linkssettingsgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(linkssettingsgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      destroy_component(linkssettingsgroup);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { noticeText: noticeText2 } = $$props;
  let { vaultName } = $$props;
  let { filePath = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("noticeText" in $$props2)
      $$invalidate(0, noticeText2 = $$props2.noticeText);
    if ("vaultName" in $$props2)
      $$invalidate(1, vaultName = $$props2.vaultName);
    if ("filePath" in $$props2)
      $$invalidate(2, filePath = $$props2.filePath);
  };
  return [noticeText2, vaultName, filePath];
}
var BookmarkletModalComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, { noticeText: 0, vaultName: 1, filePath: 2 });
  }
};
var BookmarkletModalComponent_default = BookmarkletModalComponent;

// src/topicnoteentry.ts
var TopicNoteEntry = class extends NoteEntry {
  async writeToNote(file, noteEntry) {
    Utility.assertNotNull(file);
    this.handleWrite(file.path, await noteEntry.formattedEntry(this.template));
  }
};

// src/advancednotes/advancednoteentry.ts
var import_obsidian6 = require("obsidian");
var AdvancedNoteEntry = class extends NoteEntry {
  constructor(app, storageFolder) {
    super(app, false, SectionPosition.APPEND, "");
    this.storageFolder = storageFolder;
  }
  async writeToAdvancedNoteStorage(hostName, data, url) {
    const noteFilePath = `${this.storageFolder}/${hostName}.md`;
    const folder = this.app.vault.getAbstractFileByPath(this.storageFolder);
    let file = this.app.vault.getAbstractFileByPath(noteFilePath);
    const sectionHeader = window.moment().toISOString().replaceAll(":", "-");
    const entry = `
# ${sectionHeader} 
 ${data}
[^1] 

 [^1]: ${url}  
`;
    if (!(file instanceof import_obsidian6.TFile)) {
      if (!(folder instanceof import_obsidian6.TFolder)) {
        this.app.vault.createFolder(this.storageFolder);
        await new Promise((r) => setTimeout(r, 50));
      }
      file = await this.app.vault.create(noteFilePath, entry);
    } else {
      new AppendWriter(this.app, this.openFileOnWrite).write(file, entry);
    }
    await new Promise((r) => setTimeout(r, 50));
    if (!file) {
      const errorMessage = `Unable to create clipper storage file. Most likely ${this.storageFolder} doesn't exist and we were unable to create it.`;
      console.error(errorMessage);
      new import_obsidian6.Notice(errorMessage);
      throw Error(errorMessage);
    }
    return `![[${this.storageFolder}/${hostName}#${sectionHeader}|clipped]]`;
  }
};

// src/canvasentry.ts
var import_crypto = require("crypto");
var import_dagre = __toESM(require_dagre());
var CanvasEntry = class {
  constructor(app) {
    this.app = app;
  }
  async writeToCanvas(file, noteEntry) {
    const content = noteEntry.getEntryContent();
    Utility.assertNotNull(content);
    const fileData = await this.app.vault.read(file);
    const canvasData = JSON.parse(fileData);
    const newNode = this.createTextNode(canvasData.nodes, `${content}
[^1]

[^1](${noteEntry.getUrl()})`, {
      width: 600,
      height: 400
    });
    const domainNode = this.findDomainNodeOrCreate(canvasData, Utility.parseDomainFromUrl(noteEntry.getUrl()));
    canvasData.nodes.push(newNode);
    this.linkNewNodeToDomainNode(canvasData, domainNode, newNode);
    const layout = this.processWithDagre(canvasData);
    const nodesWithLayout = [];
    layout.nodes().forEach((element2) => {
      const nodeData = layout.node(element2);
      console.log(nodeData);
      const label = nodeData.label;
      Utility.assertNotNull(label);
      nodesWithLayout.push({
        id: element2,
        type: "text",
        text: label,
        width: nodeData.width,
        height: nodeData.height,
        x: nodeData.x,
        y: nodeData.y
      });
    });
    canvasData.nodes = nodesWithLayout;
    await this.app.vault.modify(file, JSON.stringify(canvasData));
    await new Promise((r) => setTimeout(r, 50));
  }
  findDomainNodeOrCreate(canvasData, domain) {
    if (!canvasData.nodes) {
      canvasData.nodes = [];
    }
    let domainNode = canvasData.nodes.find((node) => node.text === domain);
    if (!domainNode) {
      domainNode = this.createTextNode(canvasData.nodes, domain);
      canvasData.nodes.push(domainNode);
    }
    return domainNode;
  }
  createTextNode(nodes, content, options = { width: 240, height: 50 }) {
    const { x, y } = this.getPositionCoordinatesForNewNode(nodes);
    return {
      id: (0, import_crypto.randomUUID)(),
      type: "text",
      text: content,
      x,
      y,
      width: options.width,
      height: options.height,
      createdBy: "obsidian-clipper"
    };
  }
  getPositionCoordinatesForNewNode(nodes) {
    return { x: -1300, y: -800 };
  }
  linkNewNodeToDomainNode(canvasData, domainNode, newNode) {
    const edge = {
      id: (0, import_crypto.randomUUID)(),
      fromNode: newNode.id,
      fromSide: "top",
      toNode: domainNode.id,
      toSide: "bottom"
    };
    if (!canvasData.edges) {
      canvasData.edges = [];
    }
    canvasData.edges.push(edge);
  }
  processWithDagre(canvasData) {
    const g = new import_dagre.default.graphlib.Graph({ directed: true, multigraph: true });
    g.setGraph({});
    g.setDefaultEdgeLabel(function() {
      return {};
    });
    canvasData.nodes.forEach((node) => {
      g.setNode(node.id, {
        label: node.text,
        width: node.width,
        height: node.height,
        createdBy: node.createdBy,
        type: node.type,
        x: node.x,
        y: node.y
      });
    });
    canvasData.edges.forEach((edge) => {
      g.setEdge(edge.toNode, edge.fromNode);
    });
    import_dagre.default.layout(g, { rankdir: "lr", align: "dr", ranker: "tight-tree" });
    return g;
  }
};

// src/main.ts
var ObsidianClipperPlugin = class extends import_obsidian7.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    this.addCommand({
      id: "copy-bookmarklet-address-clipboard",
      name: "Vault Bookmarklet to Clipboard",
      callback: () => this.handleCopyBookmarkletToClipboard()
    });
    this.addCommand({
      id: "copy-bookmarklet-address",
      name: "Vault Bookmarklet",
      callback: () => this.handleCopyBookmarkletCommand()
    });
    this.addCommand({
      id: "copy-note-bookmarklet-address-clipboard",
      name: "Topic Bookmarklet to Clipboard",
      editorCallback: (_editor, ctx) => {
        var _a;
        this.handleCopyBookmarkletToClipboard((_a = ctx.file) == null ? void 0 : _a.path);
      }
    });
    this.addCommand({
      id: "copy-note-bookmarklet-address",
      name: "Topic Bookmarklet",
      editorCallback: (_editor, ctx) => {
        var _a;
        this.handleCopyBookmarkletCommand(false, (_a = ctx.file) == null ? void 0 : _a.path);
      }
    });
    this.addCommand({
      id: "copy-note-bookmarklet-address-canvas",
      name: "Canvas Bookmarklet",
      checkCallback: (checking) => {
        var _a;
        if (checking) {
          return this.settings.experimentalCanvas && ((_a = this.app.workspace.getActiveViewOfType(import_obsidian7.View)) == null ? void 0 : _a.file.extension) === "canvas";
        } else {
          const ctx = this.app.workspace.getActiveViewOfType(import_obsidian7.View);
          if (ctx) {
            this.handleCopyBookmarkletCommand(false, ctx.file.path);
          }
        }
      }
    });
    this.registerObsidianProtocolHandler("obsidian-clipper", async (e) => {
      const parameters = e;
      const url = parameters.url;
      const title = parameters.title;
      const notePath = parameters.notePath;
      const highlightData = parameters.highlightdata;
      const comments = parameters.comments;
      if (parameters.format === "html") {
        if (notePath !== "") {
          this.handleCopyBookmarkletCommand(true, notePath);
        } else {
          this.handleCopyBookmarkletCommand(true);
        }
        return;
      }
      let entryReference = highlightData;
      if (this.settings.advanced && highlightData) {
        const domain = Utility.parseDomainFromUrl(url);
        entryReference = await new AdvancedNoteEntry(this.app, this.settings.advancedStorageFolder).writeToAdvancedNoteStorage(domain, highlightData, url);
      }
      const noteEntry = new ClippedData(title, url, this.settings, this.app, entryReference, comments);
      if (notePath && notePath !== "") {
        const file = this.app.vault.getAbstractFileByPath(notePath);
        if (file.extension === "canvas") {
          new CanvasEntry(this.app).writeToCanvas(file, noteEntry);
        } else {
          new TopicNoteEntry(this.app, this.settings.topicOpenOnWrite, this.settings.topicPosition, this.settings.topicEntryTemplateLocation).writeToNote(file, noteEntry);
        }
      } else {
        if (this.settings.useDailyNote) {
          new DailyPeriodicNoteEntry(this.app, this.settings.dailyOpenOnWrite, this.settings.dailyPosition, this.settings.dailyEntryTemplateLocation).writeToPeriodicNote(noteEntry, this.settings.dailyNoteHeading);
        }
        if (this.settings.useWeeklyNote) {
          new WeeklyPeriodicNoteEntry(this.app, this.settings.weeklyOpenOnWrite, this.settings.weeklyPosition, this.settings.weeklyEntryTemplateLocation).writeToPeriodicNote(noteEntry, this.settings.weeklyNoteHeading);
        }
      }
    });
  }
  async loadSettings() {
    let mergedSettings = DEFAULT_SETTINGS;
    const settingsData = await this.loadData();
    if (settingsData !== null) {
      mergedSettings = deepmerge(DEFAULT_SETTINGS, settingsData);
    }
    this.settings = mergedSettings;
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  handleCopyBookmarkletToClipboard(notePath = "") {
    navigator.clipboard.writeText(new BookmarketlGenerator(this.app.vault.getName(), notePath, this.settings.markdownSettings, (this.settings.experimentalBookmarkletComment && this.settings.captureComments).toString()).generateBookmarklet());
    new import_obsidian7.Notice("Obsidian Clipper Bookmarklet copied to clipboard.");
  }
  handleCopyBookmarkletCommand(updateRequired = false, filePath = "") {
    let noticeText2 = "";
    if (updateRequired) {
      noticeText2 = `Notice: Your Bookmarklet is out of date and needs to be updated.
				Please Drag the link below to replace your current bookmarklet`;
    }
    const bookmarkletLinkModal = new import_obsidian7.Modal(this.app);
    bookmarkletLinkModal.titleEl.createEl("h2", {
      text: "Copy Your Bookmarklet"
    });
    new BookmarkletModalComponent_default({
      target: bookmarkletLinkModal.contentEl,
      props: {
        noticeText: noticeText2,
        vaultName: this.app.vault.getName(),
        filePath
      }
    });
    bookmarkletLinkModal.open();
  }
};
var SettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    init2(this.plugin);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.view = new SettingsComponent_default({
      target: containerEl,
      props: {
        app: this.app
      }
    });
  }
  async hide() {
    super.hide();
    this.view.$destroy();
  }
};

/* nosourcemap */