---
source: https://en.wikipedia.org/wiki/Endianness
author: []
published: 2002-03-06
created: 2025-06-19
tags:
  - concept/computer-science
---
![[~/×/627813ba41154cfa031e20dd4445a866_MD5.jpg]] ^ef7c35

Gulliver's Travels by Jonathan Swift, the novel from which the term was coined ^a0a290

In [computing](https://en.wikipedia.org/wiki/Computing "Computing"), **endianness** is the order in which [bytes](https://en.wikipedia.org/wiki/Byte "Byte") within a [word](https://en.wikipedia.org/wiki/Word_\(data_type\) "Word (data type)") of digital data are transmitted over a [data communication](https://en.wikipedia.org/wiki/Data_communication "Data communication") medium or [addressed](https://en.wikipedia.org/wiki/Memory_address "Memory address") (by rising addresses) in [computer memory](https://en.wikipedia.org/wiki/Computer_memory "Computer memory"), counting only byte [significance](https://en.wikipedia.org/wiki/Bit_numbering#Bit_significance_and_indexing "Bit numbering") compared to earliness. Endianness is primarily expressed as **big-endian** (**BE**) or **little-endian** (**LE**), terms introduced by [Danny Cohen](https://en.wikipedia.org/wiki/Danny_Cohen_\(computer_scientist\) "Danny Cohen (computer scientist)") into computer science for data ordering in an [Internet Experiment Note](https://en.wikipedia.org/wiki/Internet_Experiment_Note "Internet Experiment Note") published in 1980.[^1] The adjective *endian* has its origin in the writings of 18th century Anglo-Irish writer [Jonathan Swift](https://en.wikipedia.org/wiki/Jonathan_Swift "Jonathan Swift"). In the 1726 novel *[Gulliver's Travels](https://en.wikipedia.org/wiki/Gulliver%27s_Travels "Gulliver's Travels")*, he portrays the conflict between sects of Lilliputians divided into those breaking the shell of a [boiled egg](https://en.wikipedia.org/wiki/Boiled_egg "Boiled egg") from the big end or from the little end.[^2] [^3] By analogy, a CPU may read a digital word big end first or little end first.

Computers store information in various-sized groups of binary bits. Each group is assigned a number, called its *address*, that the computer uses to access that data. On most modern computers, the smallest data group with an address is eight bits long and is called a byte. Larger groups comprise two or more bytes, for example, a [32-bit](https://en.wikipedia.org/wiki/32-bit "32-bit") word contains four bytes. There are two principal ways a computer could number the individual bytes in a larger group, starting at either end. Both types of endianness are in widespread use in digital electronic engineering. The initial choice of endianness of a new design is often arbitrary, but later technology revisions and updates perpetuate the existing endianness to maintain [backward compatibility](https://en.wikipedia.org/wiki/Backward_compatibility "Backward compatibility").

- A **big-endian** system stores the [most significant byte](https://en.wikipedia.org/wiki/Most_significant_byte "Most significant byte") of a word at the smallest [memory address](https://en.wikipedia.org/wiki/Memory_address "Memory address") and the [least significant byte](https://en.wikipedia.org/wiki/Least_significant_byte "Least significant byte") at the largest
- A **little-endian** system, in contrast, stores the least-significant byte at the smallest address.[^4] [^5] [^6]

Of the two, **big-endian** is thus closer to the way the digits of numbers are written left-to-right in English, comparing digits to bytes. 

*Bi-endianness* is a feature supported by numerous computer architectures that feature switchable endianness in data fetches and stores or for instruction fetches. Other orderings are generically called *middle-endian* or *mixed-endian*.[^7] [^8] [^9] [^10]

**Big-endianness is the dominant ordering in networking protocols**, such as in the [Internet protocol suite](https://en.wikipedia.org/wiki/Internet_protocol_suite "Internet protocol suite"), where it is referred to as *network order*, transmitting the most significant byte first. Conversely, **little-endianness is the dominant ordering for processor architectures** ([x86](https://en.wikipedia.org/wiki/X86 "X86"), most [ARM](https://en.wikipedia.org/wiki/ARM_architecture "ARM architecture") implementations, base [RISC-V](https://en.wikipedia.org/wiki/RISC-V "RISC-V") implementations) and their associated memory. [File formats](https://en.wikipedia.org/wiki/File_format "File format") can use either ordering; some formats use a mixture of both or contain an indicator of which ordering is used throughout the file.[^11]
## Characteristics

![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/32bit-Endianess.svg/2560px-32bit-Endianess.svg.png) ^74e261

*Diagram demonstrating big- versus little-endianness*

[Computer memory](https://en.wikipedia.org/wiki/Computer_memory "Computer memory") consists of a sequence of storage cells (smallest [addressable](https://en.wikipedia.org/wiki/Address_space "Address space") units); in machines that support [byte addressing](https://en.wikipedia.org/wiki/Byte_addressing "Byte addressing"), those units are called *[bytes](https://en.wikipedia.org/wiki/Byte "Byte")*. Each byte is identified and accessed in hardware and software by its [memory address](https://en.wikipedia.org/wiki/Memory_address "Memory address"). If the total number of bytes in memory is *n*, then addresses are enumerated from 0 to *n* − 1.

Computer programs often use data structures or [fields](https://en.wikipedia.org/wiki/Field_\(computer_science\) "Field (computer science)") that may consist of more data than can be stored in one byte. In the context of this article where its type cannot be arbitrarily complicated, a "field" consists of a consecutive sequence of bytes and represents a "simple data value" which – at least potentially – can be manipulated by *one* single [hardware instruction](https://en.wikipedia.org/wiki/Instruction_set_architecture "Instruction set architecture"). On most systems, the address of a multi-byte simple data value is the address of its first byte (the byte with the lowest address). There are exceptions to this rule – for example, the Add instruction of the [IBM 1401](https://en.wikipedia.org/wiki/IBM_1401 "IBM 1401") addresses variable-length fields at their low-order (highest-addressed) position with their lengths being defined by a [word mark](https://en.wikipedia.org/wiki/Word_mark_\(computer_hardware\) "Word mark (computer hardware)") set at their high-order (lowest-addressed) position. When an operation such as addition is performed, the processor begins at the low-order positions at the high addresses of the two fields and works its way down to the high-order.

Another important attribute of a byte being part of a "field" is its "significance". These attributes of the parts of a field play an important role in the sequence the bytes are accessed by the computer hardware, more precisely: by the low-level algorithms contributing to the results of a computer instruction.

### Numbers

[Positional number systems](https://en.wikipedia.org/wiki/Positional_notation "Positional notation") (mostly base 2, or less often base 10) are the predominant way of representing and particularly of manipulating [integer data](https://en.wikipedia.org/wiki/Integer_\(computer_science\) "Integer (computer science)") by computers. In pure form this is valid for moderate sized non-negative integers, e.g. of C data type `[unsigned](https://en.wikipedia.org/wiki/Signedness "Signedness")`. In such a number system, the *value* of a digit that contributes to the whole number is determined not only by its value as a single digit, but also by the position it holds in the complete number, called its significance. These positions can be mapped to memory mainly in two ways:[^12]

- **Decreasing** numeric significance with increasing memory addresses, known as *big-endian* and
- **Increasing** numeric significance with increasing memory addresses, known as *little-endian*.

In *big-endian* and *little-endian*, the *end* is the extremity where the *big* or *little* significance is written in the location indexed by the lowest memory address.

### Text

When character (text) strings are to be compared with one another, e.g. in order to support some mechanism like [sorting](https://en.wikipedia.org/wiki/Sorting_algorithm "Sorting algorithm"), this is very frequently done [lexicographically](https://en.wikipedia.org/wiki/Lexicographically "Lexicographically") where a single positional element (character) also has a positional value. Lexicographical comparison means almost everywhere: first character ranks highest – as in the telephone book. Almost all machines which can do this using a single instruction are big-endian or at least mixed-endian.

Integer numbers written as text are always represented most significant digit first in memory, which is similar to big-endian, independently of [text direction](https://en.wikipedia.org/wiki/Text_direction "Text direction").

### Byte addressing

When memory bytes are printed sequentially from left to right (e.g. in a [hex dump](https://en.wikipedia.org/wiki/Hex_dump "Hex dump")), little-endian representation of integers has the significance increasing from right to left. In other words, it appears backwards when visualized, which can be counter-intuitive.

This behavior arises, for example, in [FourCC](https://en.wikipedia.org/wiki/FourCC "FourCC") or similar techniques that involve packing characters into an integer, so that it becomes a sequence of specific characters in memory. For example, take the string "JOHN", stored in hexadecimal [ASCII](https://en.wikipedia.org/wiki/ASCII "ASCII"). On big-endian machines, the value appears left-to-right, coinciding with the correct string order for reading the result ("J O H N"). But on a little-endian machine, one would see "N H O J". Middle-endian machines complicate this even further; for example, on the [PDP-11](https://en.wikipedia.org/wiki/PDP-11 "PDP-11"), the 32-bit value is stored as two 16-bit words "JO" "HN" in big-endian, with the characters in the 16-bit words being stored in little-endian, resulting in "O J N H".[^13]

### Byte swapping

Byte-swapping consists of rearranging bytes to change endianness. Many compilers provide [built-ins](https://en.wikipedia.org/wiki/Intrinsic_function "Intrinsic function") that are likely to be compiled into native processor instructions (`bswap` / `movbe`), such as `__builtin_bswap32`. Software interfaces for swapping include:

- Standard [network endianness](https://en.wikipedia.org/wiki/#Networking) functions (from/to BE, up to 32-bit).[^14] Windows has a 64-bit extension in `winsock2.h`.
- BSD and Glibc `endian.h` functions (from/to BE and LE, up to 64-bit).[^15]
- [macOS](https://en.wikipedia.org/wiki/MacOS "MacOS") `OSByteOrder.h` macros (from/to BE and LE, up to 64-bit).
- The `std::byteswap` function in [C++23](https://en.wikipedia.org/wiki/C%2B%2B23 "C++23").[^16]

Some [CPU](https://en.wikipedia.org/wiki/CPU "CPU") instruction sets provide native support for endian byte swapping, such as `bswap` [^17] ([x86](https://en.wikipedia.org/wiki/X86 "X86") — [486](https://en.wikipedia.org/wiki/Intel_80486 "Intel 80486") and later, [i960](https://en.wikipedia.org/wiki/I960 "I960") — i960Jx and later [^18]), and `rev` [^19] ([ARMv6](https://en.wikipedia.org/wiki/ARM_architecture "ARM architecture") and later).

Some [compilers](https://en.wikipedia.org/wiki/Compiler "Compiler") have built-in facilities for byte swapping. For example, the [Intel](https://en.wikipedia.org/wiki/Intel "Intel") [Fortran](https://en.wikipedia.org/wiki/Fortran "Fortran") compiler supports the non-standard `CONVERT` specifier when opening a file, e.g.: `OPEN(unit,CONVERT='BIG_ENDIAN',...)`. Other compilers have options for generating code that globally enables the conversion for all file IO operations. This permits the reuse of code on a system with the opposite endianness without code modification.

## Considerations

On most systems, the address of a multi-byte value is the address of its first byte (the byte with the lowest address); little-endian systems of that type have the property that, for sufficiently low data values, the same value can be read from memory at different lengths without using different addresses (even when [alignment](https://en.wikipedia.org/wiki/Byte_alignment "Byte alignment") restrictions are imposed). For example, a 32-bit memory location with content `4A 00 00 00` can be read at the same address as either [8-bit](https://en.wikipedia.org/wiki/8-bit "8-bit") (value = 4A), [16-bit](https://en.wikipedia.org/wiki/16-bit "16-bit") (004A), [24-bit](https://en.wikipedia.org/wiki/24-bit "24-bit") (00004A), or [32-bit](https://en.wikipedia.org/wiki/32-bit "32-bit") (0000004A), all of which retain the same numeric value. Although this little-endian property is rarely used directly by high-level programmers, it is occasionally employed by code optimizers as well as by [assembly language](https://en.wikipedia.org/wiki/Assembly_language "Assembly language") programmers. While not allowed by C++, such [type punning](https://en.wikipedia.org/wiki/Type_punning "Type punning") code is allowed as "implementation-defined" by the C11 standard [^20] and commonly used [^21] in code interacting with hardware.[^22]

### Calculation order

Some operations in [positional number systems](https://en.wikipedia.org/wiki/Positional_number_system "Positional number system") have a natural or preferred order in which the elementary steps are to be executed. This order may affect their performance on small-scale byte-addressable processors and [microcontrollers](https://en.wikipedia.org/wiki/Microcontroller "Microcontroller"). However, high-performance processors usually fetch multi-byte operands from memory in the same amount of time they would have fetched a single byte, so the complexity of the hardware is not affected by the byte ordering.

Addition, subtraction, and multiplication start at the least significant digit position and [propagate the carry](https://en.wikipedia.org/wiki/Adder_\(electronics\) "Adder (electronics)") to the subsequent more significant position. On most systems, the address of a multi-byte value is the address of its first byte (the byte with the lowest address). The implementation of these operations is marginally simpler using little-endian machines where this first byte contains the least significant digit.

Comparison and division start at the most significant digit and propagate a possible carry to the subsequent less significant digits. For fixed-length numerical values (typically of length 1,2,4,8,16), the implementation of these operations is marginally simpler on big-endian machines.

Some big-endian processors (e.g. the IBM System/360 and its successors) contain hardware instructions for lexicographically comparing varying length [character strings](https://en.wikipedia.org/wiki/Character_string "Character string").

The normal data transport by an [assignment](https://en.wikipedia.org/wiki/Assignment_\(computer_science\) "Assignment (computer science)") statement is in principle independent of the endianness of the processor.

## Hardware

Many historical and extant processors use a big-endian memory representation, either exclusively or as a design option. The [IBM System/360](https://en.wikipedia.org/wiki/IBM_System/360 "IBM System/360") uses big-endian byte order, as do its successors [System/370](https://en.wikipedia.org/wiki/System/370 "System/370"), [ESA/390](https://en.wikipedia.org/wiki/ESA/390 "ESA/390"), and [z/Architecture](https://en.wikipedia.org/wiki/Z/Architecture "Z/Architecture"). The [PDP-10](https://en.wikipedia.org/wiki/PDP-10 "PDP-10") uses big-endian addressing for byte-oriented instructions. The [IBM Series/1](https://en.wikipedia.org/wiki/IBM_Series/1 "IBM Series/1") minicomputer uses big-endian byte order. The Motorola [6800](https://en.wikipedia.org/wiki/Motorola_6800 "Motorola 6800") / 6801, the [6809](https://en.wikipedia.org/wiki/6809 "6809") and the [68000 series](https://en.wikipedia.org/wiki/68000_series "68000 series") of processors use the big-endian format. Solely big-endian architectures include the IBM z/Architecture and [OpenRISC](https://en.wikipedia.org/wiki/OpenRISC "OpenRISC"). The [PDP-11](https://en.wikipedia.org/wiki/PDP-11 "PDP-11") minicomputer, however, uses little-endian byte order, as does its [VAX](https://en.wikipedia.org/wiki/VAX "VAX") successor.

The [Datapoint 2200](https://en.wikipedia.org/wiki/Datapoint_2200 "Datapoint 2200") used simple bit-serial logic with little-endian to facilitate [carry propagation](https://en.wikipedia.org/wiki/Carry_propagation "Carry propagation"). When Intel developed the [8008](https://en.wikipedia.org/wiki/8008 "8008") microprocessor for Datapoint, they used little-endian for compatibility. However, as Intel was unable to deliver the 8008 in time, Datapoint used a [medium-scale integration](https://en.wikipedia.org/wiki/Medium-scale_integration "Medium-scale integration") equivalent, but the little-endianness was retained in most Intel designs, including the [MCS-48](https://en.wikipedia.org/wiki/MCS-48 "MCS-48") and the [8086](https://en.wikipedia.org/wiki/8086 "8086") and its [x86](https://en.wikipedia.org/wiki/X86 "X86") successors, including [IA-32](https://en.wikipedia.org/wiki/IA-32 "IA-32") and [x86-64](https://en.wikipedia.org/wiki/X86-64 "X86-64") processors.[^23] [^24] The [MOS Technology 6502](https://en.wikipedia.org/wiki/MOS_Technology_6502 "MOS Technology 6502") family (including [Western Design Center](https://en.wikipedia.org/wiki/Western_Design_Center "Western Design Center") [65802](https://en.wikipedia.org/wiki/65802 "65802") and [65C816](https://en.wikipedia.org/wiki/65C816 "65C816")), the Zilog [Z80](https://en.wikipedia.org/wiki/Z80 "Z80") (including [Z180](https://en.wikipedia.org/wiki/Z180 "Z180") and [eZ80](https://en.wikipedia.org/wiki/EZ80 "EZ80")), the [Altera](https://en.wikipedia.org/wiki/Altera "Altera") [Nios II](https://en.wikipedia.org/wiki/Nios_II "Nios II"), the [Atmel AVR](https://en.wikipedia.org/wiki/Atmel_AVR "Atmel AVR"), the [Andes Technology](https://en.wikipedia.org/wiki/Andes_Technology "Andes Technology") NDS32, the [Qualcomm Hexagon](https://en.wikipedia.org/wiki/Qualcomm_Hexagon "Qualcomm Hexagon"), and many other processors and processor families are also little-endian.

The Intel [8051](https://en.wikipedia.org/wiki/8051 "8051"), unlike other Intel processors, expects 16-bit addresses for LJMP and LCALL in big-endian format; however, xCALL instructions store the return address onto the stack in little-endian format.[^25]

### Bi-endianness

Some instruction set architectures feature a setting which allows for switchable endianness in data fetches and stores, instruction fetches, or both; those instruction set architectures are referred to as *bi-endian*. Architectures that support switchable endianness include [PowerPC](https://en.wikipedia.org/wiki/PowerPC "PowerPC") / [Power ISA](https://en.wikipedia.org/wiki/Power_ISA "Power ISA"), [SPARC](https://en.wikipedia.org/wiki/SPARC "SPARC") V9, [ARM](https://en.wikipedia.org/wiki/ARM_architecture "ARM architecture") versions 3 and above, [DEC Alpha](https://en.wikipedia.org/wiki/DEC_Alpha "DEC Alpha"), [MIPS](https://en.wikipedia.org/wiki/MIPS_architecture "MIPS architecture"), [Intel i860](https://en.wikipedia.org/wiki/Intel_i860 "Intel i860"), [PA-RISC](https://en.wikipedia.org/wiki/PA-RISC "PA-RISC"), [SuperH SH-4](https://en.wikipedia.org/wiki/SuperH "SuperH"), [IA-64](https://en.wikipedia.org/wiki/IA-64 "IA-64"), [C-Sky](https://en.wikipedia.org/w/index.php?title=C-Sky&action=edit&redlink=1 "C-Sky (page does not exist)"), and [RISC-V](https://en.wikipedia.org/wiki/RISC-V "RISC-V"). This feature can improve performance or simplify the logic of networking devices and software. The word *bi-endian*, when said of hardware, denotes the capability of the machine to compute or pass data in either endian format.

Many of these architectures can be switched via software to default to a specific endian format (usually done when the computer starts up); however, on some systems, the default endianness is selected by hardware on the motherboard and cannot be changed via software (e.g. Alpha, which runs only in big-endian mode on the [Cray T3E](https://en.wikipedia.org/wiki/Cray_T3E "Cray T3E")).

[IBM AIX](https://en.wikipedia.org/wiki/IBM_AIX "IBM AIX") and [IBM i](https://en.wikipedia.org/wiki/IBM_i "IBM i") run in big-endian mode on bi-endian Power ISA; [Linux](https://en.wikipedia.org/wiki/Linux "Linux") originally ran in big-endian mode, but by 2019, IBM had transitioned to little-endian mode for Linux to ease the porting of Linux software from x86 to Power.[^26] [^27] SPARC has no relevant little-endian deployment, as both [Oracle Solaris](https://en.wikipedia.org/wiki/Oracle_Solaris "Oracle Solaris") and Linux run in big-endian mode on bi-endian SPARC systems, and can be considered big-endian in practice. ARM, C-Sky, and RISC-V have no relevant big-endian deployments, and can be considered little-endian in practice.

The term *bi-endian* refers primarily to how a processor treats data accesses. Instruction accesses (fetches of instruction words) on a given processor may still assume a fixed endianness, even if data accesses are fully bi-endian, though this is not always the case, such as on Intel's [IA-64](https://en.wikipedia.org/wiki/IA-64 "IA-64") -based Itanium CPU, which allows both.

Some nominally bi-endian CPUs require motherboard help to fully switch endianness. For instance, the 32-bit desktop-oriented [PowerPC](https://en.wikipedia.org/wiki/PowerPC "PowerPC") processors in little-endian mode act as little-endian from the point of view of the executing programs, but they require the motherboard to perform a 64-bit swap across all 8 byte lanes to ensure that the little-endian view of things will apply to [I/O](https://en.wikipedia.org/wiki/I/O "I/O") devices. In the absence of this unusual motherboard hardware, device driver software must write to different addresses to undo the incomplete transformation and also must perform a normal byte swap.

Some CPUs, such as many PowerPC processors intended for embedded use and almost all SPARC processors, allow per-page choice of endianness.

SPARC processors since the late 1990s (SPARC v9 compliant processors) allow data endianness to be chosen with each individual instruction that loads from or stores to memory.

The [ARM architecture](https://en.wikipedia.org/wiki/ARM_architecture "ARM architecture") supports two big-endian modes, called *BE-8* and *BE-32*.[^28] CPUs up to ARMv5 only support BE-32 or word-invariant mode. Here any naturally aligned 32-bit access works like in little-endian mode, but access to a byte or 16-bit word is redirected to the corresponding address and unaligned access is not allowed. ARMv6 introduces BE-8 or byte-invariant mode, where access to a single byte works as in little-endian mode, but accessing a 16-bit, 32-bit or (starting with ARMv8) 64-bit word results in a byte swap of the data. This simplifies unaligned memory access as well as memory-mapped access to registers other than 32-bit.

Many processors have instructions to convert a word in a register to the opposite endianness, that is, they swap the order of the bytes in a 16-, 32- or 64-bit word.

Recent Intel x86 and x86-64 architecture CPUs have a MOVBE instruction ([Intel Core](https://en.wikipedia.org/wiki/Intel_Core "Intel Core") since generation 4, after [Atom](https://en.wikipedia.org/wiki/Intel_Atom "Intel Atom")),[^29] which fetches a big-endian format word from memory or writes a word into memory in big-endian format. These processors are otherwise thoroughly little-endian.

There are also devices which use different formats in different places. For instance, the BQ27421 [Texas Instruments](https://en.wikipedia.org/wiki/Texas_Instruments "Texas Instruments") battery gauge uses the little-endian format for its registers and the big-endian format for its [random-access memory](https://en.wikipedia.org/wiki/Random-access_memory "Random-access memory").

[SPARC](https://en.wikipedia.org/wiki/SPARC "SPARC") historically used big-endian until version 9, which is bi-endian. Similarly early IBM POWER processors were big-endian, but the [PowerPC](https://en.wikipedia.org/wiki/PowerPC "PowerPC") and [Power ISA](https://en.wikipedia.org/wiki/Power_ISA "Power ISA") descendants are now bi-endian. The [ARM architecture](https://en.wikipedia.org/wiki/ARM_architecture "ARM architecture") was little-endian before version 3 when it became bi-endian.

### Floating point

Although many processors use little-endian storage for all types of data (integer, floating point), there are a number of hardware architectures where [floating-point](https://en.wikipedia.org/wiki/Floating-point "Floating-point") numbers are represented in big-endian form while integers are represented in little-endian form.[^30] There are [ARM](https://en.wikipedia.org/wiki/ARM_architecture "ARM architecture") processors that have mixed-endian floating-point representation for double-precision numbers: each of the two 32-bit words is stored as little-endian, but the most significant word is stored first. [VAX](https://en.wikipedia.org/wiki/VAX "VAX") floating point stores little-endian 16-bit words in big-endian order. Because there have been many floating-point formats with no network standard representation for them, the [XDR](https://en.wikipedia.org/wiki/External_Data_Representation "External Data Representation") standard uses big-endian IEEE 754 as its representation. It may therefore appear strange that the widespread [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754 "IEEE 754") floating-point standard does not specify endianness.[^31] Theoretically, this means that even standard IEEE floating-point data written by one machine might not be readable by another. However, on modern standard computers (i.e., implementing IEEE 754), one may safely assume that the endianness is the same for floating-point numbers as for integers, making the conversion straightforward regardless of data type. Small [embedded systems](https://en.wikipedia.org/wiki/Embedded_system "Embedded system") using special floating-point formats may be another matter, however.

### Variable-length data

Most instructions considered so far contain the size (lengths) of their [operands](https://en.wikipedia.org/wiki/Operand "Operand") within the [operation code](https://en.wikipedia.org/wiki/Operation_code "Operation code"). Frequently available operand lengths are 1, 2, 4, 8, or 16 bytes. But there are also architectures where the length of an operand may be held in a separate field of the instruction or with the operand itself, e.g. by means of a [word mark](https://en.wikipedia.org/wiki/Word_mark_\(computer_hardware\) "Word mark (computer hardware)"). Such an approach allows operand lengths up to 256 bytes or larger. The data types of such operands are character strings or [BCD](https://en.wikipedia.org/wiki/Binary-coded_decimal "Binary-coded decimal"). Machines able to manipulate such data with one instruction (e.g. compare, add) include the [IBM 1401](https://en.wikipedia.org/wiki/IBM_1401 "IBM 1401"), [1410](https://en.wikipedia.org/wiki/IBM_1410 "IBM 1410"), [1620](https://en.wikipedia.org/wiki/IBM_1620 "IBM 1620"), [System/360](https://en.wikipedia.org/wiki/System/360 "System/360"), [System/370](https://en.wikipedia.org/wiki/System/370 "System/370"), [ESA/390](https://en.wikipedia.org/wiki/ESA/390 "ESA/390"), and [z/Architecture](https://en.wikipedia.org/wiki/Z/Architecture "Z/Architecture"), all of them of type big-endian.

### Middle-endian

Numerous other orderings, generically called *middle-endian* or *mixed-endian*, are possible.

The [PDP-11](https://en.wikipedia.org/wiki/PDP-11 "PDP-11") is in principle a 16-bit little-endian system. The instructions to convert between floating-point and integer values in the optional floating-point processor of the PDP-11/45, PDP-11/70, and in some later processors, stored 32-bit "double precision integer long" values with the 16-bit halves swapped from the expected little-endian order. The [UNIX](https://en.wikipedia.org/wiki/UNIX "UNIX") [C](https://en.wikipedia.org/wiki/C_\(programming_language\) "C (programming language)") compiler used the same format for 32-bit long integers. This ordering is known as *PDP-endian*.[^32]

UNIX was one of the first systems to allow the same code to be compiled for platforms with different internal representations. One of the first programs converted was supposed to print out `Unix`, but on the Series/1 it printed `nUxi` instead.[^13]

A way to interpret this endianness is that it stores a 32-bit integer as two little-endian 16-bit words, with a big-endian word ordering:

<table><caption>Storage of a 32-bit integer, <kbd>0x0A0B0C0D</kbd>, on a PDP-11</caption><tbody><tr><th>byte offset</th><th>8-bit value</th><th>16-bit little-endian value</th></tr><tr><th>0</th><td><kbd>0B <sub>h</sub></kbd></td><td rowspan="2"><kbd>0A0B <sub>h</sub></kbd></td></tr><tr><th>1</th><td><kbd>0A <sub>h</sub></kbd></td></tr><tr><th>2</th><td><kbd>0D <sub>h</sub></kbd></td><td rowspan="2"><kbd>0C0D <sub>h</sub></kbd></td></tr><tr><th>3</th><td><kbd>0C <sub>h</sub></kbd></td></tr></tbody></table>

[Segment descriptors](https://en.wikipedia.org/wiki/Segment_descriptors "Segment descriptors") of [IA-32](https://en.wikipedia.org/wiki/IA-32 "IA-32") and compatible processors keep a 32-bit base address of the segment stored in little-endian order, but in four nonconsecutive bytes, at relative positions 2, 3, 4 and 7 of the descriptor start.[^33]

## Software

### Logic design

[Hardware description languages](https://en.wikipedia.org/wiki/Hardware_description_language "Hardware description language") (HDLs) used to express digital logic often support arbitrary endianness, with arbitrary granularity. For example, in [SystemVerilog](https://en.wikipedia.org/wiki/SystemVerilog "SystemVerilog"), a word can be defined as little-endian or big-endian.

The recognition of endianness is important when reading a file or filesystem created on a computer with different endianness.

Fortran sequential unformatted files created with one endianness usually cannot be read on a system using the other endianness because Fortran usually implements a [record](https://en.wikipedia.org/wiki/Storage_record "Storage record") (defined as the data written by a single Fortran statement) as data preceded and succeeded by count fields, which are integers equal to the number of bytes in the data. An attempt to read such a file using Fortran on a system of the other endianness results in a run-time error, because the count fields are incorrect.

[Unicode](https://en.wikipedia.org/wiki/Unicode "Unicode") text can optionally start with a [byte order mark](https://en.wikipedia.org/wiki/Byte_order_mark "Byte order mark") (BOM) to signal the endianness of the file or stream. Its code point is U+FEFF. In [UTF-32](https://en.wikipedia.org/wiki/UTF-32 "UTF-32") for example, a big-endian file should start with `00 00 FE FF`; a little-endian should start with `FF FE 00 00`.

Application binary data formats, such as [MATLAB](https://en.wikipedia.org/wiki/MATLAB "MATLAB")*.mat* files, or the *.bil* data format, used in topography, are usually endianness-independent. This is achieved by storing the data always in one fixed endianness or carrying with the data a switch to indicate the endianness. An example of the former is the binary [XLS file](https://en.wikipedia.org/wiki/XLS_file "XLS file") format that is portable between Windows and Mac systems and always little-endian, requiring the Mac application to swap the bytes on load and save when running on a big-endian Motorola 68K or PowerPC processor.[^34]

[TIFF](https://en.wikipedia.org/wiki/TIFF "TIFF") image files are an example of the second strategy, whose header instructs the application about the endianness of their internal binary integers. If a file starts with the signature `MM` it means that integers are represented as big-endian, while `II` means little-endian. Those signatures need a single 16-bit word each, and they are [palindromes](https://en.wikipedia.org/wiki/Palindrome "Palindrome"), so they are endianness independent. `I` stands for [Intel](https://en.wikipedia.org/wiki/Intel "Intel") and `M` stands for [Motorola](https://en.wikipedia.org/wiki/Motorola "Motorola"). Intel CPUs are little-endian, while Motorola 680x0 CPUs are big-endian. This explicit signature allows a TIFF reader program to swap bytes if necessary when a given file was generated by a TIFF writer program running on a computer with a different endianness.

As a consequence of its original implementation on the Intel 8080 platform, the operating system-independent [File Allocation Table](https://en.wikipedia.org/wiki/File_Allocation_Table "File Allocation Table") (FAT) file system is defined with little-endian byte ordering, even on platforms using another endianness natively, necessitating byte-swap operations for maintaining the FAT on these platforms.

[ZFS](https://en.wikipedia.org/wiki/ZFS "ZFS"), which combines a [filesystem](https://en.wikipedia.org/wiki/Filesystem "Filesystem") and a [logical volume manager](https://en.wikipedia.org/wiki/Logical_volume_manager "Logical volume manager"), is known to provide adaptive endianness and to work with both big-endian and little-endian systems.[^35]

### Networking

Many [IETF RFCs](https://en.wikipedia.org/wiki/IETF_RFC "IETF RFC") use the term *network order*, meaning the order of transmission for bytes *over the wire* in [network protocols](https://en.wikipedia.org/wiki/Network_protocols "Network protocols"). Among others, the historic RFC [1700](https://www.rfc-editor.org/rfc/rfc1700) defines the network order for protocols in the [Internet protocol suite](https://en.wikipedia.org/wiki/Internet_protocol_suite "Internet protocol suite") to be big-endian.[^36]

However, not all protocols use big-endian byte order as the network order. The [Server Message Block](https://en.wikipedia.org/wiki/Server_Message_Block "Server Message Block") (SMB) protocol uses little-endian byte order. In [CANopen](https://en.wikipedia.org/wiki/CANopen "CANopen"), multi-byte parameters are always sent [least significant byte](https://en.wikipedia.org/wiki/Least_significant_byte "Least significant byte") first (little-endian). The same is true for [Ethernet Powerlink](https://en.wikipedia.org/wiki/Ethernet_Powerlink "Ethernet Powerlink").[^37]

The [Berkeley sockets](https://en.wikipedia.org/wiki/Berkeley_sockets "Berkeley sockets") [API](https://en.wikipedia.org/wiki/API "API") defines a set of functions to convert 16- and 32-bit integers to and from network byte order: the `htons` (host-to-network-short) and `htonl` (host-to-network-long) functions convert 16- and 32-bit values respectively from machine (*host*) to network order; the `ntohs` and `ntohl` functions convert from network to host order.[^38] [^39] These functions may be a [no-op](https://en.wikipedia.org/wiki/No-op "No-op") on a big-endian system.

While the high-level network protocols usually consider the byte (mostly meant as *[octet](https://en.wikipedia.org/wiki/Octet_\(computing\) "Octet (computing)")*) as their atomic unit, the lowest layers of a [network stack](https://en.wikipedia.org/wiki/Network_stack "Network stack") may deal with ordering of bits within a byte.

## External links

- The dictionary definition of [*endianness*](https://en.wiktionary.org/wiki/Special:Search/endianness "wiktionary:Special:Search/endianness") at Wiktionary

[^1]: [Cohen, Danny](https://en.wikipedia.org/wiki/Danny_Cohen_\(computer_scientist\) "Danny Cohen (computer scientist)") (1980-04-01). [*On Holy Wars and a Plea for Peace*](https://www.rfc-editor.org/ien/ien137.txt). [IETF](https://en.wikipedia.org/wiki/IETF "IETF"). IEN 137. Also published at Cohen, Danny (October 1981). ["On Holy Wars and a Plea for Peace"](https://ieeexplore.ieee.org/document/1667115). *IEEE Computer*. **14** (10): 48– 54. [doi](https://en.wikipedia.org/wiki/Doi_\(identifier\) "Doi (identifier)"):[10.1109/C-M.1981.220208](https://doi.org/10.1109%2FC-M.1981.220208).

[^2]: Swift, Jonathan (1726). ["A Voyage to Lilliput, Chapter IV"](https://en.wikisource.org/wiki/The_Works_of_the_Rev._Jonathan_Swift/Volume_6/A_Voyage_to_Lilliput/Chapter_4). *Gulliver's Travels*. [Archived](https://web.archive.org/web/20220920173204/https://en.wikisource.org/wiki/The_Works_of_the_Rev._Jonathan_Swift/Volume_6/A_Voyage_to_Lilliput/Chapter_4) from the original on 2022-09-20. Retrieved 2022-09-20.

[^3]: [Bryant, Randal E.](https://en.wikipedia.org/wiki/Randal_Bryant "Randal Bryant"); David, O'Hallaron (2016), *Computer Systems: A Programmer's Perspective* (3 ed.), Pearson Education, p. 79, [ISBN](https://en.wikipedia.org/wiki/ISBN_\(identifier\) "ISBN (identifier)") [978-1-488-67207-1](https://en.wikipedia.org/wiki/Special:BookSources/978-1-488-67207-1 "Special:BookSources/978-1-488-67207-1")

[^4]: ["Understanding big and little endian byte order"](https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/). *betterexplained.com*. [Archived](https://web.archive.org/web/20190524124000/https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/) from the original on 2019-05-24. Retrieved 2019-05-20.

[^5]: ["Byte Ordering PPC"](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html#//apple_ref/doc/uid/20001150-CJBEJBHH). [Archived](https://web.archive.org/web/20190509013855/https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html#//apple_ref/doc/uid/20001150-CJBEJBHH) from the original on 2019-05-09. Retrieved 2019-05-20.

[^6]: ["Writing endian-independent code in C"](https://developer.ibm.com/articles/au-endianc/). [Archived](https://web.archive.org/web/20190610085733/https://developer.ibm.com/articles/au-endianc/) from the original on 2019-06-10. Retrieved 2019-05-20.

[^7]: ["Internet Hall of Fame Pioneer"](http://internethalloffame.org/inductees/danny-cohen). *[Internet Hall of Fame](https://en.wikipedia.org/wiki/Internet_Hall_of_Fame "Internet Hall of Fame")*. [The Internet Society](https://en.wikipedia.org/wiki/The_Internet_Society "The Internet Society"). [Archived](https://web.archive.org/web/20210721114730/https://www.internethalloffame.org/inductees/danny-cohen) from the original on 2021-07-21. Retrieved 2015-10-07.

[^8]: Cary, David. ["Endian FAQ"](https://web.archive.org/web/20171109112101/http://david.carybros.com/html/endian_faq.html). Archived from [the original](http://david.carybros.com/html/endian_faq.html) on 2017-11-09. Retrieved 2010-10-11.

[^9]: James, David V. (June 1990). "Multiplexed buses: the endian wars continue". *[IEEE Micro](https://en.wikipedia.org/wiki/IEEE_Micro "IEEE Micro")*. **10** (3): 9– 21. [doi](https://en.wikipedia.org/wiki/Doi_\(identifier\) "Doi (identifier)"):[10.1109/40.56322](https://doi.org/10.1109%2F40.56322). [ISSN](https://en.wikipedia.org/wiki/ISSN_\(identifier\) "ISSN (identifier)") [0272-1732](https://search.worldcat.org/issn/0272-1732). [S2CID](https://en.wikipedia.org/wiki/S2CID_\(identifier\) "S2CID (identifier)") [24291134](https://api.semanticscholar.org/CorpusID:24291134).

[^10]: Blanc, Bertrand; Maaraoui, Bob (December 2005). ["Endianness or Where is Byte 0?"](http://3bc.bertrand-blanc.com/endianness05.pdf) (PDF). [Archived](https://web.archive.org/web/20071203190220/http://3bc.bertrand-blanc.com/endianness05.pdf) (PDF) from the original on 2007-12-03. Retrieved 2008-12-21.

[^11]: [*A File Format for the Exchange of Images in the Internet*](https://datatracker.ietf.org/doc/html/rfc1314#page-7). April 1992. p. 7. [doi](https://en.wikipedia.org/wiki/Doi_\(identifier\) "Doi (identifier)"):[10.17487/RFC1314](https://doi.org/10.17487%2FRFC1314). [RFC](https://en.wikipedia.org/wiki/Request_for_Comments "Request for Comments") [1314](https://datatracker.ietf.org/doc/html/rfc1314). Retrieved 2021-08-16.

[^12]: Tanenbaum, Andrew S.; Austin, Todd M. (4 August 2012). [*Structured Computer Organization*](https://books.google.com/books?id=m0HHygAACAAJ). Prentice Hall PTR. [ISBN](https://en.wikipedia.org/wiki/ISBN_\(identifier\) "ISBN (identifier)") [978-0-13-291652-3](https://en.wikipedia.org/wiki/Special:BookSources/978-0-13-291652-3 "Special:BookSources/978-0-13-291652-3"). Retrieved 18 May 2013.

[^13]: Jalics, Paul J.; Heines, Thomas S. (1 December 1983). ["Transporting a portable operating system: UNIX to an IBM minicomputer"](https://doi.org/10.1145%2F358476.358504). *Communications of the ACM*. **26** (12): 1066– 1072. [doi](https://en.wikipedia.org/wiki/Doi_\(identifier\) "Doi (identifier)"):[10.1145/358476.358504](https://doi.org/10.1145%2F358476.358504). [S2CID](https://en.wikipedia.org/wiki/S2CID_\(identifier\) "S2CID (identifier)") [15558835](https://api.semanticscholar.org/CorpusID:15558835).

[^14]: `[byteorder(3)](https://manned.org/byteorder.3)` – [Linux](https://en.wikipedia.org/wiki/Linux "Linux") Programmer's [Manual](https://en.wikipedia.org/wiki/Man_page "Man page") – Library Functions

[^15]: `[endian(3)](https://manned.org/endian.3)` – [Linux](https://en.wikipedia.org/wiki/Linux "Linux") Programmer's [Manual](https://en.wikipedia.org/wiki/Man_page "Man page") – Library Functions

[^16]: ["std::byteswap"](https://en.cppreference.com/w/cpp/numeric/byteswap). *en.cppreference.com*. [Archived](https://web.archive.org/web/20231120095109/https://en.cppreference.com/w/cpp/numeric/byteswap) from the original on 20 November 2023. Retrieved 3 October 2023.

[^17]: ["Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2 (2A, 2B & 2C): Instruction Set Reference, A-Z"](http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf) (PDF). Intel. September 2016. p. 3–112. [Archived](https://ghostarchive.org/archive/20221009/http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf) (PDF) from the original on 2022-10-09. Retrieved 2017-02-05.

[^18]: ["i960® VH Processor Developer's Manual"](https://datasheets.chipdb.org/Intel/80960/manuals/27317301.PDF) (PDF). Intel. October 1998. [Archived](https://web.archive.org/web/20240402165236/https://datasheets.chipdb.org/Intel/80960/manuals/27317301.PDF) (PDF) from the original on 2024-04-02. Retrieved 2024-04-02.

[^19]: ["ARMv8-A Reference Manual"](http://infocenter.arm.com/help/topic/com.arm.doc.ddi0487a.k_10775/index.html). [ARM Holdings](https://en.wikipedia.org/wiki/ARM_Holdings "ARM Holdings"). [Archived](https://web.archive.org/web/20190119214452/http://infocenter.arm.com/help/topic/com.arm.doc.ddi0487a.k_10775/index.html) from the original on 2019-01-19. Retrieved 2017-02-05.

[^20]: ["C11 standard"](https://www.iso.org/standard/57853.html). ISO. Section 6.5.2.3 "Structure and Union members", §3 and footnote 95. [Archived](https://web.archive.org/web/20200328063511/https://www.iso.org/standard/57853.html) from the original on 28 March 2020. Retrieved 15 August 2018.

[^21]: ["3.10 Options That Control Optimization: -fstrict-aliasing"](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Type-punning). *GNU Compiler Collection (GCC)*. Free Software Foundation. [Archived](https://web.archive.org/web/20230701053330/https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Type-punning) from the original on 1 July 2023. Retrieved 15 August 2018.

[^22]: Torvalds, Linus (5 Jun 2018). ["\[GIT PULL\] Device properties framework update for v4.18-rc1"](https://lkml.org/lkml/2018/6/5/769). *Linux Kernel* (Mailing list). [Archived](https://web.archive.org/web/20180815090956/https://lkml.org/lkml/2018/6/5/769) from the original on 15 August 2018. Retrieved 15 August 2018.

[^23]: House, David; Faggin, Federico; Feeney, Hal; Gelbach, Ed; Hoff, Ted; Mazor, Stan; Smith, Hank (2006-09-21). ["Oral History Panel on the Development and Promotion of the Intel 8008 Microprocessor"](http://archive.computerhistory.org/resources/text/Oral_History/Intel_8008/Intel_8008_1.oral_history.2006.102657982.pdf#page=5) (PDF). [Computer History Museum](https://en.wikipedia.org/wiki/Computer_History_Museum "Computer History Museum"). p. b5. [Archived](https://web.archive.org/web/20140629084907/http://archive.computerhistory.org/resources/text/Oral_History/Intel_8008/Intel_8008_1.oral_history.2006.102657982.pdf#page=5) (PDF) from the original on 2014-06-29. Retrieved 23 April 2014.

[^24]: Lunde, Ken (13 January 2009). [*CJKV Information Processing*](https://books.google.com/books?id=SA92uQqTB-AC&pg=PA29). O'Reilly Media, Inc. p. 29. [ISBN](https://en.wikipedia.org/wiki/ISBN_\(identifier\) "ISBN (identifier)") [978-0-596-51447-1](https://en.wikipedia.org/wiki/Special:BookSources/978-0-596-51447-1 "Special:BookSources/978-0-596-51447-1"). Retrieved 21 May 2013.

[^25]: ["Cx51 User's Guide: E. Byte Ordering"](http://www.keil.com/support/man/docs/c51/c51_xe.htm). *keil.com*. [Archived](https://web.archive.org/web/20150402094251/http://www.keil.com/support/man/docs/c51/c51_xe.htm) from the original on 2015-04-02. Retrieved 2015-03-28.

[^26]: Jeff Scheel (2016-06-16). ["Little endian and Linux on IBM Power Systems"](https://developer.ibm.com/articles/l-power-little-endian-faq-trs/). *IBM*. [Archived](https://web.archive.org/web/20220327025540/https://developer.ibm.com/articles/l-power-little-endian-faq-trs/) from the original on 2022-03-27. Retrieved 2022-03-27.

[^27]: Timothy Prickett Morgan (10 June 2019). ["The Transition To RHEL 8 Begins On Power Systems"](https://www.itjungle.com/2019/06/10/the-transition-to-rhel-8-begins-on-power-systems/). *ITJungle*. [Archived](https://web.archive.org/web/20220124063316/https://www.itjungle.com/2019/06/10/the-transition-to-rhel-8-begins-on-power-systems/) from the original on 24 January 2022. Retrieved 26 March 2022.

[^28]: ["Differences between BE-32 and BE-8 buses"](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0290g/ch06s05s01.html). [Archived](https://web.archive.org/web/20190212070549/http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0290g/ch06s05s01.html) from the original on 2019-02-12. Retrieved 2019-02-10.

[^29]: ["How to detect New Instruction support in the 4th generation Intel® Core™ processor family"](https://software.intel.com/sites/default/files/article/405250/how-to-detect-new-instruction-support-in-the-4th-generation-intel-core-processor-family.pdf) (PDF). [Archived](https://web.archive.org/web/20160320222513/https://software.intel.com/sites/default/files/article/405250/how-to-detect-new-instruction-support-in-the-4th-generation-intel-core-processor-family.pdf) (PDF) from the original on 20 March 2016. Retrieved 2 May 2017.

[^30]: Savard, John J. G. (2018) \[2005\], ["Floating-Point Formats"](http://www.quadibloc.com/comp/cp0201.htm), *quadibloc*, [archived](https://web.archive.org/web/20180703001709/http://www.quadibloc.com/comp/cp0201.htm) from the original on 2018-07-03, retrieved 2018-07-16

[^31]: ["pack – convert a list into a binary representation"](http://www.perl.com/doc/manual/html/pod/perlfunc/pack.html). [Archived](https://web.archive.org/web/20090218010333/http://perl.com/doc/manual/html/pod/perlfunc/pack.html) from the original on 2009-02-18. Retrieved 2009-02-04.

[^32]: [*PDP-11/45 Processor Handbook*](http://bitsavers.org/pdf/dec/pdp11/handbooks/PDP1145_Handbook_1973.pdf) (PDF). [Digital Equipment Corporation](https://en.wikipedia.org/wiki/Digital_Equipment_Corporation "Digital Equipment Corporation"). 1973. p. 165. [Archived](https://ghostarchive.org/archive/20221009/http://bitsavers.org/pdf/dec/pdp11/handbooks/PDP1145_Handbook_1973.pdf) (PDF) from the original on 2022-10-09.

[^33]: [*AMD64 Architecture Programmer's Manual Volume 2: System Programming*](https://web.archive.org/web/20180218024045/http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2012/10/24593_APM_v21.pdf) (PDF) (Technical report). 2013. p. 80. Archived from [the original](http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2012/10/24593_APM_v21.pdf) (PDF) on 2018-02-18.

[^34]: ["Microsoft Office Excel 97 - 2007 Binary File Format Specification (\*.xls 97-2007 format)"](http://download.microsoft.com/download/0/B/E/0BE8BDD7-E5E8-422A-ABFD-4342ED7AD886/Excel97-2007BinaryFileFormat\(xls\)Specification.xps). Microsoft Corporation. 2007. [Archived](https://web.archive.org/web/20081222093136/http://download.microsoft.com/download/0/B/E/0BE8BDD7-E5E8-422A-ABFD-4342ED7AD886/Excel97-2007BinaryFileFormat\(xls\)Specification.xps) from the original on 2008-12-22. Retrieved 2014-08-18.

[^35]: Matt Ahrens (2016). [*FreeBSD Kernel Internals: An Intensive Code Walkthrough*](http://open-zfs.org/wiki/Documentation/Read_Write_Lecture). OpenZFS Documentation/Read Write Lecture. [Archived](https://web.archive.org/web/20160414051047/http://open-zfs.org/wiki/Documentation/Read_Write_Lecture) from the original on 2016-04-14. Retrieved 2016-03-30.

[^36]: [Reynolds, J.](https://en.wikipedia.org/wiki/Joyce_K._Reynolds "Joyce K. Reynolds"); [Postel, J.](https://en.wikipedia.org/wiki/Jon_Postel "Jon Postel") (October 1994). ["Data Notations"](https://datatracker.ietf.org/doc/html/rfc1700#page-3). [*Assigned Numbers*](https://datatracker.ietf.org/doc/html/rfc1700). [IETF](https://en.wikipedia.org/wiki/IETF "IETF"). p. 3. [doi](https://en.wikipedia.org/wiki/Doi_\(identifier\) "Doi (identifier)"):[10.17487/RFC1700](https://doi.org/10.17487%2FRFC1700). STD 2. [RFC](https://en.wikipedia.org/wiki/Request_for_Comments "Request for Comments") [1700](https://datatracker.ietf.org/doc/html/rfc1700). Retrieved 2012-03-02.

[^37]: Ethernet POWERLINK Standardisation Group (2012), *EPSG Working Draft Proposal 301: Ethernet POWERLINK Communication Profile Specification Version 1.1.4*, chapter 6.1.1.

[^38]: IEEE and The Open Group (2018). "3. System Interfaces". [*The Open Group Base Specifications Issue 7*](https://pubs.opengroup.org/onlinepubs/9699919799/functions/htonl.html). Vol. 2. p. 1120. [Archived](https://web.archive.org/web/20210418041546/https://pubs.opengroup.org/onlinepubs/9699919799/functions/htonl.html) from the original on 2021-04-18. Retrieved 2021-04-09.

[^39]: ["htonl(3) - Linux man page"](https://linux.die.net/man/3/htonl). *linux.die.net*. [Archived](https://web.archive.org/web/20210418054331/https://linux.die.net/man/3/htonl) from the original on 2021-04-18. Retrieved 2021-04-09.