---
title: Learn How to Use Linux Find -printf from 50 Examples - Code Dodle
source: https://www.codedodle.com/find-printf.html
author:
  - "[[Hank Cheah]]"
published: 2021-08-25
created: 2025-01-20
description: The ultimate guide to using find -printf to customize find output.
tags:
  - clippings
  - howto
  - article
related:
  - "[[Find Command]]"
  - "[[codedoodle]]"
---
In this tutorial, you will learn how to use the GNU/Linux find utility’s printf option.

Among the functionalities that make this file searching utility so powerful is its printf option.

The printf option allows you to override the default output which is just filenames and their relative paths.

Using -printf, you can instruct `find` to show permission, owner, modification time, …, and the list goes on.

If you’re interested in finding out how to make find shows more than just the filenames, this article is for you.

In the following sections, I will go through most of the directives supported by -printf and show you the actual outputs I generated on my local machine using these directives.

As mentioned, we’ll be using the GNU find which is commonly found on GNU/Linux distros like Ubuntu, Debian, Centos, etc.

The -printf option is used in the following way:-

Where <input> can include any user-provided strings, escapes(\\), and directives(%).

Both single quotes(‘) and double quotes(“) are supported.

**Quick Links**

1. [Escapes](https://www.codedodle.com/#escapes)
2. [Name Directives](https://www.codedodle.com/#name-directives)
3. [Ownership Directives](https://www.codedodle.com/#ownership-directives)
4. [Location Directives](https://www.codedodle.com/#location-directives)
5. [Link Directives](https://www.codedodle.com/#link-directives)
6. [Time Directives](https://www.codedodle.com/#time-directives)
7. [Time Formats](https://www.codedodle.com/#time-formats)
8. [Formatting Tips](https://www.codedodle.com/#formatting-tips)
9. [Mix Matching Directives](https://www.codedodle.com/#mixing-directives)

### Escapes

In my opinion, these two are the most important escapes to remember:-

\\n – Newline

\\t – Horizontal tab

They’re pretty self-explanatory, so I won’t be providing any examples here. But you will see them in the next section.

### Directives

Using directives, you can instruct find to print almost any information pertaining to the found files.

For example, file path, access time, modified time, file size, etc.

Below I’ll provide find command examples that make use of most of the directives that are supported by find. I’ll explain them using simple words, as well as show you the outputs generated by these commands on my WSL2 Ubuntu terminal.

However, for more precise and concise explanations, please refer to the GNU manual for [find](https://www.gnu.org/software/findutils/manual/html_mono/find.html#Name-Directives).

### Name Directives

```sh
find . -printf "%p\n"
.
./wip-2-tables.sql
./subdir
./subdir/demo.txt
./month.sql
```

**%f – just filenames (basename), no paths**

```sh
find . -printf "%f\n"
.
wip-2-tables.sql
subdir
demo.txt
month.sql
```
%f prints just the last part of the file path, which is the basename. This applies to both files and directories. In the example above, subdir is a directory.

**%H – the starting point for find as specified by the user.**

For example, if two files are found under subdir/, the command would print subdir/ twice:-

Here’s another example. The command found five results so it prints the user-specified search starting point (.) five times.

**%h – this shows the matching files’ relative file paths, without the filename.**

For example, say we have these files in the directory:-

Using the %h directive would give us the following results:-

### Ownership Directives

The following printf directives deal with file ownership and file permission.

The first few directives are straightforward, so I won’t be providing any examples of them.

%g – print the file’s group name. If the file has no group name, print the group ID instead.

%G – print the file’s group ID.

%u – show the file’s owner or owner ID if the owner has no name.

%U – the ID of the file’s owner

**%m – the file permission. e.g. 777, 640, 000**

In the preceding example, %m show the file permission, \\t adds a horizontal tab, and %p prints the file paths.

**%M – file type and file permission in symbolic form**

Example:-

### Size Directives

**%k – file size in KB**

```sh
find . -printf "%k\t%p\n"
   .
   ./wip-2-tables.sql
   ./subdir
   ./subdir/demo.txt
   ./month.sql
```

- [ ] remind me (@[[2025-01-24]])

### Location Directives

**%d – file’s depth in the directory tree.**

**%D – show the device number of the device where the file resides.**

**%F – show the type of filesystem**

E.g. ext2, ext3, ext4, etc

### Location: Link Directives

Officially grouped under location directives, I found that the following directives mainly focus on links, both symbolic links and hard links.

For this section, we’ll be using the following file structure:-

src/ only contains regular files, there are no symbolic links. dst/ contains two files:-

- tgt-file-1 is a hard link of src/src-file-1
- tgt-file-2 is a symbolic link of src/src-file-2

**%l – this shows the object (origin) of the symbolic link.**

The result is empty if the file is not a symbolic link.

Since ./dst/tgt-file-2 is the only symbolic link, %l returns its source which is /home/hgcheah/linux/find/links/src/src-file-2. For other files, which include hard links, %l return empty strings.

Observe that the output looks messed up. This is because the first column (%l) has variable length.

See the [Formatting Tips](https://www.codedodle.com/#formatting-tips) section to see how to set minimum field width.

**%i – the file’s inode number.**

**%n – number of hard links to the file’s inode**

In the example above, ./dst/tgt-file-1 is a hard link of ./src/src-file-1. This means their shared inode is linked to two files and the %n directive returns 2 as the result.

**%y – file type**

f – file, d – directory, l – symbolic link, b – block device files, s – socket file, etc.

**%Y – a more inquisitive version of %y**

Where %y just prints the file type as presented, %Y does more investigative work into symbolic links. Namely, it will try to trace the links and report back if there’s any problem.

For this example, let’s focus on dst/tgt-file-2, which is a symbolic link of src/src-file-2.

Using %y from the previous section, this is the find result:-

%y returns the letter l (representing symbolic link) which is the expected outcome.

On the other hand, this is the %Y result:-

As you can see, %Y has resolved the symbolic link and found that it is linked to a file (as indicated by the letter f). Similarly, if the symbolic link was pointing to a directory, the letter d would have been shown.

%Y can also be used to show other problems a symbolic link may be having. For example, if I delete the source of the symbolic link (src/src-file-2), orphaning tgt-file-2 in the process:-

%Y shows N which means that the symbolic link is broken.

Here’s a list of possible return values for %Y:-

- file type: f, d, b, s, etc.
- N – broken link
- L – loop found
- ? – error

### Time Directives

Using printf time directives, the user can show the files’ time-related properties such as last access time  last modified time, and last status change time.

These time directives can be roughly split into two groups. Group 1 uses C ctime format. Group 2 allows you to specify your own time format (but it has to be in a format that is supported by your local strftime).

Below is the list of time directives supported by find as well as some sample outputs.

***Group 1 – C ctime format***

%a – last access time in C ctime format.

%c – last status change time in C ctime format.

%t – last modification time in C ctime format.

Here’s an example using %a. The output is similar for %c and %t.

***Group 2 – Custom format***

%Ak – last access time in format specified by k.

%Ck – last status change time in format specified by k.

%Tk – ast modification time in format specified by k.

The time format k is explained in the following section.

### Time Formats

As shown in the previous section, some time directives (%T, %C, %A) support user-specified formats.

These time formats are in conjunction with these directives in the following way:-

In the examples below, I’ll be using %T<format> which prints the modification time in various formats.

find uses format supported by strftime, so refer to strftime for the complete list of supported time formats. This implies that depending on your strftime version, the following examples may or may not be supported by your system.

Quick tip: use `man strftime` to see the list of supported time formats on your system.

**@ – seconds since the Unix Epoch**

The output is sort-friendly, but unfortunately it’s not very readable. %T+ (near the bottom of this section) provides a more readable output that is sortable.

**a – abbreviated weekday name (Sun to Sat)**

**A – full weekday name (Sunday to Saturday)** 

**b or h – abbreviated month name (Jan to Dec)**

**B – full month name (January..December)**

**m – month (01..12)**

**d – day of month (01..31)**

**w – day of week (0..6)**

0 – Sunday, 1 – Monday, …, 6 – Saturday

**j – day of year (001..366)**

**Adding in %Ta to show the weekday.**

**U – week number of year with Sunday as first day of week (00 to 53)**

**W – week number of year with Monday as first day of week (00 to 53)**

**Y – year (1970…)**

**y – last two digits of year (00 to 99)**

**r – time in 12-hour format (hh:mm:ss \[AP\]M)**

**T – time in 24-hour format (hh:mm:ss.xxxxxxxxxx)**

**X – locale time (hh:mm:ss.xxxxxxxxxx)**

**c – locale time in ctime format**

**D – date (mm/dd/yy)**

**F – date (yyyy-mm-dd)**

**x – locale date (mm/dd/yy)**

**R – hour and minute in 24 hour format (HH:MM)**

**\+ both date and time, separated by ’+’**

Show both date and time down to the fractional seconds. Format: yyyy-mm-dd+hh:mm:ss.xxxxxxxxxx

This is a sort-friendly format.

Sort the results in ascending order (oldest file at the top, newest file at the bottom) by piping the results to sort.

Similar commands can be used to find [recently modified files](https://www.codedodle.com/recently-modified-files-linux.html).

To sort the results in descending order (newest file at the top, oldest file at the bottom), use sort -r to reverse the sort order.

### Formatting Tips

Specify minimum field width for a directive by adding a number between % and the letter of the directive.

For instance, say you’re using %TA to show the weekday. You can specify the min width to 15 by adding a 15 between % and TA, like this %15TA.

This is extremely useful when you use a directive like %TA which has variable length. It keeps the results tidy and readable.

In the example above, the weekday column is right-aligned. To change the alignment to left align, just add a minus sign (-) in front of the field width.

### Mix Matching Directives

Using the directives described above, you can customize find’s results in a way that is useful to you. Here are some examples.

1\. Show the last modified time, weekday, and permission for all files (files only). Sort the results such that the most recently changed files are at the bottom.

2\. For all directories under the current directory, print the depth, file path, owner, group, permission, and modification date.

## Linux Find Tutorials

[Find: files modified between X and Y days ago](https://www.codedodle.com/files-modified-between-xy-days.html)

[Find: recently modified files](https://www.codedodle.com/recently-modified-files-linux.html)

[Find: printf](https://www.codedodle.com/find-printf.html)