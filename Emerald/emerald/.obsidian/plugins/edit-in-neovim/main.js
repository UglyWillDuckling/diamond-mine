/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@msgpack/msgpack/dist/utils/int.js
var require_int = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUint64 = exports.getInt64 = exports.setInt64 = exports.setUint64 = exports.UINT32_MAX = void 0;
    exports.UINT32_MAX = 4294967295;
    function setUint64(view, offset, value) {
      const high = value / 4294967296;
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports.setUint64 = setUint64;
    function setInt64(view, offset, value) {
      const high = Math.floor(value / 4294967296);
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports.setInt64 = setInt64;
    function getInt64(view, offset) {
      const high = view.getInt32(offset);
      const low = view.getUint32(offset + 4);
      return high * 4294967296 + low;
    }
    exports.getInt64 = getInt64;
    function getUint64(view, offset) {
      const high = view.getUint32(offset);
      const low = view.getUint32(offset + 4);
      return high * 4294967296 + low;
    }
    exports.getUint64 = getUint64;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/utf8.js
var require_utf8 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/utf8.js"(exports) {
    "use strict";
    var _a;
    var _b;
    var _c;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utf8DecodeTD = exports.TEXT_DECODER_THRESHOLD = exports.utf8DecodeJs = exports.utf8EncodeTE = exports.TEXT_ENCODER_THRESHOLD = exports.utf8EncodeJs = exports.utf8Count = void 0;
    var int_1 = require_int();
    var TEXT_ENCODING_AVAILABLE = (typeof process === "undefined" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a["TEXT_ENCODING"]) !== "never") && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
    function utf8Count(str) {
      const strLength = str.length;
      let byteLength = 0;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          byteLength++;
          continue;
        } else if ((value & 4294965248) === 0) {
          byteLength += 2;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            byteLength += 3;
          } else {
            byteLength += 4;
          }
        }
      }
      return byteLength;
    }
    exports.utf8Count = utf8Count;
    function utf8EncodeJs(str, output, outputOffset) {
      const strLength = str.length;
      let offset = outputOffset;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          output[offset++] = value;
          continue;
        } else if ((value & 4294965248) === 0) {
          output[offset++] = value >> 6 & 31 | 192;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            output[offset++] = value >> 12 & 15 | 224;
            output[offset++] = value >> 6 & 63 | 128;
          } else {
            output[offset++] = value >> 18 & 7 | 240;
            output[offset++] = value >> 12 & 63 | 128;
            output[offset++] = value >> 6 & 63 | 128;
          }
        }
        output[offset++] = value & 63 | 128;
      }
    }
    exports.utf8EncodeJs = utf8EncodeJs;
    var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;
    exports.TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? int_1.UINT32_MAX : typeof process !== "undefined" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b["TEXT_ENCODING"]) !== "force" ? 200 : 0;
    function utf8EncodeTEencode(str, output, outputOffset) {
      output.set(sharedTextEncoder.encode(str), outputOffset);
    }
    function utf8EncodeTEencodeInto(str, output, outputOffset) {
      sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
    }
    exports.utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;
    var CHUNK_SIZE = 4096;
    function utf8DecodeJs(bytes, inputOffset, byteLength) {
      let offset = inputOffset;
      const end = offset + byteLength;
      const units = [];
      let result = "";
      while (offset < end) {
        const byte1 = bytes[offset++];
        if ((byte1 & 128) === 0) {
          units.push(byte1);
        } else if ((byte1 & 224) === 192) {
          const byte2 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 6 | byte2);
        } else if ((byte1 & 240) === 224) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
        } else if ((byte1 & 248) === 240) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          const byte4 = bytes[offset++] & 63;
          let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (unit > 65535) {
            unit -= 65536;
            units.push(unit >>> 10 & 1023 | 55296);
            unit = 56320 | unit & 1023;
          }
          units.push(unit);
        } else {
          units.push(byte1);
        }
        if (units.length >= CHUNK_SIZE) {
          result += String.fromCharCode(...units);
          units.length = 0;
        }
      }
      if (units.length > 0) {
        result += String.fromCharCode(...units);
      }
      return result;
    }
    exports.utf8DecodeJs = utf8DecodeJs;
    var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
    exports.TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? int_1.UINT32_MAX : typeof process !== "undefined" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c["TEXT_DECODER"]) !== "force" ? 200 : 0;
    function utf8DecodeTD(bytes, inputOffset, byteLength) {
      const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
      return sharedTextDecoder.decode(stringBytes);
    }
    exports.utf8DecodeTD = utf8DecodeTD;
  }
});

// node_modules/@msgpack/msgpack/dist/ExtData.js
var require_ExtData = __commonJS({
  "node_modules/@msgpack/msgpack/dist/ExtData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtData = void 0;
    var ExtData = class {
      constructor(type, data) {
        this.type = type;
        this.data = data;
      }
    };
    exports.ExtData = ExtData;
  }
});

// node_modules/@msgpack/msgpack/dist/DecodeError.js
var require_DecodeError = __commonJS({
  "node_modules/@msgpack/msgpack/dist/DecodeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecodeError = void 0;
    var DecodeError = class extends Error {
      constructor(message) {
        super(message);
        const proto = Object.create(DecodeError.prototype);
        Object.setPrototypeOf(this, proto);
        Object.defineProperty(this, "name", {
          configurable: true,
          enumerable: false,
          value: DecodeError.name
        });
      }
    };
    exports.DecodeError = DecodeError;
  }
});

// node_modules/@msgpack/msgpack/dist/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/@msgpack/msgpack/dist/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timestampExtension = exports.decodeTimestampExtension = exports.decodeTimestampToTimeSpec = exports.encodeTimestampExtension = exports.encodeDateToTimeSpec = exports.encodeTimeSpecToTimestamp = exports.EXT_TIMESTAMP = void 0;
    var DecodeError_1 = require_DecodeError();
    var int_1 = require_int();
    exports.EXT_TIMESTAMP = -1;
    var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
    var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
    function encodeTimeSpecToTimestamp({ sec, nsec }) {
      if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
          const rv = new Uint8Array(4);
          const view = new DataView(rv.buffer);
          view.setUint32(0, sec);
          return rv;
        } else {
          const secHigh = sec / 4294967296;
          const secLow = sec & 4294967295;
          const rv = new Uint8Array(8);
          const view = new DataView(rv.buffer);
          view.setUint32(0, nsec << 2 | secHigh & 3);
          view.setUint32(4, secLow);
          return rv;
        }
      } else {
        const rv = new Uint8Array(12);
        const view = new DataView(rv.buffer);
        view.setUint32(0, nsec);
        (0, int_1.setInt64)(view, 4, sec);
        return rv;
      }
    }
    exports.encodeTimeSpecToTimestamp = encodeTimeSpecToTimestamp;
    function encodeDateToTimeSpec(date) {
      const msec = date.getTime();
      const sec = Math.floor(msec / 1e3);
      const nsec = (msec - sec * 1e3) * 1e6;
      const nsecInSec = Math.floor(nsec / 1e9);
      return {
        sec: sec + nsecInSec,
        nsec: nsec - nsecInSec * 1e9
      };
    }
    exports.encodeDateToTimeSpec = encodeDateToTimeSpec;
    function encodeTimestampExtension(object) {
      if (object instanceof Date) {
        const timeSpec = encodeDateToTimeSpec(object);
        return encodeTimeSpecToTimestamp(timeSpec);
      } else {
        return null;
      }
    }
    exports.encodeTimestampExtension = encodeTimestampExtension;
    function decodeTimestampToTimeSpec(data) {
      const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
      switch (data.byteLength) {
        case 4: {
          const sec = view.getUint32(0);
          const nsec = 0;
          return { sec, nsec };
        }
        case 8: {
          const nsec30AndSecHigh2 = view.getUint32(0);
          const secLow32 = view.getUint32(4);
          const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
          const nsec = nsec30AndSecHigh2 >>> 2;
          return { sec, nsec };
        }
        case 12: {
          const sec = (0, int_1.getInt64)(view, 4);
          const nsec = view.getUint32(0);
          return { sec, nsec };
        }
        default:
          throw new DecodeError_1.DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
      }
    }
    exports.decodeTimestampToTimeSpec = decodeTimestampToTimeSpec;
    function decodeTimestampExtension(data) {
      const timeSpec = decodeTimestampToTimeSpec(data);
      return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
    }
    exports.decodeTimestampExtension = decodeTimestampExtension;
    exports.timestampExtension = {
      type: exports.EXT_TIMESTAMP,
      encode: encodeTimestampExtension,
      decode: decodeTimestampExtension
    };
  }
});

// node_modules/@msgpack/msgpack/dist/ExtensionCodec.js
var require_ExtensionCodec = __commonJS({
  "node_modules/@msgpack/msgpack/dist/ExtensionCodec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtensionCodec = void 0;
    var ExtData_1 = require_ExtData();
    var timestamp_1 = require_timestamp();
    var ExtensionCodec = class {
      constructor() {
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        this.encoders = [];
        this.decoders = [];
        this.register(timestamp_1.timestampExtension);
      }
      register({ type, encode, decode }) {
        if (type >= 0) {
          this.encoders[type] = encode;
          this.decoders[type] = decode;
        } else {
          const index = 1 + type;
          this.builtInEncoders[index] = encode;
          this.builtInDecoders[index] = decode;
        }
      }
      tryToEncode(object, context) {
        for (let i = 0; i < this.builtInEncoders.length; i++) {
          const encodeExt = this.builtInEncoders[i];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = -1 - i;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        for (let i = 0; i < this.encoders.length; i++) {
          const encodeExt = this.encoders[i];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = i;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        if (object instanceof ExtData_1.ExtData) {
          return object;
        }
        return null;
      }
      decode(data, type, context) {
        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
          return decodeExt(data, type, context);
        } else {
          return new ExtData_1.ExtData(type, data);
        }
      }
    };
    exports.ExtensionCodec = ExtensionCodec;
    ExtensionCodec.defaultCodec = new ExtensionCodec();
  }
});

// node_modules/@msgpack/msgpack/dist/utils/typedArrays.js
var require_typedArrays = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/typedArrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDataView = exports.ensureUint8Array = void 0;
    function ensureUint8Array(buffer) {
      if (buffer instanceof Uint8Array) {
        return buffer;
      } else if (ArrayBuffer.isView(buffer)) {
        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      } else if (buffer instanceof ArrayBuffer) {
        return new Uint8Array(buffer);
      } else {
        return Uint8Array.from(buffer);
      }
    }
    exports.ensureUint8Array = ensureUint8Array;
    function createDataView(buffer) {
      if (buffer instanceof ArrayBuffer) {
        return new DataView(buffer);
      }
      const bufferView = ensureUint8Array(buffer);
      return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    }
    exports.createDataView = createDataView;
  }
});

// node_modules/@msgpack/msgpack/dist/Encoder.js
var require_Encoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/Encoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Encoder = exports.DEFAULT_INITIAL_BUFFER_SIZE = exports.DEFAULT_MAX_DEPTH = void 0;
    var utf8_1 = require_utf8();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var typedArrays_1 = require_typedArrays();
    exports.DEFAULT_MAX_DEPTH = 100;
    exports.DEFAULT_INITIAL_BUFFER_SIZE = 2048;
    var Encoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxDepth = exports.DEFAULT_MAX_DEPTH, initialBufferSize = exports.DEFAULT_INITIAL_BUFFER_SIZE, sortKeys = false, forceFloat32 = false, ignoreUndefined = false, forceIntegerToFloat = false) {
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxDepth = maxDepth;
        this.initialBufferSize = initialBufferSize;
        this.sortKeys = sortKeys;
        this.forceFloat32 = forceFloat32;
        this.ignoreUndefined = ignoreUndefined;
        this.forceIntegerToFloat = forceIntegerToFloat;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
      }
      reinitializeState() {
        this.pos = 0;
      }
      /**
       * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
       *
       * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
       */
      encodeSharedRef(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.subarray(0, this.pos);
      }
      /**
       * @returns Encodes the object and returns a copy of the encoder's internal buffer.
       */
      encode(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.slice(0, this.pos);
      }
      doEncode(object, depth) {
        if (depth > this.maxDepth) {
          throw new Error(`Too deep objects in depth ${depth}`);
        }
        if (object == null) {
          this.encodeNil();
        } else if (typeof object === "boolean") {
          this.encodeBoolean(object);
        } else if (typeof object === "number") {
          this.encodeNumber(object);
        } else if (typeof object === "string") {
          this.encodeString(object);
        } else {
          this.encodeObject(object, depth);
        }
      }
      ensureBufferSizeToWrite(sizeToWrite) {
        const requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
          this.resizeBuffer(requiredSize * 2);
        }
      }
      resizeBuffer(newSize) {
        const newBuffer = new ArrayBuffer(newSize);
        const newBytes = new Uint8Array(newBuffer);
        const newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
      }
      encodeNil() {
        this.writeU8(192);
      }
      encodeBoolean(object) {
        if (object === false) {
          this.writeU8(194);
        } else {
          this.writeU8(195);
        }
      }
      encodeNumber(object) {
        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
          if (object >= 0) {
            if (object < 128) {
              this.writeU8(object);
            } else if (object < 256) {
              this.writeU8(204);
              this.writeU8(object);
            } else if (object < 65536) {
              this.writeU8(205);
              this.writeU16(object);
            } else if (object < 4294967296) {
              this.writeU8(206);
              this.writeU32(object);
            } else {
              this.writeU8(207);
              this.writeU64(object);
            }
          } else {
            if (object >= -32) {
              this.writeU8(224 | object + 32);
            } else if (object >= -128) {
              this.writeU8(208);
              this.writeI8(object);
            } else if (object >= -32768) {
              this.writeU8(209);
              this.writeI16(object);
            } else if (object >= -2147483648) {
              this.writeU8(210);
              this.writeI32(object);
            } else {
              this.writeU8(211);
              this.writeI64(object);
            }
          }
        } else {
          if (this.forceFloat32) {
            this.writeU8(202);
            this.writeF32(object);
          } else {
            this.writeU8(203);
            this.writeF64(object);
          }
        }
      }
      writeStringHeader(byteLength) {
        if (byteLength < 32) {
          this.writeU8(160 + byteLength);
        } else if (byteLength < 256) {
          this.writeU8(217);
          this.writeU8(byteLength);
        } else if (byteLength < 65536) {
          this.writeU8(218);
          this.writeU16(byteLength);
        } else if (byteLength < 4294967296) {
          this.writeU8(219);
          this.writeU32(byteLength);
        } else {
          throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
        }
      }
      encodeString(object) {
        const maxHeaderSize = 1 + 4;
        const strLength = object.length;
        if (strLength > utf8_1.TEXT_ENCODER_THRESHOLD) {
          const byteLength = (0, utf8_1.utf8Count)(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          (0, utf8_1.utf8EncodeTE)(object, this.bytes, this.pos);
          this.pos += byteLength;
        } else {
          const byteLength = (0, utf8_1.utf8Count)(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          (0, utf8_1.utf8EncodeJs)(object, this.bytes, this.pos);
          this.pos += byteLength;
        }
      }
      encodeObject(object, depth) {
        const ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
          this.encodeExtension(ext);
        } else if (Array.isArray(object)) {
          this.encodeArray(object, depth);
        } else if (ArrayBuffer.isView(object)) {
          this.encodeBinary(object);
        } else if (typeof object === "object") {
          this.encodeMap(object, depth);
        } else {
          throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
        }
      }
      encodeBinary(object) {
        const size = object.byteLength;
        if (size < 256) {
          this.writeU8(196);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(197);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(198);
          this.writeU32(size);
        } else {
          throw new Error(`Too large binary: ${size}`);
        }
        const bytes = (0, typedArrays_1.ensureUint8Array)(object);
        this.writeU8a(bytes);
      }
      encodeArray(object, depth) {
        const size = object.length;
        if (size < 16) {
          this.writeU8(144 + size);
        } else if (size < 65536) {
          this.writeU8(220);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(221);
          this.writeU32(size);
        } else {
          throw new Error(`Too large array: ${size}`);
        }
        for (const item of object) {
          this.doEncode(item, depth + 1);
        }
      }
      countWithoutUndefined(object, keys) {
        let count = 0;
        for (const key of keys) {
          if (object[key] !== void 0) {
            count++;
          }
        }
        return count;
      }
      encodeMap(object, depth) {
        const keys = Object.keys(object);
        if (this.sortKeys) {
          keys.sort();
        }
        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
          this.writeU8(128 + size);
        } else if (size < 65536) {
          this.writeU8(222);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(223);
          this.writeU32(size);
        } else {
          throw new Error(`Too large map object: ${size}`);
        }
        for (const key of keys) {
          const value = object[key];
          if (!(this.ignoreUndefined && value === void 0)) {
            this.encodeString(key);
            this.doEncode(value, depth + 1);
          }
        }
      }
      encodeExtension(ext) {
        const size = ext.data.length;
        if (size === 1) {
          this.writeU8(212);
        } else if (size === 2) {
          this.writeU8(213);
        } else if (size === 4) {
          this.writeU8(214);
        } else if (size === 8) {
          this.writeU8(215);
        } else if (size === 16) {
          this.writeU8(216);
        } else if (size < 256) {
          this.writeU8(199);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(200);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(201);
          this.writeU32(size);
        } else {
          throw new Error(`Too large extension object: ${size}`);
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
      }
      writeU8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
      }
      writeU8a(values) {
        const size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
      }
      writeI8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
      }
      writeU16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
      }
      writeI16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
      }
      writeU32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
      }
      writeI32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
      }
      writeF32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
      }
      writeF64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
      }
      writeU64(value) {
        this.ensureBufferSizeToWrite(8);
        (0, int_1.setUint64)(this.view, this.pos, value);
        this.pos += 8;
      }
      writeI64(value) {
        this.ensureBufferSizeToWrite(8);
        (0, int_1.setInt64)(this.view, this.pos, value);
        this.pos += 8;
      }
    };
    exports.Encoder = Encoder;
  }
});

// node_modules/@msgpack/msgpack/dist/encode.js
var require_encode = __commonJS({
  "node_modules/@msgpack/msgpack/dist/encode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = void 0;
    var Encoder_1 = require_Encoder();
    var defaultEncodeOptions = {};
    function encode(value, options = defaultEncodeOptions) {
      const encoder = new Encoder_1.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
      return encoder.encodeSharedRef(value);
    }
    exports.encode = encode;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/prettyByte.js
var require_prettyByte = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/prettyByte.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prettyByte = void 0;
    function prettyByte(byte) {
      return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
    }
    exports.prettyByte = prettyByte;
  }
});

// node_modules/@msgpack/msgpack/dist/CachedKeyDecoder.js
var require_CachedKeyDecoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/CachedKeyDecoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CachedKeyDecoder = void 0;
    var utf8_1 = require_utf8();
    var DEFAULT_MAX_KEY_LENGTH = 16;
    var DEFAULT_MAX_LENGTH_PER_KEY = 16;
    var CachedKeyDecoder = class {
      constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.hit = 0;
        this.miss = 0;
        this.caches = [];
        for (let i = 0; i < this.maxKeyLength; i++) {
          this.caches.push([]);
        }
      }
      canBeCached(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
      }
      find(bytes, inputOffset, byteLength) {
        const records = this.caches[byteLength - 1];
        FIND_CHUNK:
          for (const record of records) {
            const recordBytes = record.bytes;
            for (let j = 0; j < byteLength; j++) {
              if (recordBytes[j] !== bytes[inputOffset + j]) {
                continue FIND_CHUNK;
              }
            }
            return record.str;
          }
        return null;
      }
      store(bytes, value) {
        const records = this.caches[bytes.length - 1];
        const record = { bytes, str: value };
        if (records.length >= this.maxLengthPerKey) {
          records[Math.random() * records.length | 0] = record;
        } else {
          records.push(record);
        }
      }
      decode(bytes, inputOffset, byteLength) {
        const cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
          this.hit++;
          return cachedValue;
        }
        this.miss++;
        const str = (0, utf8_1.utf8DecodeJs)(bytes, inputOffset, byteLength);
        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
      }
    };
    exports.CachedKeyDecoder = CachedKeyDecoder;
  }
});

// node_modules/@msgpack/msgpack/dist/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/Decoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decoder = exports.DataViewIndexOutOfBoundsError = void 0;
    var prettyByte_1 = require_prettyByte();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var utf8_1 = require_utf8();
    var typedArrays_1 = require_typedArrays();
    var CachedKeyDecoder_1 = require_CachedKeyDecoder();
    var DecodeError_1 = require_DecodeError();
    var isValidMapKeyType = (key) => {
      const keyType = typeof key;
      return keyType === "string" || keyType === "number";
    };
    var HEAD_BYTE_REQUIRED = -1;
    var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
    var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
    exports.DataViewIndexOutOfBoundsError = (() => {
      try {
        EMPTY_VIEW.getInt8(0);
      } catch (e) {
        return e.constructor;
      }
      throw new Error("never reached");
    })();
    var MORE_DATA = new exports.DataViewIndexOutOfBoundsError("Insufficient data");
    var sharedCachedKeyDecoder = new CachedKeyDecoder_1.CachedKeyDecoder();
    var Decoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxStrLength = int_1.UINT32_MAX, maxBinLength = int_1.UINT32_MAX, maxArrayLength = int_1.UINT32_MAX, maxMapLength = int_1.UINT32_MAX, maxExtLength = int_1.UINT32_MAX, keyDecoder = sharedCachedKeyDecoder) {
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxStrLength = maxStrLength;
        this.maxBinLength = maxBinLength;
        this.maxArrayLength = maxArrayLength;
        this.maxMapLength = maxMapLength;
        this.maxExtLength = maxExtLength;
        this.keyDecoder = keyDecoder;
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = [];
      }
      reinitializeState() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.length = 0;
      }
      setBuffer(buffer) {
        this.bytes = (0, typedArrays_1.ensureUint8Array)(buffer);
        this.view = (0, typedArrays_1.createDataView)(this.bytes);
        this.pos = 0;
      }
      appendBuffer(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
          this.setBuffer(buffer);
        } else {
          const remainingData = this.bytes.subarray(this.pos);
          const newData = (0, typedArrays_1.ensureUint8Array)(buffer);
          const newBuffer = new Uint8Array(remainingData.length + newData.length);
          newBuffer.set(remainingData);
          newBuffer.set(newData, remainingData.length);
          this.setBuffer(newBuffer);
        }
      }
      hasRemaining(size) {
        return this.view.byteLength - this.pos >= size;
      }
      createExtraByteError(posToShow) {
        const { view, pos } = this;
        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
      }
      /**
       * @throws {@link DecodeError}
       * @throws {@link RangeError}
       */
      decode(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        const object = this.doDecodeSync();
        if (this.hasRemaining(1)) {
          throw this.createExtraByteError(this.pos);
        }
        return object;
      }
      *decodeMulti(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        while (this.hasRemaining(1)) {
          yield this.doDecodeSync();
        }
      }
      async decodeAsync(stream) {
        let decoded = false;
        let object;
        for await (const buffer of stream) {
          if (decoded) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          try {
            object = this.doDecodeSync();
            decoded = true;
          } catch (e) {
            if (!(e instanceof exports.DataViewIndexOutOfBoundsError)) {
              throw e;
            }
          }
          this.totalPos += this.pos;
        }
        if (decoded) {
          if (this.hasRemaining(1)) {
            throw this.createExtraByteError(this.totalPos);
          }
          return object;
        }
        const { headByte, pos, totalPos } = this;
        throw new RangeError(`Insufficient data in parsing ${(0, prettyByte_1.prettyByte)(headByte)} at ${totalPos} (${pos} in the current buffer)`);
      }
      decodeArrayStream(stream) {
        return this.decodeMultiAsync(stream, true);
      }
      decodeStream(stream) {
        return this.decodeMultiAsync(stream, false);
      }
      async *decodeMultiAsync(stream, isArray) {
        let isArrayHeaderRequired = isArray;
        let arrayItemsLeft = -1;
        for await (const buffer of stream) {
          if (isArray && arrayItemsLeft === 0) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          if (isArrayHeaderRequired) {
            arrayItemsLeft = this.readArraySize();
            isArrayHeaderRequired = false;
            this.complete();
          }
          try {
            while (true) {
              yield this.doDecodeSync();
              if (--arrayItemsLeft === 0) {
                break;
              }
            }
          } catch (e) {
            if (!(e instanceof exports.DataViewIndexOutOfBoundsError)) {
              throw e;
            }
          }
          this.totalPos += this.pos;
        }
      }
      doDecodeSync() {
        DECODE:
          while (true) {
            const headByte = this.readHeadByte();
            let object;
            if (headByte >= 224) {
              object = headByte - 256;
            } else if (headByte < 192) {
              if (headByte < 128) {
                object = headByte;
              } else if (headByte < 144) {
                const size = headByte - 128;
                if (size !== 0) {
                  this.pushMapState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = {};
                }
              } else if (headByte < 160) {
                const size = headByte - 144;
                if (size !== 0) {
                  this.pushArrayState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = [];
                }
              } else {
                const byteLength = headByte - 160;
                object = this.decodeUtf8String(byteLength, 0);
              }
            } else if (headByte === 192) {
              object = null;
            } else if (headByte === 194) {
              object = false;
            } else if (headByte === 195) {
              object = true;
            } else if (headByte === 202) {
              object = this.readF32();
            } else if (headByte === 203) {
              object = this.readF64();
            } else if (headByte === 204) {
              object = this.readU8();
            } else if (headByte === 205) {
              object = this.readU16();
            } else if (headByte === 206) {
              object = this.readU32();
            } else if (headByte === 207) {
              object = this.readU64();
            } else if (headByte === 208) {
              object = this.readI8();
            } else if (headByte === 209) {
              object = this.readI16();
            } else if (headByte === 210) {
              object = this.readI32();
            } else if (headByte === 211) {
              object = this.readI64();
            } else if (headByte === 217) {
              const byteLength = this.lookU8();
              object = this.decodeUtf8String(byteLength, 1);
            } else if (headByte === 218) {
              const byteLength = this.lookU16();
              object = this.decodeUtf8String(byteLength, 2);
            } else if (headByte === 219) {
              const byteLength = this.lookU32();
              object = this.decodeUtf8String(byteLength, 4);
            } else if (headByte === 220) {
              const size = this.readU16();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 221) {
              const size = this.readU32();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 222) {
              const size = this.readU16();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 223) {
              const size = this.readU32();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 196) {
              const size = this.lookU8();
              object = this.decodeBinary(size, 1);
            } else if (headByte === 197) {
              const size = this.lookU16();
              object = this.decodeBinary(size, 2);
            } else if (headByte === 198) {
              const size = this.lookU32();
              object = this.decodeBinary(size, 4);
            } else if (headByte === 212) {
              object = this.decodeExtension(1, 0);
            } else if (headByte === 213) {
              object = this.decodeExtension(2, 0);
            } else if (headByte === 214) {
              object = this.decodeExtension(4, 0);
            } else if (headByte === 215) {
              object = this.decodeExtension(8, 0);
            } else if (headByte === 216) {
              object = this.decodeExtension(16, 0);
            } else if (headByte === 199) {
              const size = this.lookU8();
              object = this.decodeExtension(size, 1);
            } else if (headByte === 200) {
              const size = this.lookU16();
              object = this.decodeExtension(size, 2);
            } else if (headByte === 201) {
              const size = this.lookU32();
              object = this.decodeExtension(size, 4);
            } else {
              throw new DecodeError_1.DecodeError(`Unrecognized type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
            }
            this.complete();
            const stack = this.stack;
            while (stack.length > 0) {
              const state = stack[stack.length - 1];
              if (state.type === 0) {
                state.array[state.position] = object;
                state.position++;
                if (state.position === state.size) {
                  stack.pop();
                  object = state.array;
                } else {
                  continue DECODE;
                }
              } else if (state.type === 1) {
                if (!isValidMapKeyType(object)) {
                  throw new DecodeError_1.DecodeError("The type of key must be string or number but " + typeof object);
                }
                if (object === "__proto__") {
                  throw new DecodeError_1.DecodeError("The key __proto__ is not allowed");
                }
                state.key = object;
                state.type = 2;
                continue DECODE;
              } else {
                state.map[state.key] = object;
                state.readCount++;
                if (state.readCount === state.size) {
                  stack.pop();
                  object = state.map;
                } else {
                  state.key = null;
                  state.type = 1;
                  continue DECODE;
                }
              }
            }
            return object;
          }
      }
      readHeadByte() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
          this.headByte = this.readU8();
        }
        return this.headByte;
      }
      complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
      }
      readArraySize() {
        const headByte = this.readHeadByte();
        switch (headByte) {
          case 220:
            return this.readU16();
          case 221:
            return this.readU32();
          default: {
            if (headByte < 160) {
              return headByte - 144;
            } else {
              throw new DecodeError_1.DecodeError(`Unrecognized array type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
            }
          }
        }
      }
      pushMapState(size) {
        if (size > this.maxMapLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.push({
          type: 1,
          size,
          key: null,
          readCount: 0,
          map: {}
        });
      }
      pushArrayState(size) {
        if (size > this.maxArrayLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.push({
          type: 0,
          size,
          array: new Array(size),
          position: 0
        });
      }
      decodeUtf8String(byteLength, headerOffset) {
        var _a;
        if (byteLength > this.maxStrLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
          throw MORE_DATA;
        }
        const offset = this.pos + headerOffset;
        let object;
        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
          object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        } else if (byteLength > utf8_1.TEXT_DECODER_THRESHOLD) {
          object = (0, utf8_1.utf8DecodeTD)(this.bytes, offset, byteLength);
        } else {
          object = (0, utf8_1.utf8DecodeJs)(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
      }
      stateIsMapKey() {
        if (this.stack.length > 0) {
          const state = this.stack[this.stack.length - 1];
          return state.type === 1;
        }
        return false;
      }
      decodeBinary(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
          throw MORE_DATA;
        }
        const offset = this.pos + headOffset;
        const object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
      }
      decodeExtension(size, headOffset) {
        if (size > this.maxExtLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
        }
        const extType = this.view.getInt8(this.pos + headOffset);
        const data = this.decodeBinary(
          size,
          headOffset + 1
          /* extType */
        );
        return this.extensionCodec.decode(data, extType, this.context);
      }
      lookU8() {
        return this.view.getUint8(this.pos);
      }
      lookU16() {
        return this.view.getUint16(this.pos);
      }
      lookU32() {
        return this.view.getUint32(this.pos);
      }
      readU8() {
        const value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
      }
      readI8() {
        const value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
      }
      readU16() {
        const value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
      }
      readI16() {
        const value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
      }
      readU32() {
        const value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
      }
      readI32() {
        const value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
      }
      readU64() {
        const value = (0, int_1.getUint64)(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readI64() {
        const value = (0, int_1.getInt64)(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readF32() {
        const value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
      }
      readF64() {
        const value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
      }
    };
    exports.Decoder = Decoder;
  }
});

// node_modules/@msgpack/msgpack/dist/decode.js
var require_decode = __commonJS({
  "node_modules/@msgpack/msgpack/dist/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeMulti = exports.decode = exports.defaultDecodeOptions = void 0;
    var Decoder_1 = require_Decoder();
    exports.defaultDecodeOptions = {};
    function decode(buffer, options = exports.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decode(buffer);
    }
    exports.decode = decode;
    function decodeMulti(buffer, options = exports.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeMulti(buffer);
    }
    exports.decodeMulti = decodeMulti;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/stream.js
var require_stream = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureAsyncIterable = exports.asyncIterableFromStream = exports.isAsyncIterable = void 0;
    function isAsyncIterable(object) {
      return object[Symbol.asyncIterator] != null;
    }
    exports.isAsyncIterable = isAsyncIterable;
    function assertNonNull(value) {
      if (value == null) {
        throw new Error("Assertion Failure: value must not be null nor undefined");
      }
    }
    async function* asyncIterableFromStream(stream) {
      const reader = stream.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            return;
          }
          assertNonNull(value);
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    }
    exports.asyncIterableFromStream = asyncIterableFromStream;
    function ensureAsyncIterable(streamLike) {
      if (isAsyncIterable(streamLike)) {
        return streamLike;
      } else {
        return asyncIterableFromStream(streamLike);
      }
    }
    exports.ensureAsyncIterable = ensureAsyncIterable;
  }
});

// node_modules/@msgpack/msgpack/dist/decodeAsync.js
var require_decodeAsync = __commonJS({
  "node_modules/@msgpack/msgpack/dist/decodeAsync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeStream = exports.decodeMultiStream = exports.decodeArrayStream = exports.decodeAsync = void 0;
    var Decoder_1 = require_Decoder();
    var stream_1 = require_stream();
    var decode_1 = require_decode();
    async function decodeAsync(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeAsync(stream);
    }
    exports.decodeAsync = decodeAsync;
    function decodeArrayStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeArrayStream(stream);
    }
    exports.decodeArrayStream = decodeArrayStream;
    function decodeMultiStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeStream(stream);
    }
    exports.decodeMultiStream = decodeMultiStream;
    function decodeStream(streamLike, options = decode_1.defaultDecodeOptions) {
      return decodeMultiStream(streamLike, options);
    }
    exports.decodeStream = decodeStream;
  }
});

// node_modules/@msgpack/msgpack/dist/index.js
var require_dist = __commonJS({
  "node_modules/@msgpack/msgpack/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeTimestampExtension = exports.encodeTimestampExtension = exports.decodeTimestampToTimeSpec = exports.encodeTimeSpecToTimestamp = exports.encodeDateToTimeSpec = exports.EXT_TIMESTAMP = exports.ExtData = exports.ExtensionCodec = exports.Encoder = exports.DataViewIndexOutOfBoundsError = exports.DecodeError = exports.Decoder = exports.decodeStream = exports.decodeMultiStream = exports.decodeArrayStream = exports.decodeAsync = exports.decodeMulti = exports.decode = exports.encode = void 0;
    var encode_1 = require_encode();
    Object.defineProperty(exports, "encode", { enumerable: true, get: function() {
      return encode_1.encode;
    } });
    var decode_1 = require_decode();
    Object.defineProperty(exports, "decode", { enumerable: true, get: function() {
      return decode_1.decode;
    } });
    Object.defineProperty(exports, "decodeMulti", { enumerable: true, get: function() {
      return decode_1.decodeMulti;
    } });
    var decodeAsync_1 = require_decodeAsync();
    Object.defineProperty(exports, "decodeAsync", { enumerable: true, get: function() {
      return decodeAsync_1.decodeAsync;
    } });
    Object.defineProperty(exports, "decodeArrayStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeArrayStream;
    } });
    Object.defineProperty(exports, "decodeMultiStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeMultiStream;
    } });
    Object.defineProperty(exports, "decodeStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeStream;
    } });
    var Decoder_1 = require_Decoder();
    Object.defineProperty(exports, "Decoder", { enumerable: true, get: function() {
      return Decoder_1.Decoder;
    } });
    Object.defineProperty(exports, "DataViewIndexOutOfBoundsError", { enumerable: true, get: function() {
      return Decoder_1.DataViewIndexOutOfBoundsError;
    } });
    var DecodeError_1 = require_DecodeError();
    Object.defineProperty(exports, "DecodeError", { enumerable: true, get: function() {
      return DecodeError_1.DecodeError;
    } });
    var Encoder_1 = require_Encoder();
    Object.defineProperty(exports, "Encoder", { enumerable: true, get: function() {
      return Encoder_1.Encoder;
    } });
    var ExtensionCodec_1 = require_ExtensionCodec();
    Object.defineProperty(exports, "ExtensionCodec", { enumerable: true, get: function() {
      return ExtensionCodec_1.ExtensionCodec;
    } });
    var ExtData_1 = require_ExtData();
    Object.defineProperty(exports, "ExtData", { enumerable: true, get: function() {
      return ExtData_1.ExtData;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports, "EXT_TIMESTAMP", { enumerable: true, get: function() {
      return timestamp_1.EXT_TIMESTAMP;
    } });
    Object.defineProperty(exports, "encodeDateToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.encodeDateToTimeSpec;
    } });
    Object.defineProperty(exports, "encodeTimeSpecToTimestamp", { enumerable: true, get: function() {
      return timestamp_1.encodeTimeSpecToTimestamp;
    } });
    Object.defineProperty(exports, "decodeTimestampToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampToTimeSpec;
    } });
    Object.defineProperty(exports, "encodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.encodeTimestampExtension;
    } });
    Object.defineProperty(exports, "decodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampExtension;
    } });
  }
});

// node_modules/neovim/lib/utils/util.js
var require_util = __commonJS({
  "node_modules/neovim/lib/utils/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partialClone = void 0;
    function partialClone(obj, depth = 3, omitKeys = [], replacement = void 0) {
      if (typeof obj !== "object" || obj === null || Object.getOwnPropertyNames(obj).length === 0) {
        return obj;
      }
      const clonedObj = Array.isArray(obj) ? [] : {};
      if (depth === 0) {
        return replacement || clonedObj;
      }
      for (const key of Object.keys(obj)) {
        if (omitKeys.includes(key)) {
          clonedObj[key] = replacement || (Array.isArray(obj) ? [] : {});
        } else if (Object.prototype.hasOwnProperty.call(obj, key)) {
          clonedObj[key] = partialClone(obj[key], depth - 1, omitKeys, replacement);
        }
      }
      return clonedObj;
    }
    exports.partialClone = partialClone;
  }
});

// node_modules/logform/format.js
var require_format = __commonJS({
  "node_modules/logform/format.js"(exports, module2) {
    "use strict";
    var InvalidFormatError = class extends Error {
      constructor(formatFn) {
        super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}
`);
        Error.captureStackTrace(this, InvalidFormatError);
      }
    };
    module2.exports = (formatFn) => {
      if (formatFn.length > 2) {
        throw new InvalidFormatError(formatFn);
      }
      function Format(options = {}) {
        this.options = options;
      }
      Format.prototype.transform = formatFn;
      function createFormatWrap(opts) {
        return new Format(opts);
      }
      createFormatWrap.Format = Format;
      return createFormatWrap;
    };
  }
});

// node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/@colors/colors/lib/styles.js"(exports, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "node_modules/@colors/colors/lib/system/has-flag.js"(exports, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv || [];
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/@colors/colors/lib/system/supports-colors.js"(exports, module2) {
    "use strict";
    var os2 = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os2.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/@colors/colors/lib/custom/trap.js"(exports, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/@colors/colors/lib/custom/zalgo.js"(exports, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/@colors/colors/lib/maps/america.js"(exports, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        if (letter === " ")
          return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/@colors/colors/lib/maps/zebra.js"(exports, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/@colors/colors/lib/maps/rainbow.js"(exports, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/@colors/colors/lib/maps/random.js"(exports, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/@colors/colors/lib/colors.js"(exports, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util = require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/@colors/colors/safe.js
var require_safe = __commonJS({
  "node_modules/@colors/colors/safe.js"(exports, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/triple-beam/config/cli.js
var require_cli = __commonJS({
  "node_modules/triple-beam/config/cli.js"(exports) {
    "use strict";
    exports.levels = {
      error: 0,
      warn: 1,
      help: 2,
      data: 3,
      info: 4,
      debug: 5,
      prompt: 6,
      verbose: 7,
      input: 8,
      silly: 9
    };
    exports.colors = {
      error: "red",
      warn: "yellow",
      help: "cyan",
      data: "grey",
      info: "green",
      debug: "blue",
      prompt: "grey",
      verbose: "cyan",
      input: "grey",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/npm.js
var require_npm = __commonJS({
  "node_modules/triple-beam/config/npm.js"(exports) {
    "use strict";
    exports.levels = {
      error: 0,
      warn: 1,
      info: 2,
      http: 3,
      verbose: 4,
      debug: 5,
      silly: 6
    };
    exports.colors = {
      error: "red",
      warn: "yellow",
      info: "green",
      http: "green",
      verbose: "cyan",
      debug: "blue",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS({
  "node_modules/triple-beam/config/syslog.js"(exports) {
    "use strict";
    exports.levels = {
      emerg: 0,
      alert: 1,
      crit: 2,
      error: 3,
      warning: 4,
      notice: 5,
      info: 6,
      debug: 7
    };
    exports.colors = {
      emerg: "red",
      alert: "yellow",
      crit: "red",
      error: "red",
      warning: "red",
      notice: "yellow",
      info: "green",
      debug: "blue"
    };
  }
});

// node_modules/triple-beam/config/index.js
var require_config = __commonJS({
  "node_modules/triple-beam/config/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "cli", {
      value: require_cli()
    });
    Object.defineProperty(exports, "npm", {
      value: require_npm()
    });
    Object.defineProperty(exports, "syslog", {
      value: require_syslog()
    });
  }
});

// node_modules/triple-beam/index.js
var require_triple_beam = __commonJS({
  "node_modules/triple-beam/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "LEVEL", {
      value: Symbol.for("level")
    });
    Object.defineProperty(exports, "MESSAGE", {
      value: Symbol.for("message")
    });
    Object.defineProperty(exports, "SPLAT", {
      value: Symbol.for("splat")
    });
    Object.defineProperty(exports, "configs", {
      value: require_config()
    });
  }
});

// node_modules/logform/colorize.js
var require_colorize = __commonJS({
  "node_modules/logform/colorize.js"(exports, module2) {
    "use strict";
    var colors = require_safe();
    var { LEVEL, MESSAGE } = require_triple_beam();
    colors.enabled = true;
    var hasSpace = /\s+/;
    var Colorizer = class {
      constructor(opts = {}) {
        if (opts.colors) {
          this.addColors(opts.colors);
        }
        this.options = opts;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      static addColors(clrs) {
        const nextColors = Object.keys(clrs).reduce((acc, level) => {
          acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
          return acc;
        }, {});
        Colorizer.allColors = Object.assign({}, Colorizer.allColors || {}, nextColors);
        return Colorizer.allColors;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      addColors(clrs) {
        return Colorizer.addColors(clrs);
      }
      /*
       * function colorize (lookup, level, message)
       * Performs multi-step colorization using @colors/colors/safe
       */
      colorize(lookup, level, message) {
        if (typeof message === "undefined") {
          message = level;
        }
        if (!Array.isArray(Colorizer.allColors[lookup])) {
          return colors[Colorizer.allColors[lookup]](message);
        }
        for (let i = 0, len = Colorizer.allColors[lookup].length; i < len; i++) {
          message = colors[Colorizer.allColors[lookup][i]](message);
        }
        return message;
      }
      /*
       * function transform (info, opts)
       * Attempts to colorize the { level, message } of the given
       * `logform` info object.
       */
      transform(info, opts) {
        if (opts.all && typeof info[MESSAGE] === "string") {
          info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
        }
        if (opts.level || opts.all || !opts.message) {
          info.level = this.colorize(info[LEVEL], info.level);
        }
        if (opts.all || opts.message) {
          info.message = this.colorize(info[LEVEL], info.level, info.message);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Colorizer(opts);
    module2.exports.Colorizer = module2.exports.Format = Colorizer;
  }
});

// node_modules/logform/levels.js
var require_levels = __commonJS({
  "node_modules/logform/levels.js"(exports, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    module2.exports = (config) => {
      Colorizer.addColors(config.colors || config);
      return config;
    };
  }
});

// node_modules/logform/align.js
var require_align = __commonJS({
  "node_modules/logform/align.js"(exports, module2) {
    "use strict";
    var format = require_format();
    module2.exports = format((info) => {
      info.message = `	${info.message}`;
      return info;
    });
  }
});

// node_modules/logform/errors.js
var require_errors = __commonJS({
  "node_modules/logform/errors.js"(exports, module2) {
    "use strict";
    var format = require_format();
    var { LEVEL, MESSAGE } = require_triple_beam();
    module2.exports = format((einfo, { stack, cause }) => {
      if (einfo instanceof Error) {
        const info = Object.assign({}, einfo, {
          level: einfo.level,
          [LEVEL]: einfo[LEVEL] || einfo.level,
          message: einfo.message,
          [MESSAGE]: einfo[MESSAGE] || einfo.message
        });
        if (stack)
          info.stack = einfo.stack;
        if (cause)
          info.cause = einfo.cause;
        return info;
      }
      if (!(einfo.message instanceof Error))
        return einfo;
      const err = einfo.message;
      Object.assign(einfo, err);
      einfo.message = err.message;
      einfo[MESSAGE] = err.message;
      if (stack)
        einfo.stack = err.stack;
      if (cause)
        einfo.cause = err.cause;
      return einfo;
    });
  }
});

// node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS({
  "node_modules/logform/pad-levels.js"(exports, module2) {
    "use strict";
    var { configs, LEVEL, MESSAGE } = require_triple_beam();
    var Padder = class {
      constructor(opts = { levels: configs.npm.levels }) {
        this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);
        this.options = opts;
      }
      /**
       * Returns the maximum length of keys in the specified `levels` Object.
       * @param  {Object} levels Set of all levels to calculate longest level against.
       * @returns {Number} Maximum length of the longest level string.
       */
      static getLongestLevel(levels) {
        const lvls = Object.keys(levels).map((level) => level.length);
        return Math.max(...lvls);
      }
      /**
       * Returns the padding for the specified `level` assuming that the
       * maximum length of all levels it's associated with is `maxLength`.
       * @param  {String} level Level to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @param  {Number} maxLength Length of the longest level
       * @returns {String} Padding string for the `level`
       */
      static paddingForLevel(level, filler, maxLength) {
        const targetLen = maxLength + 1 - level.length;
        const rep = Math.floor(targetLen / filler.length);
        const padding = `${filler}${filler.repeat(rep)}`;
        return padding.slice(0, targetLen);
      }
      /**
       * Returns an object with the string paddings for the given `levels`
       * using the specified `filler`.
       * @param  {Object} levels Set of all levels to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @returns {Object} Mapping of level to desired padding.
       */
      static paddingForLevels(levels, filler = " ") {
        const maxLength = Padder.getLongestLevel(levels);
        return Object.keys(levels).reduce((acc, level) => {
          acc[level] = Padder.paddingForLevel(level, filler, maxLength);
          return acc;
        }, {});
      }
      /**
       * Prepends the padding onto the `message` based on the `LEVEL` of
       * the `info`. This is based on the behavior of `winston@2` which also
       * prepended the level onto the message.
       *
       * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
       *
       * @param  {Info} info Logform info object
       * @param  {Object} opts Options passed along to this instance.
       * @returns {Info} Modified logform info object.
       */
      transform(info, opts) {
        info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
        if (info[MESSAGE]) {
          info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
        }
        return info;
      }
    };
    module2.exports = (opts) => new Padder(opts);
    module2.exports.Padder = module2.exports.Format = Padder;
  }
});

// node_modules/logform/cli.js
var require_cli2 = __commonJS({
  "node_modules/logform/cli.js"(exports, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    var { Padder } = require_pad_levels();
    var { configs, MESSAGE } = require_triple_beam();
    var CliFormat = class {
      constructor(opts = {}) {
        if (!opts.levels) {
          opts.levels = configs.cli.levels;
        }
        this.colorizer = new Colorizer(opts);
        this.padder = new Padder(opts);
        this.options = opts;
      }
      /*
       * function transform (info, opts)
       * Attempts to both:
       * 1. Pad the { level }
       * 2. Colorize the { level, message }
       * of the given `logform` info object depending on the `opts`.
       */
      transform(info, opts) {
        this.colorizer.transform(
          this.padder.transform(info, opts),
          opts
        );
        info[MESSAGE] = `${info.level}:${info.message}`;
        return info;
      }
    };
    module2.exports = (opts) => new CliFormat(opts);
    module2.exports.Format = CliFormat;
  }
});

// node_modules/logform/combine.js
var require_combine = __commonJS({
  "node_modules/logform/combine.js"(exports, module2) {
    "use strict";
    var format = require_format();
    function cascade(formats) {
      if (!formats.every(isValidFormat)) {
        return;
      }
      return (info) => {
        let obj = info;
        for (let i = 0; i < formats.length; i++) {
          obj = formats[i].transform(obj, formats[i].options);
          if (!obj) {
            return false;
          }
        }
        return obj;
      };
    }
    function isValidFormat(fmt) {
      if (typeof fmt.transform !== "function") {
        throw new Error([
          "No transform function found on format. Did you create a format instance?",
          "const myFormat = format(formatFn);",
          "const instance = myFormat();"
        ].join("\n"));
      }
      return true;
    }
    module2.exports = (...formats) => {
      const combinedFormat = format(cascade(formats));
      const instance = combinedFormat();
      instance.Format = combinedFormat.Format;
      return instance;
    };
    module2.exports.cascade = cascade;
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/safe-stable-stringify/index.js"(exports, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports.stringify = stringify;
    exports.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function insertSort(array) {
      if (array.length > 200) {
        return array.sort();
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function")
              message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getBooleanOption(options, "deterministic");
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// node_modules/logform/json.js
var require_json = __commonJS({
  "node_modules/logform/json.js"(exports, module2) {
    "use strict";
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    var stringify = require_safe_stable_stringify();
    function replacer(key, value) {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    }
    module2.exports = format((info, opts) => {
      const jsonStringify = stringify.configure(opts);
      info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
      return info;
    });
  }
});

// node_modules/logform/label.js
var require_label = __commonJS({
  "node_modules/logform/label.js"(exports, module2) {
    "use strict";
    var format = require_format();
    module2.exports = format((info, opts) => {
      if (opts.message) {
        info.message = `[${opts.label}] ${info.message}`;
        return info;
      }
      info.label = opts.label;
      return info;
    });
  }
});

// node_modules/logform/logstash.js
var require_logstash = __commonJS({
  "node_modules/logform/logstash.js"(exports, module2) {
    "use strict";
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format((info) => {
      const logstash = {};
      if (info.message) {
        logstash["@message"] = info.message;
        delete info.message;
      }
      if (info.timestamp) {
        logstash["@timestamp"] = info.timestamp;
        delete info.timestamp;
      }
      logstash["@fields"] = info;
      info[MESSAGE] = jsonStringify(logstash);
      return info;
    });
  }
});

// node_modules/logform/metadata.js
var require_metadata = __commonJS({
  "node_modules/logform/metadata.js"(exports, module2) {
    "use strict";
    var format = require_format();
    function fillExcept(info, fillExceptKeys, metadataKey) {
      const savedKeys = fillExceptKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      const metadata = Object.keys(info).reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      Object.assign(info, savedKeys, {
        [metadataKey]: metadata
      });
      return info;
    }
    function fillWith(info, fillWithKeys, metadataKey) {
      info[metadataKey] = fillWithKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      return info;
    }
    module2.exports = format((info, opts = {}) => {
      let metadataKey = "metadata";
      if (opts.key) {
        metadataKey = opts.key;
      }
      let fillExceptKeys = [];
      if (!opts.fillExcept && !opts.fillWith) {
        fillExceptKeys.push("level");
        fillExceptKeys.push("message");
      }
      if (opts.fillExcept) {
        fillExceptKeys = opts.fillExcept;
      }
      if (fillExceptKeys.length > 0) {
        return fillExcept(info, fillExceptKeys, metadataKey);
      }
      if (opts.fillWith) {
        return fillWith(info, opts.fillWith, metadataKey);
      }
      return info;
    });
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/logform/ms.js
var require_ms2 = __commonJS({
  "node_modules/logform/ms.js"(exports, module2) {
    "use strict";
    var format = require_format();
    var ms = require_ms();
    module2.exports = format((info) => {
      const curr = +new Date();
      exports.diff = curr - (exports.prevTime || curr);
      exports.prevTime = curr;
      info.ms = `+${ms(exports.diff)}`;
      return info;
    });
  }
});

// node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS({
  "node_modules/logform/pretty-print.js"(exports, module2) {
    "use strict";
    var inspect = require("util").inspect;
    var format = require_format();
    var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
    module2.exports = format((info, opts = {}) => {
      const stripped = Object.assign({}, info);
      delete stripped[LEVEL];
      delete stripped[MESSAGE];
      delete stripped[SPLAT];
      info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
      return info;
    });
  }
});

// node_modules/logform/printf.js
var require_printf = __commonJS({
  "node_modules/logform/printf.js"(exports, module2) {
    "use strict";
    var { MESSAGE } = require_triple_beam();
    var Printf = class {
      constructor(templateFn) {
        this.template = templateFn;
      }
      transform(info) {
        info[MESSAGE] = this.template(info);
        return info;
      }
    };
    module2.exports = (opts) => new Printf(opts);
    module2.exports.Printf = module2.exports.Format = Printf;
  }
});

// node_modules/logform/simple.js
var require_simple = __commonJS({
  "node_modules/logform/simple.js"(exports, module2) {
    "use strict";
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format((info) => {
      const stringifiedRest = jsonStringify(Object.assign({}, info, {
        level: void 0,
        message: void 0,
        splat: void 0
      }));
      const padding = info.padding && info.padding[info.level] || "";
      if (stringifiedRest !== "{}") {
        info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
      } else {
        info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
      }
      return info;
    });
  }
});

// node_modules/logform/splat.js
var require_splat = __commonJS({
  "node_modules/logform/splat.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var { SPLAT } = require_triple_beam();
    var formatRegExp = /%[scdjifoO%]/g;
    var escapedPercent = /%%/g;
    var Splatter = class {
      constructor(opts) {
        this.options = opts;
      }
      /**
         * Check to see if tokens <= splat.length, assign { splat, meta } into the
         * `info` accordingly, and write to this instance.
         *
         * @param  {Info} info Logform info message.
         * @param  {String[]} tokens Set of string interpolation tokens.
         * @returns {Info} Modified info message
         * @private
         */
      _splat(info, tokens) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat || [];
        const percents = msg.match(escapedPercent);
        const escapes = percents && percents.length || 0;
        const expectedSplat = tokens.length - escapes;
        const extraSplat = expectedSplat - splat.length;
        const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
        const metalen = metas.length;
        if (metalen) {
          for (let i = 0; i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        info.message = util.format(msg, ...splat);
        return info;
      }
      /**
        * Transforms the `info` message by using `util.format` to complete
        * any `info.message` provided it has string interpolation tokens.
        * If no tokens exist then `info` is immutable.
        *
        * @param  {Info} info Logform info message.
        * @param  {Object} opts Options for this instance.
        * @returns {Info} Modified info message
        */
      transform(info) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat;
        if (!splat || !splat.length) {
          return info;
        }
        const tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens && (splat || splat.length)) {
          const metas = splat.length > 1 ? splat.splice(0) : splat;
          const metalen = metas.length;
          if (metalen) {
            for (let i = 0; i < metalen; i++) {
              Object.assign(info, metas[i]);
            }
          }
          return info;
        }
        if (tokens) {
          return this._splat(info, tokens);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Splatter(opts);
  }
});

// node_modules/fecha/lib/fecha.umd.js
var require_fecha_umd = __commonJS({
  "node_modules/fecha/lib/fecha.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fecha = {});
    })(exports, function(exports2) {
      "use strict";
      var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
      var twoDigitsOptional = "\\d\\d?";
      var twoDigits = "\\d\\d";
      var threeDigits = "\\d{3}";
      var fourDigits = "\\d{4}";
      var word = "[^\\s]+";
      var literal = /\[([^]*?)\]/gm;
      function shorten(arr, sLen) {
        var newArr = [];
        for (var i = 0, len = arr.length; i < len; i++) {
          newArr.push(arr[i].substr(0, sLen));
        }
        return newArr;
      }
      var monthUpdate = function(arrName) {
        return function(v, i18n) {
          var lowerCaseArr = i18n[arrName].map(function(v2) {
            return v2.toLowerCase();
          });
          var index = lowerCaseArr.indexOf(v.toLowerCase());
          if (index > -1) {
            return index;
          }
          return null;
        };
      };
      function assign(origObj) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
          var obj = args_1[_a];
          for (var key in obj) {
            origObj[key] = obj[key];
          }
        }
        return origObj;
      }
      var dayNames = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ];
      var monthNames = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ];
      var monthNamesShort = shorten(monthNames, 3);
      var dayNamesShort = shorten(dayNames, 3);
      var defaultI18n = {
        dayNamesShort,
        dayNames,
        monthNamesShort,
        monthNames,
        amPm: ["am", "pm"],
        DoFn: function(dayOfMonth) {
          return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
        }
      };
      var globalI18n = assign({}, defaultI18n);
      var setGlobalDateI18n = function(i18n) {
        return globalI18n = assign(globalI18n, i18n);
      };
      var regexEscape = function(str) {
        return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
      };
      var pad = function(val, len) {
        if (len === void 0) {
          len = 2;
        }
        val = String(val);
        while (val.length < len) {
          val = "0" + val;
        }
        return val;
      };
      var formatFlags = {
        D: function(dateObj) {
          return String(dateObj.getDate());
        },
        DD: function(dateObj) {
          return pad(dateObj.getDate());
        },
        Do: function(dateObj, i18n) {
          return i18n.DoFn(dateObj.getDate());
        },
        d: function(dateObj) {
          return String(dateObj.getDay());
        },
        dd: function(dateObj) {
          return pad(dateObj.getDay());
        },
        ddd: function(dateObj, i18n) {
          return i18n.dayNamesShort[dateObj.getDay()];
        },
        dddd: function(dateObj, i18n) {
          return i18n.dayNames[dateObj.getDay()];
        },
        M: function(dateObj) {
          return String(dateObj.getMonth() + 1);
        },
        MM: function(dateObj) {
          return pad(dateObj.getMonth() + 1);
        },
        MMM: function(dateObj, i18n) {
          return i18n.monthNamesShort[dateObj.getMonth()];
        },
        MMMM: function(dateObj, i18n) {
          return i18n.monthNames[dateObj.getMonth()];
        },
        YY: function(dateObj) {
          return pad(String(dateObj.getFullYear()), 4).substr(2);
        },
        YYYY: function(dateObj) {
          return pad(dateObj.getFullYear(), 4);
        },
        h: function(dateObj) {
          return String(dateObj.getHours() % 12 || 12);
        },
        hh: function(dateObj) {
          return pad(dateObj.getHours() % 12 || 12);
        },
        H: function(dateObj) {
          return String(dateObj.getHours());
        },
        HH: function(dateObj) {
          return pad(dateObj.getHours());
        },
        m: function(dateObj) {
          return String(dateObj.getMinutes());
        },
        mm: function(dateObj) {
          return pad(dateObj.getMinutes());
        },
        s: function(dateObj) {
          return String(dateObj.getSeconds());
        },
        ss: function(dateObj) {
          return pad(dateObj.getSeconds());
        },
        S: function(dateObj) {
          return String(Math.round(dateObj.getMilliseconds() / 100));
        },
        SS: function(dateObj) {
          return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
        },
        SSS: function(dateObj) {
          return pad(dateObj.getMilliseconds(), 3);
        },
        a: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
        },
        A: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
        },
        ZZ: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
        },
        Z: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
        }
      };
      var monthParse = function(v) {
        return +v - 1;
      };
      var emptyDigits = [null, twoDigitsOptional];
      var emptyWord = [null, word];
      var amPm = [
        "isPm",
        word,
        function(v, i18n) {
          var val = v.toLowerCase();
          if (val === i18n.amPm[0]) {
            return 0;
          } else if (val === i18n.amPm[1]) {
            return 1;
          }
          return null;
        }
      ];
      var timezoneOffset = [
        "timezoneOffset",
        "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
        function(v) {
          var parts = (v + "").match(/([+-]|\d\d)/gi);
          if (parts) {
            var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
            return parts[0] === "+" ? minutes : -minutes;
          }
          return 0;
        }
      ];
      var parseFlags = {
        D: ["day", twoDigitsOptional],
        DD: ["day", twoDigits],
        Do: ["day", twoDigitsOptional + word, function(v) {
          return parseInt(v, 10);
        }],
        M: ["month", twoDigitsOptional, monthParse],
        MM: ["month", twoDigits, monthParse],
        YY: [
          "year",
          twoDigits,
          function(v) {
            var now = new Date();
            var cent = +("" + now.getFullYear()).substr(0, 2);
            return +("" + (+v > 68 ? cent - 1 : cent) + v);
          }
        ],
        h: ["hour", twoDigitsOptional, void 0, "isPm"],
        hh: ["hour", twoDigits, void 0, "isPm"],
        H: ["hour", twoDigitsOptional],
        HH: ["hour", twoDigits],
        m: ["minute", twoDigitsOptional],
        mm: ["minute", twoDigits],
        s: ["second", twoDigitsOptional],
        ss: ["second", twoDigits],
        YYYY: ["year", fourDigits],
        S: ["millisecond", "\\d", function(v) {
          return +v * 100;
        }],
        SS: ["millisecond", twoDigits, function(v) {
          return +v * 10;
        }],
        SSS: ["millisecond", threeDigits],
        d: emptyDigits,
        dd: emptyDigits,
        ddd: emptyWord,
        dddd: emptyWord,
        MMM: ["month", word, monthUpdate("monthNamesShort")],
        MMMM: ["month", word, monthUpdate("monthNames")],
        a: amPm,
        A: amPm,
        ZZ: timezoneOffset,
        Z: timezoneOffset
      };
      var globalMasks = {
        default: "ddd MMM DD YYYY HH:mm:ss",
        shortDate: "M/D/YY",
        mediumDate: "MMM D, YYYY",
        longDate: "MMMM D, YYYY",
        fullDate: "dddd, MMMM D, YYYY",
        isoDate: "YYYY-MM-DD",
        isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
        shortTime: "HH:mm",
        mediumTime: "HH:mm:ss",
        longTime: "HH:mm:ss.SSS"
      };
      var setGlobalDateMasks = function(masks) {
        return assign(globalMasks, masks);
      };
      var format = function(dateObj, mask, i18n) {
        if (mask === void 0) {
          mask = globalMasks["default"];
        }
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof dateObj === "number") {
          dateObj = new Date(dateObj);
        }
        if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
          throw new Error("Invalid Date pass to format");
        }
        mask = globalMasks[mask] || mask;
        var literals = [];
        mask = mask.replace(literal, function($0, $1) {
          literals.push($1);
          return "@@@";
        });
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        mask = mask.replace(token, function($0) {
          return formatFlags[$0](dateObj, combinedI18nSettings);
        });
        return mask.replace(/@@@/g, function() {
          return literals.shift();
        });
      };
      function parse(dateStr, format2, i18n) {
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof format2 !== "string") {
          throw new Error("Invalid format in fecha parse");
        }
        format2 = globalMasks[format2] || format2;
        if (dateStr.length > 1e3) {
          return null;
        }
        var today = new Date();
        var dateInfo = {
          year: today.getFullYear(),
          month: 0,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          isPm: null,
          timezoneOffset: null
        };
        var parseInfo = [];
        var literals = [];
        var newFormat = format2.replace(literal, function($0, $1) {
          literals.push(regexEscape($1));
          return "@@@";
        });
        var specifiedFields = {};
        var requiredFields = {};
        newFormat = regexEscape(newFormat).replace(token, function($0) {
          var info = parseFlags[$0];
          var field2 = info[0], regex = info[1], requiredField = info[3];
          if (specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " specified twice in format");
          }
          specifiedFields[field2] = true;
          if (requiredField) {
            requiredFields[requiredField] = true;
          }
          parseInfo.push(info);
          return "(" + regex + ")";
        });
        Object.keys(requiredFields).forEach(function(field2) {
          if (!specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " is required in specified format");
          }
        });
        newFormat = newFormat.replace(/@@@/g, function() {
          return literals.shift();
        });
        var matches = dateStr.match(new RegExp(newFormat, "i"));
        if (!matches) {
          return null;
        }
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        for (var i = 1; i < matches.length; i++) {
          var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
          var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
          if (value == null) {
            return null;
          }
          dateInfo[field] = value;
        }
        if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
          dateInfo.hour = +dateInfo.hour + 12;
        } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
          dateInfo.hour = 0;
        }
        var dateTZ;
        if (dateInfo.timezoneOffset == null) {
          dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
          var validateFields = [
            ["month", "getMonth"],
            ["day", "getDate"],
            ["hour", "getHours"],
            ["minute", "getMinutes"],
            ["second", "getSeconds"]
          ];
          for (var i = 0, len = validateFields.length; i < len; i++) {
            if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
              return null;
            }
          }
        } else {
          dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
          if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
            return null;
          }
        }
        return dateTZ;
      }
      var fecha = {
        format,
        parse,
        defaultI18n,
        setGlobalDateI18n,
        setGlobalDateMasks
      };
      exports2.assign = assign;
      exports2.default = fecha;
      exports2.format = format;
      exports2.parse = parse;
      exports2.defaultI18n = defaultI18n;
      exports2.setGlobalDateI18n = setGlobalDateI18n;
      exports2.setGlobalDateMasks = setGlobalDateMasks;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/logform/timestamp.js
var require_timestamp2 = __commonJS({
  "node_modules/logform/timestamp.js"(exports, module2) {
    "use strict";
    var fecha = require_fecha_umd();
    var format = require_format();
    module2.exports = format((info, opts = {}) => {
      if (opts.format) {
        info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(new Date(), opts.format);
      }
      if (!info.timestamp) {
        info.timestamp = new Date().toISOString();
      }
      if (opts.alias) {
        info[opts.alias] = info.timestamp;
      }
      return info;
    });
  }
});

// node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS({
  "node_modules/logform/uncolorize.js"(exports, module2) {
    "use strict";
    var colors = require_safe();
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    module2.exports = format((info, opts) => {
      if (opts.level !== false) {
        info.level = colors.strip(info.level);
      }
      if (opts.message !== false) {
        info.message = colors.strip(String(info.message));
      }
      if (opts.raw !== false && info[MESSAGE]) {
        info[MESSAGE] = colors.strip(String(info[MESSAGE]));
      }
      return info;
    });
  }
});

// node_modules/logform/index.js
var require_logform = __commonJS({
  "node_modules/logform/index.js"(exports) {
    "use strict";
    var format = exports.format = require_format();
    exports.levels = require_levels();
    function exposeFormat(name, requireFormat) {
      Object.defineProperty(format, name, {
        get() {
          return requireFormat();
        },
        configurable: true
      });
    }
    exposeFormat("align", function() {
      return require_align();
    });
    exposeFormat("errors", function() {
      return require_errors();
    });
    exposeFormat("cli", function() {
      return require_cli2();
    });
    exposeFormat("combine", function() {
      return require_combine();
    });
    exposeFormat("colorize", function() {
      return require_colorize();
    });
    exposeFormat("json", function() {
      return require_json();
    });
    exposeFormat("label", function() {
      return require_label();
    });
    exposeFormat("logstash", function() {
      return require_logstash();
    });
    exposeFormat("metadata", function() {
      return require_metadata();
    });
    exposeFormat("ms", function() {
      return require_ms2();
    });
    exposeFormat("padLevels", function() {
      return require_pad_levels();
    });
    exposeFormat("prettyPrint", function() {
      return require_pretty_print();
    });
    exposeFormat("printf", function() {
      return require_printf();
    });
    exposeFormat("simple", function() {
      return require_simple();
    });
    exposeFormat("splat", function() {
      return require_splat();
    });
    exposeFormat("timestamp", function() {
      return require_timestamp2();
    });
    exposeFormat("uncolorize", function() {
      return require_uncolorize();
    });
  }
});

// node_modules/winston/lib/winston/common.js
var require_common = __commonJS({
  "node_modules/winston/lib/winston/common.js"(exports) {
    "use strict";
    var { format } = require("util");
    exports.warn = {
      deprecated(prop) {
        return () => {
          throw new Error(format("{ %s } was removed in winston@3.0.0.", prop));
        };
      },
      useFormat(prop) {
        return () => {
          throw new Error([
            format("{ %s } was removed in winston@3.0.0.", prop),
            "Use a custom winston.format = winston.format(function) instead."
          ].join("\n"));
        };
      },
      forFunctions(obj, type, props) {
        props.forEach((prop) => {
          obj[prop] = exports.warn[type](prop);
        });
      },
      forProperties(obj, type, props) {
        props.forEach((prop) => {
          const notice = exports.warn[type](prop);
          Object.defineProperty(obj, prop, {
            get: notice,
            set: notice
          });
        });
      }
    };
  }
});

// node_modules/winston/package.json
var require_package = __commonJS({
  "node_modules/winston/package.json"(exports, module2) {
    module2.exports = {
      name: "winston",
      description: "A logger for just about everything.",
      version: "3.11.0",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      maintainers: [
        "David Hyde <dabh@alumni.stanford.edu>"
      ],
      repository: {
        type: "git",
        url: "https://github.com/winstonjs/winston.git"
      },
      keywords: [
        "winston",
        "logger",
        "logging",
        "logs",
        "sysadmin",
        "bunyan",
        "pino",
        "loglevel",
        "tools",
        "json",
        "stream"
      ],
      dependencies: {
        "@dabh/diagnostics": "^2.0.2",
        "@colors/colors": "^1.6.0",
        async: "^3.2.3",
        "is-stream": "^2.0.0",
        logform: "^2.4.0",
        "one-time": "^1.0.0",
        "readable-stream": "^3.4.0",
        "safe-stable-stringify": "^2.3.1",
        "stack-trace": "0.0.x",
        "triple-beam": "^1.3.0",
        "winston-transport": "^4.5.0"
      },
      devDependencies: {
        "@babel/cli": "^7.17.0",
        "@babel/core": "^7.17.2",
        "@babel/preset-env": "^7.16.7",
        "@dabh/eslint-config-populist": "^5.0.0",
        "@types/node": "^20.3.1",
        "abstract-winston-transport": "^0.5.1",
        assume: "^2.2.0",
        "cross-spawn-async": "^2.2.5",
        eslint: "^8.9.0",
        hock: "^1.4.1",
        mocha: "8.1.3",
        nyc: "^15.1.0",
        rimraf: "^5.0.5",
        split2: "^4.1.0",
        "std-mocks": "^1.0.1",
        through2: "^4.0.2",
        "winston-compat": "^0.1.5"
      },
      main: "./lib/winston.js",
      browser: "./dist/winston",
      types: "./index.d.ts",
      scripts: {
        lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
        test: "mocha",
        "test:coverage": "nyc npm run test:unit",
        "test:unit": "mocha test/unit",
        "test:integration": "mocha test/integration",
        build: "rimraf dist && babel lib -d dist",
        prepublishOnly: "npm run build"
      },
      engines: {
        node: ">= 12.0.0"
      },
      license: "MIT"
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors.js
var require_errors2 = __commonJS({
  "node_modules/readable-stream/errors.js"(exports, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream2();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require("string_decoder/").StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream2();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/winston-transport/modern.js
var require_modern = __commonJS({
  "node_modules/winston-transport/modern.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var Writable = require_stream_writable();
    var { LEVEL } = require_triple_beam();
    var TransportStream = module2.exports = function TransportStream2(options = {}) {
      Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
      this.format = options.format;
      this.level = options.level;
      this.handleExceptions = options.handleExceptions;
      this.handleRejections = options.handleRejections;
      this.silent = options.silent;
      if (options.log)
        this.log = options.log;
      if (options.logv)
        this.logv = options.logv;
      if (options.close)
        this.close = options.close;
      this.once("pipe", (logger) => {
        this.levels = logger.levels;
        this.parent = logger;
      });
      this.once("unpipe", (src) => {
        if (src === this.parent) {
          this.parent = null;
          if (this.close) {
            this.close();
          }
        }
      });
    };
    util.inherits(TransportStream, Writable);
    TransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      const level = this.level || this.parent && this.parent.level;
      if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (info && !this.format) {
          return this.log(info, callback);
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, info), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          callback();
          if (errState)
            throw errState;
          return;
        }
        return this.log(transformed, callback);
      }
      this._writableState.sync = false;
      return callback(null);
    };
    TransportStream.prototype._writev = function _writev(chunks, callback) {
      if (this.logv) {
        const infos = chunks.filter(this._accept, this);
        if (!infos.length) {
          return callback(null);
        }
        return this.logv(infos, callback);
      }
      for (let i = 0; i < chunks.length; i++) {
        if (!this._accept(chunks[i]))
          continue;
        if (chunks[i].chunk && !this.format) {
          this.log(chunks[i].chunk, chunks[i].callback);
          continue;
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(
            Object.assign({}, chunks[i].chunk),
            this.format.options
          );
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          chunks[i].callback();
          if (errState) {
            callback(null);
            throw errState;
          }
        } else {
          this.log(transformed, chunks[i].callback);
        }
      }
      return callback(null);
    };
    TransportStream.prototype._accept = function _accept(write) {
      const info = write.chunk;
      if (this.silent) {
        return false;
      }
      const level = this.level || this.parent && this.parent.level;
      if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (this.handleExceptions || info.exception !== true) {
          return true;
        }
      }
      return false;
    };
    TransportStream.prototype._nop = function _nop() {
      return void 0;
    };
  }
});

// node_modules/winston-transport/legacy.js
var require_legacy = __commonJS({
  "node_modules/winston-transport/legacy.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var { LEVEL } = require_triple_beam();
    var TransportStream = require_modern();
    var LegacyTransportStream = module2.exports = function LegacyTransportStream2(options = {}) {
      TransportStream.call(this, options);
      if (!options.transport || typeof options.transport.log !== "function") {
        throw new Error("Invalid transport, must be an object with a log method.");
      }
      this.transport = options.transport;
      this.level = this.level || options.transport.level;
      this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
      this._deprecated();
      function transportError(err) {
        this.emit("error", err, this.transport);
      }
      if (!this.transport.__winstonError) {
        this.transport.__winstonError = transportError.bind(this);
        this.transport.on("error", this.transport.__winstonError);
      }
    };
    util.inherits(LegacyTransportStream, TransportStream);
    LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
        this.transport.log(info[LEVEL], info.message, info, this._nop);
      }
      callback(null);
    };
    LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
      for (let i = 0; i < chunks.length; i++) {
        if (this._accept(chunks[i])) {
          this.transport.log(
            chunks[i].chunk[LEVEL],
            chunks[i].chunk.message,
            chunks[i].chunk,
            this._nop
          );
          chunks[i].callback();
        }
      }
      return callback(null);
    };
    LegacyTransportStream.prototype._deprecated = function _deprecated() {
      console.error([
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
      ].join("\n"));
    };
    LegacyTransportStream.prototype.close = function close() {
      if (this.transport.close) {
        this.transport.close();
      }
      if (this.transport.__winstonError) {
        this.transport.removeListener("error", this.transport.__winstonError);
        this.transport.__winstonError = null;
      }
    };
  }
});

// node_modules/winston-transport/index.js
var require_winston_transport = __commonJS({
  "node_modules/winston-transport/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_modern();
    module2.exports.LegacyTransportStream = require_legacy();
  }
});

// node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS({
  "node_modules/winston/lib/winston/transports/console.js"(exports, module2) {
    "use strict";
    var os2 = require("os");
    var { LEVEL, MESSAGE } = require_triple_beam();
    var TransportStream = require_winston_transport();
    module2.exports = class Console extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "console";
        this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
        this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
        this.eol = typeof options.eol === "string" ? options.eol : os2.EOL;
        this.setMaxListeners(30);
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.stderrLevels[info[LEVEL]]) {
          if (console._stderr) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            console.error(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        } else if (this.consoleWarnLevels[info[LEVEL]]) {
          if (console._stderr) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            console.warn(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        }
        if (console._stdout) {
          console._stdout.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          console.log(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
      }
      /**
       * Returns a Set-like object with strArray's elements as keys (each with the
       * value true).
       * @param {Array} strArray - Array of Set-elements as strings.
       * @param {?string} [errMsg] - Custom error message thrown on invalid input.
       * @returns {Object} - TODO: add return description.
       * @private
       */
      _stringArrayToSet(strArray, errMsg) {
        if (!strArray)
          return {};
        errMsg = errMsg || "Cannot make set from type other than Array of string elements";
        if (!Array.isArray(strArray)) {
          throw new Error(errMsg);
        }
        return strArray.reduce((set, el) => {
          if (typeof el !== "string") {
            throw new Error(errMsg);
          }
          set[el] = true;
          return set;
        }, {});
      }
    };
  }
});

// node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/async/internal/isArrayLike.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isArrayLike;
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    };
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.fallback = fallback;
    exports.wrap = wrap;
    var hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer;
    if (hasQueueMicrotask) {
      _defer = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports.default = wrap(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = asyncify;
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    var _wrapAsync = require_wrapAsync();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      if ((0, _wrapAsync.isAsync)(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        (0, _setImmediate2.default)((e) => {
          throw e;
        }, err);
      }
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports.default = wrapAsync;
    exports.isAsync = isAsync;
    exports.isAsyncGenerator = isAsyncGenerator;
    exports.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS({
  "node_modules/async/internal/awaitify.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = awaitify;
    function awaitify(asyncFn, arity) {
      if (!arity)
        arity = asyncFn.length;
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/async/internal/parallel.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = once;
    function once(fn) {
      function wrapper(...args) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    };
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/async/internal/iterator.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createIterator;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done)
          return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
          return next();
        }
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = onlyOnce;
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var breakLoop = {};
    exports.default = breakLoop;
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS({
  "node_modules/async/internal/asyncEachOfLimit.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = asyncEachOfLimit;
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _asyncEachOfLimit = require_asyncEachOfLimit();
    var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (limit) => {
      return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    module2.exports = exports.default;
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports.default = (0, _awaitify2.default)(eachOfLimit, 4);
    module2.exports = exports.default;
  }
});

// node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS({
  "node_modules/async/eachOfSeries.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfSeries(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
    }
    exports.default = (0, _awaitify2.default)(eachOfSeries, 3);
    module2.exports = exports.default;
  }
});

// node_modules/async/series.js
var require_series = __commonJS({
  "node_modules/async/series.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = series;
    var _parallel2 = require_parallel();
    var _parallel3 = _interopRequireDefault(_parallel2);
    var _eachOfSeries = require_eachOfSeries();
    var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function series(tasks, callback) {
      return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
    }
    module2.exports = exports.default;
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors2().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors2().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports = module2.exports = require_stream_readable();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
      exports.finished = require_end_of_stream();
      exports.pipeline = require_pipeline();
    }
  }
});

// node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS({
  "node_modules/@dabh/diagnostics/diagnostics.js"(exports, module2) {
    var adapters = [];
    var modifiers = [];
    var logger = function devnull() {
    };
    function use(adapter) {
      if (~adapters.indexOf(adapter))
        return false;
      adapters.push(adapter);
      return true;
    }
    function set(custom) {
      logger = custom;
    }
    function enabled(namespace) {
      var async = [];
      for (var i = 0; i < adapters.length; i++) {
        if (adapters[i].async) {
          async.push(adapters[i]);
          continue;
        }
        if (adapters[i](namespace))
          return true;
      }
      if (!async.length)
        return false;
      return new Promise(function pinky(resolve) {
        Promise.all(
          async.map(function prebind(fn) {
            return fn(namespace);
          })
        ).then(function resolved(values) {
          resolve(values.some(Boolean));
        });
      });
    }
    function modify(fn) {
      if (~modifiers.indexOf(fn))
        return false;
      modifiers.push(fn);
      return true;
    }
    function write() {
      logger.apply(logger, arguments);
    }
    function process2(message) {
      for (var i = 0; i < modifiers.length; i++) {
        message = modifiers[i].apply(modifiers[i], arguments);
      }
      return message;
    }
    function introduce(fn, options) {
      var has = Object.prototype.hasOwnProperty;
      for (var key in options) {
        if (has.call(options, key)) {
          fn[key] = options[key];
        }
      }
      return fn;
    }
    function nope(options) {
      options.enabled = false;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(function diagnopes() {
        return false;
      }, options);
    }
    function yep(options) {
      function diagnostics() {
        var args = Array.prototype.slice.call(arguments, 0);
        write.call(write, options, process2(args, options));
        return true;
      }
      options.enabled = true;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(diagnostics, options);
    }
    module2.exports = function create(diagnostics) {
      diagnostics.introduce = introduce;
      diagnostics.enabled = enabled;
      diagnostics.process = process2;
      diagnostics.modify = modify;
      diagnostics.write = write;
      diagnostics.nope = nope;
      diagnostics.yep = yep;
      diagnostics.set = set;
      diagnostics.use = use;
      return diagnostics;
    };
  }
});

// node_modules/@dabh/diagnostics/node/production.js
var require_production = __commonJS({
  "node_modules/@dabh/diagnostics/node/production.js"(exports, module2) {
    var create = require_diagnostics();
    var diagnostics = create(function prod(namespace, options) {
      options = options || {};
      options.namespace = namespace;
      options.prod = true;
      options.dev = false;
      if (!(options.force || prod.force))
        return prod.nope(options);
      return prod.yep(options);
    });
    module2.exports = diagnostics;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s = clamp(parseFloat(match[2]), 0, 100);
        var l = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color/node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color/node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color/node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color/node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports, module2) {
    "use strict";
    var colorString = require_color_string();
    var convert = require_color_convert();
    var _slice = [].slice;
    var skippedModels = [
      // to be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // gray conflicts with some method names, and has its own method defined.
      "gray",
      // shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert).forEach(function(model) {
      hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color(obj, model) {
      if (!(this instanceof Color)) {
        return new Color(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      var i;
      var channels;
      if (obj == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (obj instanceof Color) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result = colorString.get(obj);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys = Object.keys(obj);
        if ("alpha" in obj) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert[this.model].labels;
        var color = [];
        for (i = 0; i < labels.length; i++) {
          color.push(obj[labels[i]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          var limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString: function() {
        return this.string();
      },
      toJSON: function() {
        return this[this.model]();
      },
      string: function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args);
      },
      percentString: function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args);
      },
      array: function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      },
      object: function() {
        var result = {};
        var channels = convert[this.model].channels;
        var labels = convert[this.model].labels;
        for (var i = 0; i < channels; i++) {
          result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray: function() {
        var rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject: function() {
        var rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round: function(places) {
        places = Math.max(places || 0, 0);
        return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      },
      alpha: function(val) {
        if (arguments.length) {
          return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      },
      // rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      // eslint-disable-line brace-style
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return convert[this.model].keyword(this.color);
      },
      hex: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      rgbNumber: function() {
        var rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity: function() {
        var rgb = this.rgb().color;
        var lum = [];
        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color2) {
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark: function() {
        var rgb = this.rgb().color;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
        return yiq < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      negate: function() {
        var rgb = this.rgb();
        for (var i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten: function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken: function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale: function() {
        var rgb = this.rgb().color;
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(val, val, val);
      },
      fade: function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer: function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate: function(degrees) {
        var hsl = this.hsl();
        var hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix: function(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        var color1 = mixinColor.rgb();
        var color2 = this.rgb();
        var p = weight === void 0 ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        var w2 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p + color2.alpha() * (1 - p)
        );
      }
    };
    Object.keys(convert).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert[model].channels;
      Color.prototype[model] = function() {
        if (this.model === model) {
          return new Color(this);
        }
        if (arguments.length) {
          return new Color(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color[model] = function(color) {
        if (typeof color === "number") {
          color = zeroArray(_slice.call(arguments), channels);
        }
        return new Color(color, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      model.forEach(function(m) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result = this[model]();
          result.color[channel] = val;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function zeroArray(arr, length) {
      for (var i = 0; i < length; i++) {
        if (typeof arr[i] !== "number") {
          arr[i] = 0;
        }
      }
      return arr;
    }
    module2.exports = Color;
  }
});

// node_modules/text-hex/index.js
var require_text_hex = __commonJS({
  "node_modules/text-hex/index.js"(exports, module2) {
    "use strict";
    module2.exports = function hex(str) {
      for (var i = 0, hash = 0; i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash))
        ;
      var color = Math.floor(
        Math.abs(
          Math.sin(hash) * 1e4 % 1 * 16777216
        )
      ).toString(16);
      return "#" + Array(6 - color.length + 1).join("0") + color;
    };
  }
});

// node_modules/colorspace/index.js
var require_colorspace = __commonJS({
  "node_modules/colorspace/index.js"(exports, module2) {
    "use strict";
    var color = require_color();
    var hex = require_text_hex();
    module2.exports = function colorspace(namespace, delimiter) {
      var split = namespace.split(delimiter || ":");
      var base = hex(split[0]);
      if (!split.length)
        return base;
      for (var i = 0, l = split.length - 1; i < l; i++) {
        base = color(base).mix(color(hex(split[i + 1]))).saturate(1).hex();
      }
      return base;
    };
  }
});

// node_modules/kuler/index.js
var require_kuler = __commonJS({
  "node_modules/kuler/index.js"(exports, module2) {
    "use strict";
    function Kuler(text, color) {
      if (color)
        return new Kuler(text).style(color);
      if (!(this instanceof Kuler))
        return new Kuler(text);
      this.text = text;
    }
    Kuler.prototype.prefix = "\x1B[";
    Kuler.prototype.suffix = "m";
    Kuler.prototype.hex = function hex(color) {
      color = color[0] === "#" ? color.substring(1) : color;
      if (color.length === 3) {
        color = color.split("");
        color[5] = color[2];
        color[4] = color[2];
        color[3] = color[1];
        color[2] = color[1];
        color[1] = color[0];
        color = color.join("");
      }
      var r = color.substring(0, 2), g = color.substring(2, 4), b = color.substring(4, 6);
      return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
    };
    Kuler.prototype.rgb = function rgb(r, g, b) {
      var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
      return this.ansi(red, green, blue);
    };
    Kuler.prototype.ansi = function ansi(r, g, b) {
      var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
      return 16 + red * 36 + green * 6 + blue;
    };
    Kuler.prototype.reset = function reset() {
      return this.prefix + "39;49" + this.suffix;
    };
    Kuler.prototype.style = function style(color) {
      return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
    };
    module2.exports = Kuler;
  }
});

// node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS({
  "node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js"(exports, module2) {
    var colorspace = require_colorspace();
    var kuler = require_kuler();
    module2.exports = function ansiModifier(args, options) {
      var namespace = options.namespace;
      var ansi = options.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
      args[0] = ansi + " " + args[0];
      return args;
    };
  }
});

// node_modules/enabled/index.js
var require_enabled = __commonJS({
  "node_modules/enabled/index.js"(exports, module2) {
    "use strict";
    module2.exports = function enabled(name, variable) {
      if (!variable)
        return false;
      var variables = variable.split(/[\s,]+/), i = 0;
      for (; i < variables.length; i++) {
        variable = variables[i].replace("*", ".*?");
        if ("-" === variable.charAt(0)) {
          if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
            return false;
          }
          continue;
        }
        if (new RegExp("^" + variable + "$").test(name)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/index.js"(exports, module2) {
    var enabled = require_enabled();
    module2.exports = function create(fn) {
      return function adapter(namespace) {
        try {
          return enabled(namespace, fn());
        } catch (e) {
        }
        return false;
      };
    };
  }
});

// node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/process.env.js"(exports, module2) {
    var adapter = require_adapters();
    module2.exports = adapter(function processenv() {
      return process.env.DEBUG || process.env.DIAGNOSTICS;
    });
  }
});

// node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS({
  "node_modules/@dabh/diagnostics/logger/console.js"(exports, module2) {
    module2.exports = function(meta, messages) {
      try {
        Function.prototype.apply.call(console.log, console, messages);
      } catch (e) {
      }
    };
  }
});

// node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS({
  "node_modules/@dabh/diagnostics/node/development.js"(exports, module2) {
    var create = require_diagnostics();
    var tty = require("tty").isatty(1);
    var diagnostics = create(function dev(namespace, options) {
      options = options || {};
      options.colors = "colors" in options ? options.colors : tty;
      options.namespace = namespace;
      options.prod = false;
      options.dev = true;
      if (!dev.enabled(namespace) && !(options.force || dev.force)) {
        return dev.nope(options);
      }
      return dev.yep(options);
    });
    diagnostics.modify(require_namespace_ansi());
    diagnostics.use(require_process_env());
    diagnostics.set(require_console2());
    module2.exports = diagnostics;
  }
});

// node_modules/@dabh/diagnostics/node/index.js
var require_node2 = __commonJS({
  "node_modules/@dabh/diagnostics/node/index.js"(exports, module2) {
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_production();
    } else {
      module2.exports = require_development();
    }
  }
});

// node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS({
  "node_modules/winston/lib/winston/tail-file.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var { StringDecoder } = require("string_decoder");
    var { Stream } = require_readable();
    function noop() {
    }
    module2.exports = (options, iter) => {
      const buffer = Buffer.alloc(64 * 1024);
      const decode = new StringDecoder("utf8");
      const stream = new Stream();
      let buff = "";
      let pos = 0;
      let row = 0;
      if (options.start === -1) {
        delete options.start;
      }
      stream.readable = true;
      stream.destroy = () => {
        stream.destroyed = true;
        stream.emit("end");
        stream.emit("close");
      };
      fs.open(options.file, "a+", "0644", (err, fd) => {
        if (err) {
          if (!iter) {
            stream.emit("error", err);
          } else {
            iter(err);
          }
          stream.destroy();
          return;
        }
        (function read() {
          if (stream.destroyed) {
            fs.close(fd, noop);
            return;
          }
          return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
            if (error) {
              if (!iter) {
                stream.emit("error", error);
              } else {
                iter(error);
              }
              stream.destroy();
              return;
            }
            if (!bytes) {
              if (buff) {
                if (options.start == null || row > options.start) {
                  if (!iter) {
                    stream.emit("line", buff);
                  } else {
                    iter(null, buff);
                  }
                }
                row++;
                buff = "";
              }
              return setTimeout(read, 1e3);
            }
            let data = decode.write(buffer.slice(0, bytes));
            if (!iter) {
              stream.emit("data", data);
            }
            data = (buff + data).split(/\n+/);
            const l = data.length - 1;
            let i = 0;
            for (; i < l; i++) {
              if (options.start == null || row > options.start) {
                if (!iter) {
                  stream.emit("line", data[i]);
                } else {
                  iter(null, data[i]);
                }
              }
              row++;
            }
            buff = data[l];
            pos += bytes;
            return read();
          });
        })();
      });
      if (!iter) {
        return stream;
      }
      return stream.destroy;
    };
  }
});

// node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS({
  "node_modules/winston/lib/winston/transports/file.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var asyncSeries = require_series();
    var zlib = require("zlib");
    var { MESSAGE } = require_triple_beam();
    var { Stream, PassThrough } = require_readable();
    var TransportStream = require_winston_transport();
    var debug = require_node2()("winston:file");
    var os2 = require("os");
    var tailFile = require_tail_file();
    module2.exports = class File extends TransportStream {
      /**
       * Constructor function for the File transport object responsible for
       * persisting log messages and metadata to one or more files.
       * @param {Object} options - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "file";
        function throwIf(target, ...args) {
          args.slice(1).forEach((name) => {
            if (options[name]) {
              throw new Error(`Cannot set ${name} and ${target} together`);
            }
          });
        }
        this._stream = new PassThrough();
        this._stream.setMaxListeners(30);
        this._onError = this._onError.bind(this);
        if (options.filename || options.dirname) {
          throwIf("filename or dirname", "stream");
          this._basename = this.filename = options.filename ? path.basename(options.filename) : "winston.log";
          this.dirname = options.dirname || path.dirname(options.filename);
          this.options = options.options || { flags: "a" };
        } else if (options.stream) {
          console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
          throwIf("stream", "filename", "maxsize");
          this._dest = this._stream.pipe(this._setupStream(options.stream));
          this.dirname = path.dirname(this._dest.path);
        } else {
          throw new Error("Cannot log to file without filename or stream.");
        }
        this.maxsize = options.maxsize || null;
        this.rotationFormat = options.rotationFormat || false;
        this.zippedArchive = options.zippedArchive || false;
        this.maxFiles = options.maxFiles || null;
        this.eol = typeof options.eol === "string" ? options.eol : os2.EOL;
        this.tailable = options.tailable || false;
        this.lazy = options.lazy || false;
        this._size = 0;
        this._pendingSize = 0;
        this._created = 0;
        this._drain = false;
        this._opening = false;
        this._ending = false;
        this._fileExist = false;
        if (this.dirname)
          this._createLogDirIfNotExist(this.dirname);
        if (!this.lazy)
          this.open();
      }
      finishIfEnding() {
        if (this._ending) {
          if (this._opening) {
            this.once("open", () => {
              this._stream.once("finish", () => this.emit("finish"));
              setImmediate(() => this._stream.end());
            });
          } else {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          }
        }
      }
      /**
       * Core logging method exposed to Winston. Metadata is optional.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback = () => {
      }) {
        if (this.silent) {
          callback();
          return true;
        }
        if (this._drain) {
          this._stream.once("drain", () => {
            this._drain = false;
            this.log(info, callback);
          });
          return;
        }
        if (this._rotate) {
          this._stream.once("rotate", () => {
            this._rotate = false;
            this.log(info, callback);
          });
          return;
        }
        if (this.lazy) {
          if (!this._fileExist) {
            if (!this._opening) {
              this.open();
            }
            this.once("open", () => {
              this._fileExist = true;
              this.log(info, callback);
              return;
            });
            return;
          }
          if (this._needsNewFile(this._pendingSize)) {
            this._dest.once("close", () => {
              if (!this._opening) {
                this.open();
              }
              this.once("open", () => {
                this.log(info, callback);
                return;
              });
              return;
            });
            return;
          }
        }
        const output = `${info[MESSAGE]}${this.eol}`;
        const bytes = Buffer.byteLength(output);
        function logged() {
          this._size += bytes;
          this._pendingSize -= bytes;
          debug("logged %s %s", this._size, output);
          this.emit("logged", info);
          if (this._rotate) {
            return;
          }
          if (this._opening) {
            return;
          }
          if (!this._needsNewFile()) {
            return;
          }
          if (this.lazy) {
            this._endStream(() => {
              this.emit("fileclosed");
            });
            return;
          }
          this._rotate = true;
          this._endStream(() => this._rotateFile());
        }
        this._pendingSize += bytes;
        if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
          this.rotatedWhileOpening = true;
        }
        const written = this._stream.write(output, logged.bind(this));
        if (!written) {
          this._drain = true;
          this._stream.once("drain", () => {
            this._drain = false;
            callback();
          });
        } else {
          callback();
        }
        debug("written", written, this._drain);
        this.finishIfEnding();
        return written;
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options - Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * TODO: Refactor me.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = normalizeQuery(options);
        const file = path.join(this.dirname, this.filename);
        let buff = "";
        let results = [];
        let row = 0;
        const stream = fs.createReadStream(file, {
          encoding: "utf8"
        });
        stream.on("error", (err) => {
          if (stream.readable) {
            stream.destroy();
          }
          if (!callback) {
            return;
          }
          return err.code !== "ENOENT" ? callback(err) : callback(null, results);
        });
        stream.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            if (!options.start || row >= options.start) {
              add(data[i]);
            }
            row++;
          }
          buff = data[l];
        });
        stream.on("close", () => {
          if (buff) {
            add(buff, true);
          }
          if (options.order === "desc") {
            results = results.reverse();
          }
          if (callback)
            callback(null, results);
        });
        function add(buff2, attempt) {
          try {
            const log = JSON.parse(buff2);
            if (check(log)) {
              push(log);
            }
          } catch (e) {
            if (!attempt) {
              stream.emit("error", e);
            }
          }
        }
        function push(log) {
          if (options.rows && results.length >= options.rows && options.order !== "desc") {
            if (stream.readable) {
              stream.destroy();
            }
            return;
          }
          if (options.fields) {
            log = options.fields.reduce((obj, key) => {
              obj[key] = log[key];
              return obj;
            }, {});
          }
          if (options.order === "desc") {
            if (results.length >= options.rows) {
              results.shift();
            }
          }
          results.push(log);
        }
        function check(log) {
          if (!log) {
            return;
          }
          if (typeof log !== "object") {
            return;
          }
          const time = new Date(log.timestamp);
          if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
            return;
          }
          return true;
        }
        function normalizeQuery(options2) {
          options2 = options2 || {};
          options2.rows = options2.rows || options2.limit || 10;
          options2.start = options2.start || 0;
          options2.until = options2.until || new Date();
          if (typeof options2.until !== "object") {
            options2.until = new Date(options2.until);
          }
          options2.from = options2.from || options2.until - 24 * 60 * 60 * 1e3;
          if (typeof options2.from !== "object") {
            options2.from = new Date(options2.from);
          }
          options2.order = options2.order || "desc";
          return options2;
        }
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       * TODO: Refactor me.
       */
      stream(options = {}) {
        const file = path.join(this.dirname, this.filename);
        const stream = new Stream();
        const tail = {
          file,
          start: options.start
        };
        stream.destroy = tailFile(tail, (err, line) => {
          if (err) {
            return stream.emit("error", err);
          }
          try {
            stream.emit("data", line);
            line = JSON.parse(line);
            stream.emit("log", line);
          } catch (e) {
            stream.emit("error", e);
          }
        });
        return stream;
      }
      /**
       * Checks to see the filesize of.
       * @returns {undefined}
       */
      open() {
        if (!this.filename)
          return;
        if (this._opening)
          return;
        this._opening = true;
        this.stat((err, size) => {
          if (err) {
            return this.emit("error", err);
          }
          debug("stat done: %s { size: %s }", this.filename, size);
          this._size = size;
          this._dest = this._createStream(this._stream);
          this._opening = false;
          this.once("open", () => {
            if (this._stream.eventNames().includes("rotate")) {
              this._stream.emit("rotate");
            } else {
              this._rotate = false;
            }
          });
        });
      }
      /**
       * Stat the file and assess information in order to create the proper stream.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      stat(callback) {
        const target = this._getFile();
        const fullpath = path.join(this.dirname, target);
        fs.stat(fullpath, (err, stat) => {
          if (err && err.code === "ENOENT") {
            debug("ENOENT\xA0ok", fullpath);
            this.filename = target;
            return callback(null, 0);
          }
          if (err) {
            debug(`err ${err.code} ${fullpath}`);
            return callback(err);
          }
          if (!stat || this._needsNewFile(stat.size)) {
            return this._incFile(() => this.stat(callback));
          }
          this.filename = target;
          callback(null, stat.size);
        });
      }
      /**
       * Closes the stream associated with this instance.
       * @param {function} cb - TODO: add param description.
       * @returns {undefined}
       */
      close(cb) {
        if (!this._stream) {
          return;
        }
        this._stream.end(() => {
          if (cb) {
            cb();
          }
          this.emit("flush");
          this.emit("closed");
        });
      }
      /**
       * TODO: add method description.
       * @param {number} size - TODO: add param description.
       * @returns {undefined}
       */
      _needsNewFile(size) {
        size = size || this._size;
        return this.maxsize && size >= this.maxsize;
      }
      /**
       * TODO: add method description.
       * @param {Error} err - TODO: add param description.
       * @returns {undefined}
       */
      _onError(err) {
        this.emit("error", err);
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _setupStream(stream) {
        stream.on("error", this._onError);
        return stream;
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _cleanupStream(stream) {
        stream.removeListener("error", this._onError);
        stream.destroy();
        return stream;
      }
      /**
       * TODO: add method description.
       */
      _rotateFile() {
        this._incFile(() => this.open());
      }
      /**
       * Unpipe from the stream that has been marked as full and end it so it
       * flushes to disk.
       *
       * @param {function} callback - Callback for when the current file has closed.
       * @private
       */
      _endStream(callback = () => {
      }) {
        if (this._dest) {
          this._stream.unpipe(this._dest);
          this._dest.end(() => {
            this._cleanupStream(this._dest);
            callback();
          });
        } else {
          callback();
        }
      }
      /**
       * Returns the WritableStream for the active file on this instance. If we
       * should gzip the file then a zlib stream is returned.
       *
       * @param {ReadableStream} source –PassThrough to pipe to the file when open.
       * @returns {WritableStream} Stream that writes to disk for the active file.
       */
      _createStream(source) {
        const fullpath = path.join(this.dirname, this.filename);
        debug("create stream start", fullpath, this.options);
        const dest = fs.createWriteStream(fullpath, this.options).on("error", (err) => debug(err)).on("close", () => debug("close", dest.path, dest.bytesWritten)).on("open", () => {
          debug("file open ok", fullpath);
          this.emit("open", fullpath);
          source.pipe(dest);
          if (this.rotatedWhileOpening) {
            this._stream = new PassThrough();
            this._stream.setMaxListeners(30);
            this._rotateFile();
            this.rotatedWhileOpening = false;
            this._cleanupStream(dest);
            source.end();
          }
        });
        debug("create stream ok", fullpath);
        if (this.zippedArchive) {
          const gzip = zlib.createGzip();
          gzip.pipe(dest);
          return gzip;
        }
        return dest;
      }
      /**
       * TODO: add method description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      _incFile(callback) {
        debug("_incFile", this.filename);
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        if (!this.tailable) {
          this._created += 1;
          this._checkMaxFilesIncrementing(ext, basename, callback);
        } else {
          this._checkMaxFilesTailable(ext, basename, callback);
        }
      }
      /**
       * Gets the next filename to use for this instance in the case that log
       * filesizes are being capped.
       * @returns {string} - TODO: add return description.
       * @private
       */
      _getFile() {
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
        const target = !this.tailable && this._created ? `${basename}${isRotation}${ext}` : `${basename}${ext}`;
        return this.zippedArchive && !this.tailable ? `${target}.gz` : target;
      }
      /**
       * Increment the number of files created or checked by this instance.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesIncrementing(ext, basename, callback) {
        if (!this.maxFiles || this._created < this.maxFiles) {
          return setImmediate(callback);
        }
        const oldest = this._created - this.maxFiles;
        const isOldest = oldest !== 0 ? oldest : "";
        const isZipped = this.zippedArchive ? ".gz" : "";
        const filePath = `${basename}${isOldest}${ext}${isZipped}`;
        const target = path.join(this.dirname, filePath);
        fs.unlink(target, callback);
      }
      /**
       * Roll files forward based on integer, up to maxFiles. e.g. if base if
       * file.log and it becomes oversized, roll to file1.log, and allow file.log
       * to be re-used. If file is oversized again, roll file1.log to file2.log,
       * roll file.log to file1.log, and so on.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesTailable(ext, basename, callback) {
        const tasks = [];
        if (!this.maxFiles) {
          return;
        }
        const isZipped = this.zippedArchive ? ".gz" : "";
        for (let x = this.maxFiles - 1; x > 1; x--) {
          tasks.push(function(i, cb) {
            let fileName = `${basename}${i - 1}${ext}${isZipped}`;
            const tmppath = path.join(this.dirname, fileName);
            fs.exists(tmppath, (exists) => {
              if (!exists) {
                return cb(null);
              }
              fileName = `${basename}${i}${ext}${isZipped}`;
              fs.rename(tmppath, path.join(this.dirname, fileName), cb);
            });
          }.bind(this, x));
        }
        asyncSeries(tasks, () => {
          fs.rename(
            path.join(this.dirname, `${basename}${ext}`),
            path.join(this.dirname, `${basename}1${ext}${isZipped}`),
            callback
          );
        });
      }
      _createLogDirIfNotExist(dirPath) {
        if (!fs.existsSync(dirPath)) {
          fs.mkdirSync(dirPath, { recursive: true });
        }
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS({
  "node_modules/winston/lib/winston/transports/http.js"(exports, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var { Stream } = require_readable();
    var TransportStream = require_winston_transport();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = class Http extends TransportStream {
      /**
       * Constructor function for the Http transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      // eslint-disable-next-line max-statements
      constructor(options = {}) {
        super(options);
        this.options = options;
        this.name = options.name || "http";
        this.ssl = !!options.ssl;
        this.host = options.host || "localhost";
        this.port = options.port;
        this.auth = options.auth;
        this.path = options.path || "";
        this.agent = options.agent;
        this.headers = options.headers || {};
        this.headers["content-type"] = "application/json";
        this.batch = options.batch || false;
        this.batchInterval = options.batchInterval || 5e3;
        this.batchCount = options.batchCount || 10;
        this.batchOptions = [];
        this.batchTimeoutID = -1;
        this.batchCallback = {};
        if (!this.port) {
          this.port = this.ssl ? 443 : 80;
        }
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        this._request(info, null, null, (err, res) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            this.emit("warn", err);
          } else {
            this.emit("logged", info);
          }
        });
        if (callback) {
          setImmediate(callback);
        }
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options -  Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * @returns {undefined}
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = {
          method: "query",
          params: this.normalizeQuery(options)
        };
        const auth = options.params.auth || null;
        delete options.params.auth;
        const path = options.params.path || null;
        delete options.params.path;
        this._request(options, auth, path, (err, res, body) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            return callback(err);
          }
          if (typeof body === "string") {
            try {
              body = JSON.parse(body);
            } catch (e) {
              return callback(e);
            }
          }
          callback(null, body);
        });
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description
       */
      stream(options = {}) {
        const stream = new Stream();
        options = {
          method: "stream",
          params: options
        };
        const path = options.params.path || null;
        delete options.params.path;
        const auth = options.params.auth || null;
        delete options.params.auth;
        let buff = "";
        const req = this._request(options, auth, path);
        stream.destroy = () => req.destroy();
        req.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            try {
              stream.emit("log", JSON.parse(data[i]));
            } catch (e) {
              stream.emit("error", e);
            }
          }
          buff = data[l];
        });
        req.on("error", (err) => stream.emit("error", err));
        return stream;
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       * @param {function} callback - Continuation to respond to when complete.
       */
      _request(options, auth, path, callback) {
        options = options || {};
        auth = auth || this.auth;
        path = path || this.path || "";
        if (this.batch) {
          this._doBatch(options, callback, auth, path);
        } else {
          this._doRequest(options, callback, auth, path);
        }
      }
      /**
       * Send or memorize the options according to batch configuration
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatch(options, callback, auth, path) {
        this.batchOptions.push(options);
        if (this.batchOptions.length === 1) {
          const me = this;
          this.batchCallback = callback;
          this.batchTimeoutID = setTimeout(function() {
            me.batchTimeoutID = -1;
            me._doBatchRequest(me.batchCallback, auth, path);
          }, this.batchInterval);
        }
        if (this.batchOptions.length === this.batchCount) {
          this._doBatchRequest(this.batchCallback, auth, path);
        }
      }
      /**
       * Initiate a request with the memorized batch options, stop the batch timeout
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatchRequest(callback, auth, path) {
        if (this.batchTimeoutID > 0) {
          clearTimeout(this.batchTimeoutID);
          this.batchTimeoutID = -1;
        }
        const batchOptionsCopy = this.batchOptions.slice();
        this.batchOptions = [];
        this._doRequest(batchOptionsCopy, callback, auth, path);
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doRequest(options, callback, auth, path) {
        const headers = Object.assign({}, this.headers);
        if (auth && auth.bearer) {
          headers.Authorization = `Bearer ${auth.bearer}`;
        }
        const req = (this.ssl ? https : http).request({
          ...this.options,
          method: "POST",
          host: this.host,
          port: this.port,
          path: `/${path.replace(/^\//, "")}`,
          headers,
          auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
          agent: this.agent
        });
        req.on("error", callback);
        req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
        req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
      }
    };
  }
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/is-stream/index.js"(exports, module2) {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
    module2.exports = isStream;
  }
});

// node_modules/winston/lib/winston/transports/stream.js
var require_stream3 = __commonJS({
  "node_modules/winston/lib/winston/transports/stream.js"(exports, module2) {
    "use strict";
    var isStream = require_is_stream();
    var { MESSAGE } = require_triple_beam();
    var os2 = require("os");
    var TransportStream = require_winston_transport();
    module2.exports = class Stream extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        if (!options.stream || !isStream(options.stream)) {
          throw new Error("options.stream is required.");
        }
        this._stream = options.stream;
        this._stream.setMaxListeners(Infinity);
        this.isObjectMode = options.stream._writableState.objectMode;
        this.eol = typeof options.eol === "string" ? options.eol : os2.EOL;
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.isObjectMode) {
          this._stream.write(info);
          if (callback) {
            callback();
          }
          return;
        }
        this._stream.write(`${info[MESSAGE]}${this.eol}`);
        if (callback) {
          callback();
        }
        return;
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/index.js
var require_transports = __commonJS({
  "node_modules/winston/lib/winston/transports/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "Console", {
      configurable: true,
      enumerable: true,
      get() {
        return require_console();
      }
    });
    Object.defineProperty(exports, "File", {
      configurable: true,
      enumerable: true,
      get() {
        return require_file();
      }
    });
    Object.defineProperty(exports, "Http", {
      configurable: true,
      enumerable: true,
      get() {
        return require_http();
      }
    });
    Object.defineProperty(exports, "Stream", {
      configurable: true,
      enumerable: true,
      get() {
        return require_stream3();
      }
    });
  }
});

// node_modules/winston/lib/winston/config/index.js
var require_config2 = __commonJS({
  "node_modules/winston/lib/winston/config/index.js"(exports) {
    "use strict";
    var logform = require_logform();
    var { configs } = require_triple_beam();
    exports.cli = logform.levels(configs.cli);
    exports.npm = logform.levels(configs.npm);
    exports.syslog = logform.levels(configs.syslog);
    exports.addColors = logform.levels;
  }
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/async/eachOf.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback);
      var index = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true)
          return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports.default = (0, _awaitify2.default)(eachOf, 3);
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return (value, index, callback) => iteratee(value, callback);
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/forEach.js
var require_forEach = __commonJS({
  "node_modules/async/forEach.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, iteratee, callback) {
      return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    exports.default = (0, _awaitify2.default)(eachLimit, 3);
    module2.exports = exports.default;
  }
});

// node_modules/fn.name/index.js
var require_fn = __commonJS({
  "node_modules/fn.name/index.js"(exports, module2) {
    "use strict";
    var toString = Object.prototype.toString;
    module2.exports = function name(fn) {
      if ("string" === typeof fn.displayName && fn.constructor.name) {
        return fn.displayName;
      } else if ("string" === typeof fn.name && fn.name) {
        return fn.name;
      }
      if ("object" === typeof fn && fn.constructor && "string" === typeof fn.constructor.name)
        return fn.constructor.name;
      var named = fn.toString(), type = toString.call(fn).slice(8, -1);
      if ("Function" === type) {
        named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
      } else {
        named = type;
      }
      return named || "anonymous";
    };
  }
});

// node_modules/one-time/index.js
var require_one_time = __commonJS({
  "node_modules/one-time/index.js"(exports, module2) {
    "use strict";
    var name = require_fn();
    module2.exports = function one(fn) {
      var called = 0, value;
      function onetime() {
        if (called)
          return value;
        called = 1;
        value = fn.apply(this, arguments);
        fn = null;
        return value;
      }
      onetime.displayName = name(fn);
      return onetime;
    };
  }
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS({
  "node_modules/stack-trace/lib/stack-trace.js"(exports) {
    exports.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      var dummyObject = {};
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports.get);
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    };
    exports.parse = function(err) {
      if (!err.stack) {
        return [];
      }
      var self2 = this;
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return self2._createParsedCallSite({
            fileName: line,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            "native": null
          });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] == ".")
            methodStart--;
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          fileName: lineMatch[2] || null,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          functionName,
          typeName,
          methodName,
          columnNumber: parseInt(lineMatch[4], 10) || null,
          "native": isNative
        };
        return self2._createParsedCallSite(properties);
      }).filter(function(callSite) {
        return !!callSite;
      });
    };
    function CallSite(properties) {
      for (var property in properties) {
        this[property] = properties[property];
      }
    }
    var strProperties = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ];
    var boolProperties = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    strProperties.forEach(function(property) {
      CallSite.prototype[property] = null;
      CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    boolProperties.forEach(function(property) {
      CallSite.prototype[property] = false;
      CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    exports._createParsedCallSite = function(properties) {
      return new CallSite(properties);
    };
  }
});

// node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS({
  "node_modules/winston/lib/winston/exception-stream.js"(exports, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class ExceptionStream extends Writable {
      /**
       * Constructor function for the ExceptionStream responsible for wrapping a
       * TransportStream; only allowing writes of `info` objects with
       * `info.exception` set to true.
       * @param {!TransportStream} transport - Stream to filter to exceptions
       */
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("ExceptionStream requires a TransportStream instance.");
        }
        this.handleExceptions = true;
        this.transport = transport;
      }
      /**
       * Writes the info object to our transport instance if (and only if) the
       * `exception` property is set on the info.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _write(info, enc, callback) {
        if (info.exception) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS({
  "node_modules/winston/lib/winston/exception-handler.js"(exports, module2) {
    "use strict";
    var os2 = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node2()("winston:exception");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class ExceptionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required to handle exceptions");
        }
        this.logger = logger;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `uncaughtException` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._uncaughtException.bind(this);
          process.on("uncaughtException", this.catcher);
        }
      }
      /**
       * Removes any handlers to `uncaughtException` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("uncaughtException", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `uncaughtException: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          exception: true,
          date: new Date().toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os2.loadavg(),
          uptime: os2.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleExceptions = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _uncaughtException(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getExceptionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no exception handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, (handler, next) => {
          const done = once(next);
          const transport = handler.transport || handler;
          function onDone(event) {
            return () => {
              debug(event);
              done();
            };
          }
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, () => doExit && gracefulExit());
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getExceptionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleExceptions;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS({
  "node_modules/winston/lib/winston/rejection-handler.js"(exports, module2) {
    "use strict";
    var os2 = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node2()("winston:rejection");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class RejectionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required to handle rejections");
        }
        this.logger = logger;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `unhandledRejection` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._unhandledRejection.bind(this);
          process.on("unhandledRejection", this.catcher);
        }
      }
      /**
       * Removes any handlers to `unhandledRejection` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("unhandledRejection", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach(
            (wrapper) => this.logger.unpipe(wrapper)
          );
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `unhandledRejection: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          exception: true,
          date: new Date().toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os2.loadavg(),
          uptime: os2.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleRejections = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _unhandledRejection(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getRejectionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no rejection handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(
          handlers,
          (handler, next) => {
            const done = once(next);
            const transport = handler.transport || handler;
            function onDone(event) {
              return () => {
                debug(event);
                done();
              };
            }
            transport._ending = true;
            transport.once("finish", onDone("finished"));
            transport.once("error", onDone("error"));
          },
          () => doExit && gracefulExit()
        );
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getRejectionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleRejections;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS({
  "node_modules/winston/lib/winston/profiler.js"(exports, module2) {
    "use strict";
    var Profiler = class {
      /**
       * Constructor function for the Profiler instance used by
       * `Logger.prototype.startTimer`. When done is called the timer will finish
       * and log the duration.
       * @param {!Logger} logger - TODO: add param description.
       * @private
       */
      constructor(logger) {
        const Logger = require_logger();
        if (typeof logger !== "object" || Array.isArray(logger) || !(logger instanceof Logger)) {
          throw new Error("Logger is required for profiling");
        } else {
          this.logger = logger;
          this.start = Date.now();
        }
      }
      /**
       * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
       * with the duration since creation.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      done(...args) {
        if (typeof args[args.length - 1] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = Date.now() - this.start;
        return this.logger.write(info);
      }
    };
    module2.exports = Profiler;
  }
});

// node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS({
  "node_modules/winston/lib/winston/logger.js"(exports, module2) {
    "use strict";
    var { Stream, Transform } = require_readable();
    var asyncForEach = require_forEach();
    var { LEVEL, SPLAT } = require_triple_beam();
    var isStream = require_is_stream();
    var ExceptionHandler = require_exception_handler();
    var RejectionHandler = require_rejection_handler();
    var LegacyTransportStream = require_legacy();
    var Profiler = require_profiler();
    var { warn } = require_common();
    var config = require_config2();
    var formatRegExp = /%[scdjifoO%]/g;
    var Logger = class extends Transform {
      /**
       * Constructor function for the Logger object responsible for persisting log
       * messages and metadata to one or more transports.
       * @param {!Object} options - foo
       */
      constructor(options) {
        super({ objectMode: true });
        this.configure(options);
      }
      child(defaultRequestMetadata) {
        const logger = this;
        return Object.create(logger, {
          write: {
            value: function(info) {
              const infoClone = Object.assign(
                {},
                defaultRequestMetadata,
                info
              );
              if (info instanceof Error) {
                infoClone.stack = info.stack;
                infoClone.message = info.message;
              }
              logger.write(infoClone);
            }
          }
        });
      }
      /**
       * This will wholesale reconfigure this instance by:
       * 1. Resetting all transports. Older transports will be removed implicitly.
       * 2. Set all other options including levels, colors, rewriters, filters,
       *    exceptionHandlers, etc.
       * @param {!Object} options - TODO: add param description.
       * @returns {undefined}
       */
      configure({
        silent,
        format,
        defaultMeta,
        levels,
        level = "info",
        exitOnError = true,
        transports,
        colors,
        emitErrs,
        formatters,
        padLevels,
        rewriters,
        stripColors,
        exceptionHandlers,
        rejectionHandlers
      } = {}) {
        if (this.transports.length) {
          this.clear();
        }
        this.silent = silent;
        this.format = format || this.format || require_json()();
        this.defaultMeta = defaultMeta || null;
        this.levels = levels || this.levels || config.npm.levels;
        this.level = level;
        if (this.exceptions) {
          this.exceptions.unhandle();
        }
        if (this.rejections) {
          this.rejections.unhandle();
        }
        this.exceptions = new ExceptionHandler(this);
        this.rejections = new RejectionHandler(this);
        this.profilers = {};
        this.exitOnError = exitOnError;
        if (transports) {
          transports = Array.isArray(transports) ? transports : [transports];
          transports.forEach((transport) => this.add(transport));
        }
        if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
          throw new Error(
            [
              "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
              "Use a custom winston.format(function) instead.",
              "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
            ].join("\n")
          );
        }
        if (exceptionHandlers) {
          this.exceptions.handle(exceptionHandlers);
        }
        if (rejectionHandlers) {
          this.rejections.handle(rejectionHandlers);
        }
      }
      isLevelEnabled(level) {
        const givenLevelValue = getLevelValue(this.levels, level);
        if (givenLevelValue === null) {
          return false;
        }
        const configuredLevelValue = getLevelValue(this.levels, this.level);
        if (configuredLevelValue === null) {
          return false;
        }
        if (!this.transports || this.transports.length === 0) {
          return configuredLevelValue >= givenLevelValue;
        }
        const index = this.transports.findIndex((transport) => {
          let transportLevelValue = getLevelValue(this.levels, transport.level);
          if (transportLevelValue === null) {
            transportLevelValue = configuredLevelValue;
          }
          return transportLevelValue >= givenLevelValue;
        });
        return index !== -1;
      }
      /* eslint-disable valid-jsdoc */
      /**
       * Ensure backwards compatibility with a `log` method
       * @param {mixed} level - Level the log message is written at.
       * @param {mixed} msg - TODO: add param description.
       * @param {mixed} meta - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       *
       * @example
       *    // Supports the existing API:
       *    logger.log('info', 'Hello world', { custom: true });
       *    logger.log('info', new Error('Yo, it\'s on fire'));
       *
       *    // Requires winston.format.splat()
       *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
       *
       *    // And the new API with a single JSON literal:
       *    logger.log({ level: 'info', message: 'Hello world', custom: true });
       *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
       *
       *    // Also requires winston.format.splat()
       *    logger.log({
       *      level: 'info',
       *      message: '%s %d%%',
       *      [SPLAT]: ['A string', 50],
       *      meta: { thisIsMeta: true }
       *    });
       *
       */
      /* eslint-enable valid-jsdoc */
      log(level, msg, ...splat) {
        if (arguments.length === 1) {
          level[LEVEL] = level.level;
          this._addDefaultMeta(level);
          this.write(level);
          return this;
        }
        if (arguments.length === 2) {
          if (msg && typeof msg === "object") {
            msg[LEVEL] = msg.level = level;
            this._addDefaultMeta(msg);
            this.write(msg);
            return this;
          }
          msg = { [LEVEL]: level, level, message: msg };
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        const [meta] = splat;
        if (typeof meta === "object" && meta !== null) {
          const tokens = msg && msg.match && msg.match(formatRegExp);
          if (!tokens) {
            const info = Object.assign({}, this.defaultMeta, meta, {
              [LEVEL]: level,
              [SPLAT]: splat,
              level,
              message: msg
            });
            if (meta.message)
              info.message = `${info.message} ${meta.message}`;
            if (meta.stack)
              info.stack = meta.stack;
            this.write(info);
            return this;
          }
        }
        this.write(Object.assign({}, this.defaultMeta, {
          [LEVEL]: level,
          [SPLAT]: splat,
          level,
          message: msg
        }));
        return this;
      }
      /**
       * Pushes data so that it can be picked up by all of our pipe targets.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - Continues stream processing.
       * @returns {undefined}
       * @private
       */
      _transform(info, enc, callback) {
        if (this.silent) {
          return callback();
        }
        if (!info[LEVEL]) {
          info[LEVEL] = info.level;
        }
        if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
          console.error("[winston] Unknown logger level: %s", info[LEVEL]);
        }
        if (!this._readableState.pipes) {
          console.error(
            "[winston] Attempt to write logs with no transports, which can increase memory usage: %j",
            info
          );
        }
        try {
          this.push(this.format.transform(info, this.format.options));
        } finally {
          this._writableState.sync = false;
          callback();
        }
      }
      /**
       * Delays the 'finish' event until all transport pipe targets have
       * also emitted 'finish' or are already finished.
       * @param {mixed} callback - Continues stream processing.
       */
      _final(callback) {
        const transports = this.transports.slice();
        asyncForEach(
          transports,
          (transport, next) => {
            if (!transport || transport.finished)
              return setImmediate(next);
            transport.once("finish", next);
            transport.end();
          },
          callback
        );
      }
      /**
       * Adds the transport to this logger instance by piping to it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      add(transport) {
        const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({ transport }) : transport;
        if (!target._writableState || !target._writableState.objectMode) {
          throw new Error(
            "Transports must WritableStreams in objectMode. Set { objectMode: true }."
          );
        }
        this._onEvent("error", target);
        this._onEvent("warn", target);
        this.pipe(target);
        if (transport.handleExceptions) {
          this.exceptions.handle();
        }
        if (transport.handleRejections) {
          this.rejections.handle();
        }
        return this;
      }
      /**
       * Removes the transport from this logger instance by unpiping from it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      remove(transport) {
        if (!transport)
          return this;
        let target = transport;
        if (!isStream(transport) || transport.log.length > 2) {
          target = this.transports.filter(
            (match) => match.transport === transport
          )[0];
        }
        if (target) {
          this.unpipe(target);
        }
        return this;
      }
      /**
       * Removes all transports from this logger instance.
       * @returns {Logger} - TODO: add return description.
       */
      clear() {
        this.unpipe();
        return this;
      }
      /**
       * Cleans up resources (streams, event listeners) for all transports
       * associated with this instance (if necessary).
       * @returns {Logger} - TODO: add return description.
       */
      close() {
        this.exceptions.unhandle();
        this.rejections.unhandle();
        this.clear();
        this.emit("close");
        return this;
      }
      /**
       * Sets the `target` levels specified on this instance.
       * @param {Object} Target levels to use on this instance.
       */
      setLevels() {
        warn.deprecated("setLevels");
      }
      /**
       * Queries the all transports for this instance with the specified `options`.
       * This will aggregate each transport's results into one object containing
       * a property per transport.
       * @param {Object} options - Query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        const results = {};
        const queryObject = Object.assign({}, options.query || {});
        function queryTransport(transport, next) {
          if (options.query && typeof transport.formatQuery === "function") {
            options.query = transport.formatQuery(queryObject);
          }
          transport.query(options, (err, res) => {
            if (err) {
              return next(err);
            }
            if (typeof transport.formatResults === "function") {
              res = transport.formatResults(res, options.format);
            }
            next(null, res);
          });
        }
        function addResults(transport, next) {
          queryTransport(transport, (err, result) => {
            if (next) {
              result = err || result;
              if (result) {
                results[transport.name] = result;
              }
              next();
            }
            next = null;
          });
        }
        asyncForEach(
          this.transports.filter((transport) => !!transport.query),
          addResults,
          () => callback(null, results)
        );
      }
      /**
       * Returns a log stream for all transports. Options object is optional.
       * @param{Object} options={} - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       */
      stream(options = {}) {
        const out = new Stream();
        const streams = [];
        out._streams = streams;
        out.destroy = () => {
          let i = streams.length;
          while (i--) {
            streams[i].destroy();
          }
        };
        this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
          const str = transport.stream(options);
          if (!str) {
            return;
          }
          streams.push(str);
          str.on("log", (log) => {
            log.transport = log.transport || [];
            log.transport.push(transport.name);
            out.emit("log", log);
          });
          str.on("error", (err) => {
            err.transport = err.transport || [];
            err.transport.push(transport.name);
            out.emit("error", err);
          });
        });
        return out;
      }
      /**
       * Returns an object corresponding to a specific timing. When done is called
       * the timer will finish and log the duration. e.g.:
       * @returns {Profile} - TODO: add return description.
       * @example
       *    const timer = winston.startTimer()
       *    setTimeout(() => {
       *      timer.done({
       *        message: 'Logging message'
       *      });
       *    }, 1000);
       */
      startTimer() {
        return new Profiler(this);
      }
      /**
       * Tracks the time inbetween subsequent calls to this method with the same
       * `id` parameter. The second call to this method will log the difference in
       * milliseconds along with the message.
       * @param {string} id Unique id of the profiler
       * @returns {Logger} - TODO: add return description.
       */
      profile(id, ...args) {
        const time = Date.now();
        if (this.profilers[id]) {
          const timeEnd = this.profilers[id];
          delete this.profilers[id];
          if (typeof args[args.length - 2] === "function") {
            console.warn(
              "Callback function no longer supported as of winston@3.0.0"
            );
            args.pop();
          }
          const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
          info.level = info.level || "info";
          info.durationMs = time - timeEnd;
          info.message = info.message || id;
          return this.write(info);
        }
        this.profilers[id] = time;
        return this;
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      handleExceptions(...args) {
        console.warn(
          "Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()"
        );
        this.exceptions.handle(...args);
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      unhandleExceptions(...args) {
        console.warn(
          "Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()"
        );
        this.exceptions.unhandle(...args);
      }
      /**
       * Throw a more meaningful deprecation notice
       * @throws {Error} - TODO: add throws description.
       */
      cli() {
        throw new Error(
          [
            "Logger.cli() was removed in winston@3.0.0",
            "Use a custom winston.formats.cli() instead.",
            "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
          ].join("\n")
        );
      }
      /**
       * Bubbles the `event` that occured on the specified `transport` up
       * from this instance.
       * @param {string} event - The event that occured
       * @param {Object} transport - Transport on which the event occured
       * @private
       */
      _onEvent(event, transport) {
        function transportEvent(err) {
          if (event === "error" && !this.transports.includes(transport)) {
            this.add(transport);
          }
          this.emit(event, err, transport);
        }
        if (!transport["__winston" + event]) {
          transport["__winston" + event] = transportEvent.bind(this);
          transport.on(event, transport["__winston" + event]);
        }
      }
      _addDefaultMeta(msg) {
        if (this.defaultMeta) {
          Object.assign(msg, this.defaultMeta);
        }
      }
    };
    function getLevelValue(levels, level) {
      const value = levels[level];
      if (!value && value !== 0) {
        return null;
      }
      return value;
    }
    Object.defineProperty(Logger.prototype, "transports", {
      configurable: false,
      enumerable: true,
      get() {
        const { pipes } = this._readableState;
        return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
      }
    });
    module2.exports = Logger;
  }
});

// node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS({
  "node_modules/winston/lib/winston/create-logger.js"(exports, module2) {
    "use strict";
    var { LEVEL } = require_triple_beam();
    var config = require_config2();
    var Logger = require_logger();
    var debug = require_node2()("winston:create-logger");
    function isLevelEnabledFunctionName(level) {
      return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
    }
    module2.exports = function(opts = {}) {
      opts.levels = opts.levels || config.npm.levels;
      class DerivedLogger extends Logger {
        /**
         * Create a new class derived logger for which the levels can be attached to
         * the prototype of. This is a V8 optimization that is well know to increase
         * performance of prototype functions.
         * @param {!Object} options - Options for the created logger.
         */
        constructor(options) {
          super(options);
        }
      }
      const logger = new DerivedLogger(opts);
      Object.keys(opts.levels).forEach(function(level) {
        debug('Define prototype method for "%s"', level);
        if (level === "log") {
          console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
          return;
        }
        DerivedLogger.prototype[level] = function(...args) {
          const self2 = this || logger;
          if (args.length === 1) {
            const [msg] = args;
            const info = msg && msg.message && msg || { message: msg };
            info.level = info[LEVEL] = level;
            self2._addDefaultMeta(info);
            self2.write(info);
            return this || logger;
          }
          if (args.length === 0) {
            self2.log(level, "");
            return self2;
          }
          return self2.log(level, ...args);
        };
        DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
          return (this || logger).isLevelEnabled(level);
        };
      });
      return logger;
    };
  }
});

// node_modules/winston/lib/winston/container.js
var require_container = __commonJS({
  "node_modules/winston/lib/winston/container.js"(exports, module2) {
    "use strict";
    var createLogger = require_create_logger();
    module2.exports = class Container {
      /**
       * Constructor function for the Container object responsible for managing a
       * set of `winston.Logger` instances based on string ids.
       * @param {!Object} [options={}] - Default pass-thru options for Loggers.
       */
      constructor(options = {}) {
        this.loggers = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
       * Retrieves a `winston.Logger` instance for the specified `id`. If an
       * instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      add(id, options) {
        if (!this.loggers.has(id)) {
          options = Object.assign({}, options || this.options);
          const existing = options.transports || this.options.transports;
          if (existing) {
            options.transports = Array.isArray(existing) ? existing.slice() : [existing];
          } else {
            options.transports = [];
          }
          const logger = createLogger(options);
          logger.on("close", () => this._delete(id));
          this.loggers.set(id, logger);
        }
        return this.loggers.get(id);
      }
      /**
       * Retreives a `winston.Logger` instance for the specified `id`. If
       * an instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      get(id, options) {
        return this.add(id, options);
      }
      /**
       * Check if the container has a logger with the id.
       * @param {?string} id - The id of the Logger instance to find.
       * @returns {boolean} - Boolean value indicating if this instance has a
       * logger with the specified `id`.
       */
      has(id) {
        return !!this.loggers.has(id);
      }
      /**
       * Closes a `Logger` instance with the specified `id` if it exists.
       * If no `id` is supplied then all Loggers are closed.
       * @param {?string} id - The id of the Logger instance to close.
       * @returns {undefined}
       */
      close(id) {
        if (id) {
          return this._removeLogger(id);
        }
        this.loggers.forEach((val, key) => this._removeLogger(key));
      }
      /**
       * Remove a logger based on the id.
       * @param {!string} id - The id of the logger to remove.
       * @returns {undefined}
       * @private
       */
      _removeLogger(id) {
        if (!this.loggers.has(id)) {
          return;
        }
        const logger = this.loggers.get(id);
        logger.close();
        this._delete(id);
      }
      /**
       * Deletes a `Logger` instance with the specified `id`.
       * @param {!string} id - The id of the Logger instance to delete from
       * container.
       * @returns {undefined}
       * @private
       */
      _delete(id) {
        this.loggers.delete(id);
      }
    };
  }
});

// node_modules/winston/lib/winston.js
var require_winston = __commonJS({
  "node_modules/winston/lib/winston.js"(exports) {
    "use strict";
    var logform = require_logform();
    var { warn } = require_common();
    exports.version = require_package().version;
    exports.transports = require_transports();
    exports.config = require_config2();
    exports.addColors = logform.levels;
    exports.format = logform.format;
    exports.createLogger = require_create_logger();
    exports.Logger = require_logger();
    exports.ExceptionHandler = require_exception_handler();
    exports.RejectionHandler = require_rejection_handler();
    exports.Container = require_container();
    exports.Transport = require_winston_transport();
    exports.loggers = new exports.Container();
    var defaultLogger = exports.createLogger();
    Object.keys(exports.config.npm.levels).concat([
      "log",
      "query",
      "stream",
      "add",
      "remove",
      "clear",
      "profile",
      "startTimer",
      "handleExceptions",
      "unhandleExceptions",
      "handleRejections",
      "unhandleRejections",
      "configure",
      "child"
    ]).forEach(
      (method) => exports[method] = (...args) => defaultLogger[method](...args)
    );
    Object.defineProperty(exports, "level", {
      get() {
        return defaultLogger.level;
      },
      set(val) {
        defaultLogger.level = val;
      }
    });
    Object.defineProperty(exports, "exceptions", {
      get() {
        return defaultLogger.exceptions;
      }
    });
    ["exitOnError"].forEach((prop) => {
      Object.defineProperty(exports, prop, {
        get() {
          return defaultLogger[prop];
        },
        set(val) {
          defaultLogger[prop] = val;
        }
      });
    });
    Object.defineProperty(exports, "default", {
      get() {
        return {
          exceptionHandlers: defaultLogger.exceptionHandlers,
          rejectionHandlers: defaultLogger.rejectionHandlers,
          transports: defaultLogger.transports
        };
      }
    });
    warn.deprecated(exports, "setLevels");
    warn.forFunctions(exports, "useFormat", ["cli"]);
    warn.forProperties(exports, "useFormat", ["padLevels", "stripColors"]);
    warn.forFunctions(exports, "deprecated", [
      "addRewriter",
      "addFilter",
      "clone",
      "extend"
    ]);
    warn.forProperties(exports, "deprecated", ["emitErrs", "levelLength"]);
  }
});

// node_modules/neovim/lib/utils/logger.js
var require_logger2 = __commonJS({
  "node_modules/neovim/lib/utils/logger.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLogger = void 0;
    var winston = __importStar(require_winston());
    var node_util_1 = require("util");
    var level = process.env.NVIM_NODE_LOG_LEVEL || "debug";
    function getFormat(colorize) {
      return winston.format.combine(winston.format.splat(), winston.format.timestamp({
        format: "YYYY-MM-DD HH:mm:ss"
      }), winston.format.printf((info) => {
        let msg;
        try {
          msg = typeof info.message === "object" ? (0, node_util_1.inspect)(info.message, false, 2, colorize) : info.message;
        } catch (_a) {
          msg = info.message;
        }
        const lvl = info.level === "debug" ? "DBG" : info.level.slice(0, 3).toUpperCase();
        return `${info.timestamp} ${lvl} ${msg}`;
      }));
    }
    function setupWinstonLogger() {
      const logger = winston.createLogger({
        level
      });
      if (process.env.NVIM_NODE_LOG_FILE) {
        logger.add(new winston.transports.File({
          filename: process.env.NVIM_NODE_LOG_FILE,
          level,
          format: getFormat(false)
        }));
      }
      if (process.env.ALLOW_CONSOLE) {
        logger.add(new winston.transports.Console({
          format: getFormat(true)
        }));
      }
      if (!process.env.NVIM_NODE_LOG_FILE && !process.env.ALLOW_CONSOLE) {
        logger.add(new winston.transports.Console({ silent: true }));
      }
      Object.keys(console).forEach((k) => {
        console[k] = function() {
          logger[k === "log" ? "info" : k].apply(logger, arguments);
        };
      });
      return logger;
    }
    var _logger;
    function getLogger() {
      if (!_logger) {
        _logger = setupWinstonLogger();
      }
      return _logger;
    }
    exports.getLogger = getLogger;
  }
});

// node_modules/neovim/lib/api/Base.js
var require_Base = __commonJS({
  "node_modules/neovim/lib/api/Base.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseApi = void 0;
    var node_events_1 = require("events");
    var util_1 = require_util();
    var logger_1 = require_logger2();
    var DO_REQUEST = Symbol("DO_REQUEST");
    var BaseApi = class extends node_events_1.EventEmitter {
      constructor({ transport, data, logger, metadata, client }) {
        super();
        this[_a] = (name, args = []) => new Promise((resolve, reject) => {
          this.transport.request(name, args, (err, res) => {
            if (this.logger.level === "debug") {
              let logData;
              try {
                logData = res && typeof res === "object" ? (0, util_1.partialClone)(res, 2, ["logger", "transport", "client"], "[Object]") : res;
              } catch (_b) {
                logData = String(res);
              }
              this.logger.debug(`response -> ${name}: %O`, logData);
            }
            if (err) {
              reject(new Error(`${name}: ${err[1]}`));
            } else {
              resolve(res);
            }
          });
        });
        this.setTransport(transport);
        this.data = data;
        this.logger = logger || (0, logger_1.getLogger)();
        this.client = client;
        if (metadata) {
          Object.defineProperty(this, "metadata", { value: metadata });
        }
      }
      setTransport(transport) {
        this.transport = transport;
      }
      equals(other) {
        try {
          return String(this.data) === String(other.data);
        } catch (e) {
          return false;
        }
      }
      asyncRequest(name, args = []) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this._isReady;
          this.logger.debug(`request  -> ${name}`);
          return this[DO_REQUEST](name, args).catch((err) => {
            const newError = new Error(err.message);
            this.logger.error(`failed request to "%s": %s: %s`, name, newError.name, newError.message);
            throw newError;
          });
        });
      }
      request(name, args = []) {
        return this.asyncRequest(name, args);
      }
      _getArgsByPrefix(...args) {
        const _args = [];
        if (this.prefix !== "nvim_") {
          _args.push(this);
        }
        return _args.concat(args);
      }
      /** Retrieves a scoped variable depending on type (using `this.prefix`) */
      getVar(name) {
        return __awaiter(this, void 0, void 0, function* () {
          const args = this._getArgsByPrefix(name);
          return this.request(`${this.prefix}get_var`, args).then((res) => res, (err) => {
            if (err && err.message && err.message.includes("not found")) {
              return null;
            }
            throw err;
          });
        });
      }
      /** Set a scoped variable */
      setVar(name, value) {
        const args = this._getArgsByPrefix(name, value);
        return this.request(`${this.prefix}set_var`, args);
      }
      /** Delete a scoped variable */
      deleteVar(name) {
        const args = this._getArgsByPrefix(name);
        return this.request(`${this.prefix}del_var`, args);
      }
      /** Retrieves a scoped option depending on type of `this` */
      getOption(name) {
        const args = this._getArgsByPrefix(name);
        return this.request(`${this.prefix}get_option`, args);
      }
      /** Set scoped option */
      setOption(name, value) {
        const args = this._getArgsByPrefix(name, value);
        return this.request(`${this.prefix}set_option`, args);
      }
      // TODO: Is this necessary?
      /** `request` is basically the same except you can choose to wait forpromise to be resolved */
      notify(name, args) {
        this.logger.debug(`notify -> ${name}`);
        this.transport.notify(name, args);
      }
    };
    exports.BaseApi = BaseApi;
    _a = DO_REQUEST;
  }
});

// node_modules/neovim/lib/api/Buffer.js
var require_Buffer = __commonJS({
  "node_modules/neovim/lib/api/Buffer.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    var _b;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Buffer = exports.ATTACH = exports.DETACH = void 0;
    var Base_1 = require_Base();
    var types_1 = require_types();
    exports.DETACH = Symbol("detachBuffer");
    exports.ATTACH = Symbol("attachBuffer");
    var Buffer2 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = types_1.Metadata[types_1.ExtType.Buffer].prefix;
        this[_a] = (sendBuffer = false, options = {}) => __awaiter(this, void 0, void 0, function* () {
          if (this.client.isAttached(this))
            return true;
          return this.request(`${this.prefix}attach`, [this, sendBuffer, options]);
        });
        this[_b] = () => this.request(`${this.prefix}detach`, [this]);
      }
      get isAttached() {
        return this.client.isAttached(this);
      }
      /**
       * Get the bufnr of Buffer
       */
      get id() {
        return this.data;
      }
      /** Total number of lines in buffer */
      get length() {
        return this.request(`${this.prefix}line_count`, [this]);
      }
      /** Get lines in buffer */
      get lines() {
        return this.getLines();
      }
      /** Gets a changed tick of a buffer */
      get changedtick() {
        return this.request(`${this.prefix}get_changedtick`, [this]);
      }
      get commands() {
        return this.getCommands();
      }
      getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [this, options]);
      }
      /** Get specific lines of buffer */
      getLines({ start, end, strictIndexing } = { start: 0, end: -1, strictIndexing: true }) {
        const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
        return this.request(`${this.prefix}get_lines`, [
          this,
          start,
          end,
          indexing
        ]);
      }
      /** Set lines of buffer given indeces */
      setLines(_lines, { start: _start, end: _end, strictIndexing } = {
        strictIndexing: true
      }) {
        const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
        const lines = typeof _lines === "string" ? [_lines] : _lines;
        const end = typeof _end !== "undefined" ? _end : _start + 1;
        return this.request(`${this.prefix}set_lines`, [
          this,
          _start,
          end,
          indexing,
          lines
        ]);
      }
      /** Insert lines at `start` index */
      insert(lines, start) {
        return this.setLines(lines, {
          start,
          end: start,
          strictIndexing: true
        });
      }
      /** Replace lines starting at `start` index */
      replace(_lines, start) {
        const lines = typeof _lines === "string" ? [_lines] : _lines;
        return this.setLines(lines, {
          start,
          end: start + lines.length,
          strictIndexing: false
        });
      }
      /** Remove lines at index */
      remove(start, end, strictIndexing) {
        return this.setLines([], { start, end, strictIndexing });
      }
      /** Append a string or list of lines to end of buffer */
      append(lines) {
        return this.setLines(lines, {
          start: -1,
          end: -1,
          strictIndexing: false
        });
      }
      /** Get buffer name */
      get name() {
        return this.request(`${this.prefix}get_name`, [this]);
      }
      /** Set current buffer name */
      set name(value) {
        this.request(`${this.prefix}set_name`, [this, value]);
      }
      /** Is current buffer valid */
      get valid() {
        return this.request(`${this.prefix}is_valid`, [this]);
      }
      /** Get mark position given mark name */
      mark(name) {
        return this.request(`${this.prefix}get_mark`, [this, name]);
      }
      // range(start, end) {
      // """Return a `Range` object, which represents part of the Buffer."""
      // return Range(this, start, end)
      // }
      /**
       * Gets a list of buffer-local |mapping| definitions.
       */
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [this, mode]);
      }
      /**
       * Checks if a buffer is valid and loaded. See |api-buffer| for
       * more info about unloaded buffers.
       */
      get loaded() {
        return this.request(`${this.prefix}is_loaded`, [this]);
      }
      /**
       * Returns the byte offset for a line.
       *
       * Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is
       * one byte. 'fileformat' and 'fileencoding' are ignored. The
       * line index just after the last line gives the total byte-count
       * of the buffer. A final EOL byte is counted if it would be
       * written, see 'eol'.
       *
       * Unlike |line2byte()|, throws error for out-of-bounds indexing.
       * Returns -1 for unloaded buffer.
       *
       * @return {Number} Integer byte offset, or -1 for unloaded buffer.
       */
      getOffset(index) {
        return this.request(`${this.prefix}get_offset`, [this, index]);
      }
      /**
       * Adds a highlight to buffer.
       *
       * Useful for plugins that dynamically generate highlights to a
       * buffer (like a semantic highlighter or linter). The function
       * adds a single highlight to a buffer. Unlike |matchaddpos()|
       * highlights follow changes to line numbering (as lines are
       * inserted/removed above the highlighted line), like signs and
       * marks do.
       *
       * Namespaces are used for batch deletion/updating of a set of
       * highlights. To create a namespace, use |nvim_create_namespace|
       * which returns a namespace id. Pass it in to this function as
       * `ns_id` to add highlights to the namespace. All highlights in
       * the same namespace can then be cleared with single call to
       * |nvim_buf_clear_namespace|. If the highlight never will be
       * deleted by an API call, pass `ns_id = -1`.
       *
       * As a shorthand, `ns_id = 0` can be used to create a new
       * namespace for the highlight, the allocated id is then
       * returned. If `hl_group` is the empty string no highlight is
       * added, but a new `ns_id` is still returned. This is supported
       * for backwards compatibility, new code should use
       * |nvim_create_namespace| to create a new empty namespace.
       */
      addHighlight({ hlGroup: _hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId }) {
        const hlGroup = typeof _hlGroup !== "undefined" ? _hlGroup : "";
        const colEnd = typeof _end !== "undefined" ? _end : -1;
        const colStart = typeof _start !== "undefined" ? _start : -0;
        const srcId = typeof _srcId !== "undefined" ? _srcId : -1;
        return this.request(`${this.prefix}add_highlight`, [
          this,
          srcId,
          hlGroup,
          line,
          colStart,
          colEnd
        ]);
      }
      /**
       * Deprecated
       */
      clearHighlight(args = {}) {
        console.warn("`clearHighlight` is deprecated, use ``clearNamespace()` instead");
        const defaults = {
          srcId: -1,
          lineStart: 0,
          lineEnd: -1
        };
        const { srcId, lineStart, lineEnd } = Object.assign(Object.assign({}, defaults), args);
        return this.request(`${this.prefix}clear_highlight`, [
          this,
          srcId,
          lineStart,
          lineEnd
        ]);
      }
      /**
       * Clears namespaced objects, highlights and virtual text, from a line range
       *
       * To clear the namespace in the entire buffer, pass in 0 and -1 to line_start and line_end respectively.
       *
       * @param {Number} nsId Namespace to clear, or -1 to clear all namespaces
       * @param {Number} lineStart Start of range of lines to clear
       * @param {Number} lineEnd End of range of lines to clear (exclusive) or -1 to clear to end of buffer
       */
      clearNamespace(args) {
        const defaults = {
          nsId: -1,
          lineStart: 0,
          lineEnd: -1
        };
        const { nsId, lineStart, lineEnd } = Object.assign(Object.assign({}, defaults), args);
        this.request(`${this.prefix}clear_namespace`, [
          this,
          nsId,
          lineStart,
          lineEnd
        ]);
      }
      /**
       * Set the virtual text (annotation) for a buffer line.
       *
       * By default (and currently the only option) the text will be
       * placed after the buffer text. Virtual text will never cause
       * reflow, rather virtual text will be truncated at the end of
       * the screen line. The virtual text will begin one cell
       * (|lcs-eol| or space) after the ordinary text.
       *
       * Namespaces are used to support batch deletion/updating of
       * virtual text. To create a namespace, use
       * |nvim_create_namespace|. Virtual text is cleared using
       * |nvim_buf_clear_namespace|. The same `ns_id` can be used for
       * both virtual text and highlights added by
       * |nvim_buf_add_highlight|, both can then be cleared with a
       * single call to |nvim_buf_clear_namespace|. If the virtual text
       * never will be cleared by an API call, pass `ns_id = -1`.
       *
       * As a shorthand, `ns_id = 0` can be used to create a new
       * namespace for the virtual text, the allocated id is then
       * returned.
       *
       * @param
       * @param {Number} nsId Namespace to use or 0 to create a namespace, or -1 for a ungrouped annotation
       * @param {Number} line Line to annotate with virtual text (zero-indexed)
       * @param {VirtualTextChunk[]} chunks  A list of [text, hl_group] arrays, each
                                  representing a text chunk with specified
                                  highlight. `hl_group` element can be omitted for
                                  no highlight.
       * @param {Object} opts Optional parameters. Currently not used.
       */
      setVirtualText(nsId, line, chunks, opts = {}) {
        return this.request(`${this.prefix}set_virtual_text`, [
          this,
          nsId,
          line,
          chunks,
          opts
        ]);
      }
      /**
       * Listens to buffer for events
       */
      listen(eventName, cb) {
        if (!this.isAttached) {
          this[exports.ATTACH]().then((attached) => {
            if (!attached) {
              this.unlisten(eventName, cb);
            }
          });
        }
        this.client.attachBuffer(this, eventName, cb);
        return () => {
          this.unlisten(eventName, cb);
        };
      }
      unlisten(eventName, cb) {
        if (!this.isAttached)
          return;
        const shouldDetach = this.client.detachBuffer(this, eventName, cb);
        if (!shouldDetach)
          return;
        this[exports.DETACH]();
      }
    };
    exports.Buffer = Buffer2;
    _a = exports.ATTACH, _b = exports.DETACH;
  }
});

// node_modules/neovim/lib/api/utils/createChainableApi.js
var require_createChainableApi = __commonJS({
  "node_modules/neovim/lib/api/utils/createChainableApi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createChainableApi = void 0;
    var Base_1 = require_Base();
    var baseProperties = Object.getOwnPropertyNames(Base_1.BaseApi.prototype);
    function createChainableApi(name, Type, requestPromise, chainCallPromise) {
      if (this[`${name}Promise`] && this[`${name}Promise`].status === 0 && this[`${name}Proxy`]) {
        return this[`${name}Proxy`];
      }
      this[`${name}Promise`] = requestPromise();
      [...baseProperties, ...Object.getOwnPropertyNames(Type.prototype)].forEach((key) => {
        Object.defineProperty(this[`${name}Promise`], key, {
          enumerable: true,
          writable: true,
          configurable: true
        });
      });
      const proxyHandler = {
        get: (target, prop) => {
          const isOnPrototype = Object.prototype.hasOwnProperty.call(Type.prototype, prop) || Object.prototype.hasOwnProperty.call(Base_1.BaseApi.prototype, prop);
          const descriptor = Object.getOwnPropertyDescriptor(Type.prototype, prop) || Object.getOwnPropertyDescriptor(Base_1.BaseApi.prototype, prop);
          const isGetter = descriptor && (typeof descriptor.get !== "undefined" || typeof descriptor.set !== "undefined");
          if (Type && isOnPrototype) {
            if (isOnPrototype && !isGetter && (prop in Type.prototype && typeof Type.prototype[prop] === "function" || prop in Base_1.BaseApi.prototype && typeof Base_1.BaseApi.prototype[prop] === "function")) {
              return (...args) => this[`${name}Promise`].then((res) => res[prop].call(res, ...args));
            }
            return chainCallPromise && chainCallPromise() || this[`${name}Promise`].then((res) => res[prop]);
          }
          if (prop in target) {
            if (typeof target[prop] === "function") {
              return target[prop].bind(target);
            }
            return target[prop];
          }
          return null;
        },
        set: (target, prop, value, receiver) => {
          if (receiver && (receiver instanceof Promise || "then" in receiver)) {
            receiver.then((obj) => {
              if (prop in obj) {
                obj[prop] = value;
              }
            });
          } else {
            target[prop] = value;
          }
          return true;
        }
      };
      this[`${name}Proxy`] = new Proxy(this[`${name}Promise`], proxyHandler);
      return this[`${name}Proxy`];
    }
    exports.createChainableApi = createChainableApi;
  }
});

// node_modules/neovim/lib/api/Tabpage.js
var require_Tabpage = __commonJS({
  "node_modules/neovim/lib/api/Tabpage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tabpage = void 0;
    var Base_1 = require_Base();
    var types_1 = require_types();
    var createChainableApi_1 = require_createChainableApi();
    var Window_1 = require_Window();
    var Tabpage = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = types_1.Metadata[types_1.ExtType.Tabpage].prefix;
      }
      /** Returns all windows of tabpage */
      get windows() {
        return this.request(`${this.prefix}list_wins`, [this]);
      }
      /** Gets the current window of tabpage */
      get window() {
        return createChainableApi_1.createChainableApi.call(this, "Window", Window_1.Window, () => this.request(`${this.prefix}get_win`, [this]));
      }
      /** Is current tabpage valid */
      get valid() {
        return this.request(`${this.prefix}is_valid`, [this]);
      }
      /** Tabpage number */
      get number() {
        return this.request(`${this.prefix}get_number`, [this]);
      }
      /** Invalid */
      getOption() {
        this.logger.error("Tabpage does not have `getOption`");
      }
      /** Invalid */
      setOption() {
        this.logger.error("Tabpage does not have `setOption`");
      }
    };
    exports.Tabpage = Tabpage;
  }
});

// node_modules/neovim/lib/api/Window.js
var require_Window = __commonJS({
  "node_modules/neovim/lib/api/Window.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Window = void 0;
    var Base_1 = require_Base();
    var types_1 = require_types();
    var createChainableApi_1 = require_createChainableApi();
    var Tabpage_1 = require_Tabpage();
    var Buffer_1 = require_Buffer();
    var Window = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = types_1.Metadata[types_1.ExtType.Window].prefix;
      }
      /**
       * The windowid that not change within a Vim session
       */
      get id() {
        return this.data;
      }
      /** Get current buffer of window */
      get buffer() {
        return createChainableApi_1.createChainableApi.call(this, "Buffer", Buffer_1.Buffer, () => this.request(`${this.prefix}get_buf`, [this]));
      }
      /** Get the Tabpage that contains the window */
      get tabpage() {
        return createChainableApi_1.createChainableApi.call(this, "Tabpage", Tabpage_1.Tabpage, () => this.request(`${this.prefix}get_tabpage`, [this]));
      }
      /** Get cursor position */
      get cursor() {
        return this.request(`${this.prefix}get_cursor`, [this]);
      }
      /** Set cursor position */
      set cursor(pos) {
        this.request(`${this.prefix}set_cursor`, [this, pos]);
      }
      /** Get window height by number of rows */
      get height() {
        return this.request(`${this.prefix}get_height`, [this]);
      }
      /** Set window height by number of rows */
      set height(height) {
        this.request(`${this.prefix}set_height`, [this, height]);
      }
      /** Get window width by number of columns */
      get width() {
        return this.request(`${this.prefix}get_width`, [this]);
      }
      /** Set window width by number of columns  */
      set width(width) {
        this.request(`${this.prefix}set_width`, [this, width]);
      }
      /** Get window position */
      get position() {
        return this.request(`${this.prefix}get_position`, [this]);
      }
      /** 0-indexed, on-screen window position(row) in display cells. */
      get row() {
        return this.request(`${this.prefix}get_position`, [this]).then((position) => position[0]);
      }
      /** 0-indexed, on-screen window position(col) in display cells. */
      get col() {
        return this.request(`${this.prefix}get_position`, [this]).then((position) => position[1]);
      }
      /** Is window valid */
      get valid() {
        return this.request(`${this.prefix}is_valid`, [this]);
      }
      /** Get window number */
      get number() {
        return this.request(`${this.prefix}get_number`, [this]);
      }
      /**
       * Closes window
       *
       * @param {Boolean} force Force close window
       */
      close(force = false) {
        return this.request(`${this.prefix}close`, [this, force]);
      }
      /**
       * Configure window position. Currently this is only used to
       * configure floating and external windows (including changing a
       * split window to these types).
       *
       * See documentation at |nvim_open_win()|, for the meaning of
       * parameters. Pass in -1 for 'witdh' and 'height' to keep
       * exiting size.
       *
       * When reconfiguring a floating window, absent option keys will
       * not be changed. The following restriction apply: `row`, `col`
       * and `relative` must be reconfigured together. Only changing a
       * subset of these is an error.
       *
       * @param {Window}  window Window handle
       * @Param {Object}  options Options object
       */
      config(options = {}) {
        return this.request(`${this.prefix}set_config`, [this, options]);
      }
    };
    exports.Window = Window;
  }
});

// node_modules/neovim/lib/api/types.js
var require_types = __commonJS({
  "node_modules/neovim/lib/api/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Metadata = exports.ExtType = void 0;
    var Buffer_1 = require_Buffer();
    var Window_1 = require_Window();
    var Tabpage_1 = require_Tabpage();
    var ExtType;
    (function(ExtType2) {
      ExtType2[ExtType2["Buffer"] = 0] = "Buffer";
      ExtType2[ExtType2["Window"] = 1] = "Window";
      ExtType2[ExtType2["Tabpage"] = 2] = "Tabpage";
    })(ExtType || (exports.ExtType = ExtType = {}));
    exports.Metadata = [
      {
        constructor: Buffer_1.Buffer,
        name: "Buffer",
        prefix: "nvim_buf_"
      },
      {
        constructor: Window_1.Window,
        name: "Window",
        prefix: "nvim_win_"
      },
      {
        constructor: Tabpage_1.Tabpage,
        name: "Tabpage",
        prefix: "nvim_tabpage_"
      }
    ];
  }
});

// node_modules/neovim/lib/utils/transport.js
var require_transport = __commonJS({
  "node_modules/neovim/lib/utils/transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transport = void 0;
    var node_events_1 = require("events");
    var msgpack_1 = require_dist();
    var types_1 = require_types();
    var Response = class {
      constructor(encoder, requestId) {
        this.encoder = encoder;
        this.requestId = requestId;
      }
      send(resp, isError) {
        if (this.sent) {
          throw new Error(`Response to id ${this.requestId} already sent`);
        }
        const encoded = (0, msgpack_1.encode)([
          1,
          this.requestId,
          isError ? resp : null,
          !isError ? resp : null
        ]);
        this.encoder.write(Buffer.from(encoded.buffer, encoded.byteOffset, encoded.byteLength));
        this.sent = true;
      }
    };
    var Transport = class extends node_events_1.EventEmitter {
      constructor() {
        super(...arguments);
        this.pending = /* @__PURE__ */ new Map();
        this.nextRequestId = 1;
        this.extensionCodec = this.initializeExtensionCodec();
      }
      initializeExtensionCodec() {
        const codec = new msgpack_1.ExtensionCodec();
        types_1.Metadata.forEach(({ constructor }, id) => {
          codec.register({
            type: id,
            encode: (input) => {
              if (input instanceof constructor) {
                return (0, msgpack_1.encode)(input.data);
              }
              return null;
            },
            decode: (data) => new constructor({
              transport: this,
              client: this.client,
              data: (0, msgpack_1.decode)(data)
            })
          });
        });
        return codec;
      }
      encodeToBuffer(value) {
        const encoded = (0, msgpack_1.encode)(value, { extensionCodec: this.extensionCodec });
        return Buffer.from(encoded.buffer, encoded.byteOffset, encoded.byteLength);
      }
      attach(writer, reader, client) {
        this.writer = writer;
        this.reader = reader;
        this.client = client;
        this.reader.on("end", () => {
          this.emit("detach");
        });
        const asyncDecodeGenerator = (0, msgpack_1.decodeMultiStream)(this.reader, {
          extensionCodec: this.extensionCodec
        });
        const resolveGeneratorRecursively = (iter) => {
          iter.next().then((resolved) => {
            if (!resolved.done) {
              this.parseMessage(resolved.value);
              return resolveGeneratorRecursively(iter);
            }
            return Promise.resolve();
          });
        };
        resolveGeneratorRecursively(asyncDecodeGenerator);
      }
      request(method, args, cb) {
        this.nextRequestId = this.nextRequestId + 1;
        this.writer.write(this.encodeToBuffer([0, this.nextRequestId, method, args]));
        this.pending.set(this.nextRequestId, cb);
      }
      notify(method, args) {
        this.writer.write(this.encodeToBuffer([2, method, args]));
      }
      parseMessage(msg) {
        const msgType = msg[0];
        if (msgType === 0) {
          this.emit("request", msg[2].toString(), msg[3], new Response(this.writer, msg[1]));
        } else if (msgType === 1) {
          const id = msg[1];
          const handler = this.pending.get(id);
          this.pending.delete(id);
          handler(msg[2], msg[3]);
        } else if (msgType === 2) {
          this.emit("notification", msg[1].toString(), msg[2]);
        } else {
          this.writer.write(this.encodeToBuffer([1, 0, "Invalid message type", null]));
        }
      }
    };
    exports.Transport = Transport;
  }
});

// node_modules/neovim/lib/api/Neovim.js
var require_Neovim = __commonJS({
  "node_modules/neovim/lib/api/Neovim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Neovim = void 0;
    var Base_1 = require_Base();
    var createChainableApi_1 = require_createChainableApi();
    var Buffer_1 = require_Buffer();
    var Tabpage_1 = require_Tabpage();
    var Window_1 = require_Window();
    var Neovim2 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_";
        this.Buffer = Buffer_1.Buffer;
        this.Window = Window_1.Window;
        this.Tabpage = Tabpage_1.Tabpage;
      }
      /**
       * Retrieves nvim API information
       */
      get apiInfo() {
        return this.request(`${this.prefix}get_api_info`);
      }
      /**
       * Gets the current list of buffer handles
       *
       * Includes unlisted (unloaded/deleted) buffers, like `ls!`. Use `buffer.loaded`
       * to check if a buffer is loaded
       *
       * @return {Buffer[]} List of buffer handles
       */
      get buffers() {
        return this.request(`${this.prefix}list_bufs`);
      }
      /**
       * Gets the current buffer
       *
       * @return {Buffer} Buffer handle
       */
      get buffer() {
        return createChainableApi_1.createChainableApi.call(this, "Buffer", Buffer_1.Buffer, () => this.request(`${this.prefix}get_current_buf`));
      }
      /**
       * Sets the current buffer
       */
      set buffer(buffer) {
        this.request(`${this.prefix}set_current_buf`, [buffer]);
      }
      /**
       * Get information about all open channels
       *
       * @return {Channel[]} Array of channels
       */
      get chans() {
        return this.request(`${this.prefix}list_chans`);
      }
      /**
       * Gets information about a channel
       *
       * @param {Number} chan The channel number
       * @return {Channel} A channel
       */
      getChanInfo(chan) {
        return this.request(`${this.prefix}get_chan_info`, [chan]);
      }
      /**
       * Gets a map of buffer-local |user-commands|.
       */
      get commands() {
        return this.getCommands();
      }
      /**
       * Gets a map of buffer-local |user-commands|.
       *
       * @param {Object} options Optional parameters (currently not used)
       * @return {Object} Map of maps describing commands
       */
      getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [options]);
      }
      /**
       * Gets the current list of tabpage handles
       *
       * @return {Tabpage[]} List of tagpage handles
       */
      get tabpages() {
        return this.request(`${this.prefix}list_tabpages`);
      }
      /**
       * Gets the window tabpage
       *
       * @return {Tabpage} Tagpage that contains the window
       */
      get tabpage() {
        return createChainableApi_1.createChainableApi.call(this, "Tabpage", Tabpage_1.Tabpage, () => this.request(`${this.prefix}get_current_tabpage`));
      }
      /**
       * Sets the current tabpage
       */
      set tabpage(tabpage) {
        this.request(`${this.prefix}set_current_tabpage`, [tabpage]);
      }
      /**
       * Gets the current list of window handles
       *
       * @return {Window[]} List of window handles
       */
      get windows() {
        return this.getWindows();
      }
      /**
       * Gets the current window
       *
       * @return {Window} Window handle
       */
      get window() {
        return this.getWindow();
      }
      /**
       * Sets the current window
       *
       * @param {Window} Window handle
       */
      set window(win) {
        if (win instanceof Window_1.Window)
          this.setWindow(win);
        else
          win.then((win2) => this.setWindow(win2));
      }
      /**
       * Gets the current list of window handles
       *
       * @return {Window[]} List of window handles
       */
      getWindows() {
        return this.request(`${this.prefix}list_wins`);
      }
      /**
       * Gets the current window
       *
       * @return {Window} Window handle
       */
      getWindow() {
        return createChainableApi_1.createChainableApi.call(this, "Window", Window_1.Window, () => this.request(`${this.prefix}get_current_win`));
      }
      /**
       * Sets the current window
       *
       * @param {Window} Window handle
       */
      setWindow(win) {
        return this.request(`${this.prefix}set_current_win`, [win]);
      }
      /**
       * Gets the paths contained in "runtimepath"
       *
       * @return {String[]} List of paths
       */
      get runtimePaths() {
        return this.request(`${this.prefix}list_runtime_paths`);
      }
      /**
       * Changes the global working directory
       *
       * @param {String} Directory path
       *
       */
      set dir(dir) {
        this.request(`${this.prefix}set_current_dir`, [dir]);
      }
      /**
       * Gets the current line
       *
       * @return {String} Current line string
       */
      get line() {
        return this.getLine();
      }
      /**
       * Sets current line
       *
       * @param {String} line Line contents
       */
      set line(line) {
        if (typeof line === "string") {
          this.setLine(line);
        }
      }
      /**
       * Gets the current line
       *
       * @return {String} Current line string
       */
      getLine() {
        return this.request(`${this.prefix}get_current_line`);
      }
      /**
       * Sets current line
       *
       * @param {String} line Line contents
       */
      setLine(line) {
        return this.request(`${this.prefix}set_current_line`, [line]);
      }
      /**
       * Gets a list of global (non-buffer-local) |mapping| definitions.
       *
       * @param {String} mode Mode short-name ("n", "i", "v", ...)
       * @return {Object[]}  Array of maparg()-like dictionaries describing mappings. The "buffer" key is always zero.
       */
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
      }
      /**
       * Gets the current mode. |mode()| "blocking" is true if Nvim is waiting for input.
       *
       * @return {Object} Dictionary { "mode": String, "blocking": Boolean }
       */
      get mode() {
        return this.request(`${this.prefix}get_mode`);
      }
      /**
       * Gets map of defined colors
       *
       * @return {Object} Color map
       */
      get colorMap() {
        return this.request(`${this.prefix}get_color_map`);
      }
      /**
       * Get color by name
       *
       * @param {String} name Color name
       * @return {Number} Color value
       */
      getColorByName(name) {
        return this.request(`${this.prefix}get_color_by_name`, [name]);
      }
      /**
       * Get highlight by name or id
       *
       * @param {String|Number} nameOrId Name or ID
       * @param {Boolean} isRgb Should export RGB colors
       * @return {Object} Highlight definition map
       */
      getHighlight(nameOrId, isRgb = true) {
        const functionName = typeof nameOrId === "string" ? "by_name" : "by_id";
        return this.request(`${this.prefix}get_hl_${functionName}`, [
          nameOrId,
          isRgb
        ]);
      }
      /**
       * Get highlight definition by name
       *
       * @param {String} name Highlight group name
       * @param {Boolean} isRgb Should export RGB colors
       * @return {Object} Highlight definition map
       */
      getHighlightByName(name, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_name`, [name, isRgb]);
      }
      /**
       * Get highlight definition by id |hlID()|
       *
       * @param {Number} id Highlight id as returned by |hlID()|
       * @param {Boolean} isRgb Should export RGB colors
       * @return {Object} Highlight definition map
       */
      getHighlightById(id, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_id`, [id, isRgb]);
      }
      /**
       * Deletes the current line
       */
      deleteCurrentLine() {
        return this.request(`${this.prefix}del_current_line`);
      }
      /**
       * Evaluates a VimL expression (:help expression). Dictionaries
       * and Lists are recursively expanded. On VimL error: Returns a
       * generic error; v:errmsg is not updated.
       *
       */
      eval(expr) {
        return this.request(`${this.prefix}eval`, [expr]);
      }
      /**
       * Executes lua, it's possible neovim client does not support this
       */
      lua(code, args = []) {
        const _args = Array.isArray(args) ? args : [args];
        return this.request(`${this.prefix}execute_lua`, [code, _args]);
      }
      /**
       * Alias for `lua()` to be consistent with neovim API
       */
      executeLua(code, args = []) {
        return this.lua(code, args);
      }
      /**
       * Calls a VimL |Dictionary-function| with the given arguments.
       *
       * On execution error: fails with VimL error, does not update v:errmsg.
       */
      callDictFunction(dict, fname, args = []) {
        const _args = Array.isArray(args) ? args : [args];
        return this.request(`${this.prefix}call_dict_function`, [
          dict,
          fname,
          _args
        ]);
      }
      /**
       * Calls a VimL function with the given arguments.
       *
       * On execution error: fails with VimL error, does not update v:errmsg.
       */
      call(fname, args = []) {
        const _args = Array.isArray(args) ? args : [args];
        return this.request(`${this.prefix}call_function`, [fname, _args]);
      }
      /**
       * Alias for `call`
       */
      callFunction(fname, args = []) {
        return this.call(fname, args);
      }
      /**
       * Calls many API methods atomically.
       *
       * This has two main usages:
       *  - To perform several requests from an async context atomically, i.e. without
       * interleaving redraws, RPC requests from other clients, or user interactions
       * (however API methods may trigger autocommands or event processing which have
       * such side-effects, e.g. |:sleep| may wake timers)
       *
       *  - To minimize RPC overhead (roundtrips) of a sequence of many requests.
       */
      callAtomic(calls) {
        return this.request(`${this.prefix}call_atomic`, [calls]);
      }
      /**
       * Executes an ex-command.
       *
       * On execution error: fails with VimL error, does not update v:errmsg.
       *
       * @param {String} arg Ex-command string
       */
      command(arg) {
        return this.request(`${this.prefix}command`, [arg]);
      }
      /**
       * Executes an ex-command and returns its (non-error) output.
       * Shell |:!| output is not captured.
       *
       * On execution error: fails with VimL error, does not update v:errmsg.
       */
      commandOutput(arg) {
        return this.request(`${this.prefix}command_output`, [arg]);
      }
      /**
       * Gets a v: variable
       *
       * @param {String} name Variable name
       * @return {VimValue} Variable value
       */
      getVvar(name) {
        return this.request(`${this.prefix}get_vvar`, [name]);
      }
      /**
       * Sets a v: variable, if it is not readonly.
       *
       * @param {String} name Variable name
       * @param {VimValue} value Variable value
       */
      setVvar(name, value) {
        return this.request(`${this.prefix}set_vvar`, [name, value]);
      }
      /**
       * Sends input-keys to Nvim, subject to various quirks controlled
       * by `mode` flags. This is a blocking call, unlike |nvim_input()|.
       *
       * On execution error: does not fail, but updates v:errmsg.
       *
       * @param {String} keys To be typed
       * @param {String} mode Behavior flags, see |feedkeys()|
       * @param {Boolean} escapeCsi If true, escape K_SPECIAL/CSI bytes in `keys`
       */
      feedKeys(keys, mode, escapeCsi) {
        return this.request(`${this.prefix}feedkeys`, [keys, mode, escapeCsi]);
      }
      /**
       * Queues raw user-input. Unlike |nvim_feedkeys()|, this uses a
       * low-level input buffer and the call is non-blocking (input is
       * processed asynchronously by the eventloop).
       *
       * On execution error: does not fail, but updates v:errmsg.
       *
       * Note:
       * |keycodes| like <CR> are translated, so "<" is special. To
       * input a literal "<", send <LT>.
       *
       * Note:
       * For mouse events use |nvim_input_mouse()|. The pseudokey
       * form "<LeftMouse><col,row>" is deprecated since
       * |api-level| 6.
       *
       * @param {String} keys To be typed
       */
      input(keys) {
        return this.request(`${this.prefix}input`, [keys]);
      }
      /**
       * Send mouse event from GUI.
       *
       * The call is non-blocking. It doesn't wait on any resulting
       * action, but queues the event to be processed soon by the event
       * loop.
       *
       * Note:
       * Currently this doesn't support "scripting" multiple mouse
       * events by calling it multiple times in a loop: the
       * intermediate mouse positions will be ignored. It should be
       * used to implement real-time mouse input in a GUI. The
       * deprecated pseudokey form ("<LeftMouse><col,row>") of
       * |nvim_input()| has the same limitiation.
       *
       * @param {String} button    Mouse button: one of "left", "right", "middle", "wheel".
       * @param {String} action    For ordinary buttons, one of "press", "drag", "release".
       *                           For the wheel, one of "up", "down", "left", "right".
       * @param {String} modifier  String of modifiers each represented by a
       *                           single char. The same specifiers are used as
       *                           for a key press, except that the "-" separator
       *                           is optional, so "C-A-", "c-a" and "CA" can all
       *                           be used to specify Ctrl+Alt+click.
       * @param {Number} grid      Grid number if the client uses |ui-multigrid|, else 0.
       * @param {Number} row       Mouse row-position (zero-based, like redraw events)
       * @param {Number} col       Mouse column-position (zero-based, like redraw events)
       */
      inputMouse(button, action, modifier, grid, row, col) {
        return this.request(`${this.prefix}input_mouse`, [
          button,
          action,
          modifier,
          grid,
          row,
          col
        ]);
      }
      /**
       * Parse a VimL Expression
       *
       * TODO: return type, see :help
       */
      parseExpression(expr, flags, highlight) {
        return this.request(`${this.prefix}parse_expression`, [
          expr,
          flags,
          highlight
        ]);
      }
      /**
       * Gets info describing process `pid`.
       *
       * @param {Number} pid pid
       * @return {Proc} Map of process properties, or null if process not found
       */
      getProc(pid) {
        return this.request(`${this.prefix}get_proc`, [pid]);
      }
      /**
       * Gets the immediate children of process `pid`
       *
       * @return {Proc[]} Array of child process ids, empty if process not found
       */
      getProcChildren(pid) {
        return this.request(`${this.prefix}get_proc_children`, [pid]);
      }
      /**
       * Replaces terminal codes and |keycodes| (<CR>, <Esc>, ...) in a
       * string with the internal representation.
       *
       * @param {String} str String to be converted.
       * @param {Boolean} fromPart Legacy Vim parameter. Usually true.
       * @param {Boolean} doIt Also translate <lt>. Ignored if `special` is false.
       * @param {Boolean} special Replace |keycodes|, e.g. <CR> becomes a "\n" char.
       */
      replaceTermcodes(str, fromPart, doIt, special) {
        return this.request(`${this.prefix}replace_termcodes`, [
          str,
          fromPart,
          doIt,
          special
        ]);
      }
      /**
       * Calculates the number of display cells occupied by `text`.
       * <Tab> counts as one cell.
       *
       * @param {String} str Some text
       * @return {Number} Number of cells
       */
      strWidth(str) {
        return this.request(`${this.prefix}strwidth`, [str]);
      }
      /** Write to output buffer */
      outWrite(str) {
        return this.request(`${this.prefix}out_write`, [str]);
      }
      outWriteLine(str) {
        return this.outWrite(`${str}
`);
      }
      /** Write to error buffer */
      errWrite(str) {
        return this.request(`${this.prefix}err_write`, [str]);
      }
      /** Write to error buffer */
      errWriteLine(str) {
        return this.request(`${this.prefix}err_writeln`, [str]);
      }
      /**
       * Gets a list of dictionaries representing attached UIs.
       *
       * @return {Ui[]} Array of UI dictionaries
       * Each dictionary has the following keys:
       * "height" requested height of the UI
       * "width" requested width of the UI
       * "rgb" whether the UI uses rgb colors (false implies cterm colors)
       * "ext_..." Requested UI extensions, see |ui-options|
       * "chan" Channel id of remote UI (not present for TUI)
       */
      get uis() {
        return this.request(`${this.prefix}list_uis`);
      }
      uiAttach(width, height, options) {
        return this.request(`${this.prefix}ui_attach`, [width, height, options]);
      }
      uiDetach() {
        return this.request(`${this.prefix}ui_detach`, []);
      }
      /**
       * TODO: Documentation
       *
       * @param {Number} width The new requested width
       * @param {Number} height The new requested height
       */
      uiTryResize(width, height) {
        return this.request(`${this.prefix}ui_try_resize`, [width, height]);
      }
      /**
       * Tell Nvim to resize a grid. Triggers a grid_resize event with
       * the requested grid size or the maximum size if it exceeds size
       * limits.
       *
       * On invalid grid handle, fails with error.
       *
       * @param {Number} grid The handle of the grid to be changed
       * @param {Number} width The new requested width
       * @param {Number} height The new requested height
       */
      uiTryResizeGrid(grid, width, height) {
        return this.request(`${this.prefix}ui_try_resize_grid`, [
          grid,
          width,
          height
        ]);
      }
      /**
       * Set UI Option
       */
      uiSetOption(name, value) {
        return this.request(`${this.prefix}ui_set_option`, [name, value]);
      }
      /**
       * Subscribe to nvim event broadcasts
       *
       * @param {String} event Event type string
       */
      subscribe(event) {
        return this.request(`${this.prefix}subscribe`, [event]);
      }
      /**
       * Unsubscribe to nvim event broadcasts
       *
       * @param {String} event Event type string
       */
      unsubscribe(event) {
        return this.request(`${this.prefix}unsubscribe`, [event]);
      }
      /**
       * Identify the client for nvim. Can be called more than once,
       * but subsequent calls will remove earlier info, which should be
       * resent if it is still valid. (This could happen if a library
       * first identifies the channel, and a plugin using that library
       * later overrides that info)
       *
       */
      setClientInfo(name, version, type, methods, attributes) {
        this.request(`${this.prefix}set_client_info`, [
          name,
          version,
          type,
          methods,
          attributes
        ]);
      }
      /**
       * Creates a new namespace, or gets an existing one.
       *
       * Namespaces are used for buffer highlights and virtual text,
       * see |nvim_buf_add_highlight()| and |nvim_buf_set_virtual_text()|.
       *
       * Namespaces can be named or anonymous. If `name` matches an
       * existing namespace, the associated id is returned. If `name`
       * is an empty string a new, anonymous namespace is created.
       *
       * @param {String} name Namespace name or empty string
       * @return {Number} Namespace id
       */
      createNamespace(name = "") {
        return this.request(`${this.prefix}create_namespace`, [name]);
      }
      /**
       * Alias for `getNamespaces()`
       */
      get namespaces() {
        return this.getNamespaces();
      }
      /**
       * Gets existing, non-anonymous namespaces.
       *
       * @return {Object} dict that maps from names to namespace ids.
       */
      getNamespaces() {
        return this.request(`${this.prefix}get_namespaces`);
      }
      /**
       * Selects an item in the completion popupmenu.
       *
       * If |ins-completion| is not active this API call is silently
       * ignored. Useful for an external UI using |ui-popupmenu| to
       * control the popupmenu with the mouse. Can also be used in a
       * mapping; use <cmd> |:map-cmd| to ensure the mapping doesn't
       * end completion mode.
       *
       * @param {Number}  item     Index (zero-based) of the item to select.
       *                           Value of -1 selects nothing and restores the original text.
       * @param {Boolean} insert   Whether the selection should be inserted in the buffer.
       * @param {Boolean} finish   Finish the completion and dismiss the popupmenu.
       *                           Implies `insert`.
       * @param {Object}  opts     Optional parameters. Reserved for future use.
       */
      selectPopupmenuItem(item, insert, finish, opts = {}) {
        return this.request(`${this.prefix}select_popupmenu_item`, [
          item,
          insert,
          finish,
          opts
        ]);
      }
      /**
       * Creates a new, empty, unnamed buffer.
       *
       * @param {Boolean} listed  Controls 'buflisted'
       * @param {Boolean} scratch Creates a "throwaway" |scratch-buffer| for temporary work (always 'nomodified')
       * @return {Buffer|Number} Buffer handle, or 0 on error
       */
      createBuf(listed, scratch) {
        return this.request(`${this.prefix}create_buf`, [listed, scratch]);
      }
      /**
       * Public alias for `createBuf`
       */
      createBuffer(listed, scratch) {
        return this.createBuf(listed, scratch);
      }
      /**
       * Open a new window.
       * Currently this is used to open floating and external windows.
       * Floats are windows that are drawn above the split layout, at
       * some anchor position in some other window. Floats can be draw
       * internally or by external GUI with the |ui-multigrid|
       * extension. External windows are only supported with multigrid
       * GUIs, and are displayed as separate top-level windows.
       *
       * Exactly one of `external` and `relative` must be specified.
       *
       * @param {Buffer}  buffer Handle of buffer to be displayed in the window
       * @param {Boolean} enter  Whether the window should be entered (made the current window)
       * @Param {Object}  options Options object
       * @return {Window|Number} The Window handle or 0 when error
       */
      openWin(buffer, enter, options) {
        return this.request(`${this.prefix}open_win`, [buffer, enter, options]);
      }
      /**
       * Public alias for `openWin`
       */
      openWindow(buffer, enter, options) {
        return this.openWin(buffer, enter, options);
      }
      /**
       * Configure window position. Currently this is only used to
       * configure floating and external windows (including changing a
       * split window to these types).
       *
       * See documentation at |nvim_open_win()|, for the meaning of
       * parameters. Pass in -1 for 'witdh' and 'height' to keep
       * exiting size.
       *
       * When reconfiguring a floating window, absent option keys will
       * not be changed. The following restriction apply: `row`, `col`
       * and `relative` must be reconfigured together. Only changing a
       * subset of these is an error.
       *
       * @param {Window}  window Window handle
       * @param {Number}  width  Width of window (in character cells)
       * @param {Number}  height Height of window (in character cells)
       * @Param {Object}  options Options object
       */
      winConfig(window2, options = {}) {
        return window2.config(options);
      }
      /**
       * Public Alias for `winConfig`
       */
      windowConfig(window2, options = {}) {
        return this.winConfig(window2, options);
      }
      /**
       * Closes window
       *
       * @param {Boolean} force Force close window
       */
      winClose(window2, force) {
        return window2.close(force);
      }
      /**
       * Public alias for `winClose`
       */
      windowClose(window2, force) {
        return this.winClose(window2, force);
      }
      /**
       * Quit nvim
       */
      quit() {
        this.command("qa!");
      }
    };
    exports.Neovim = Neovim2;
  }
});

// node_modules/neovim/lib/api/client.js
var require_client = __commonJS({
  "node_modules/neovim/lib/api/client.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NeovimClient = void 0;
    var transport_1 = require_transport();
    var Neovim_1 = require_Neovim();
    var REGEX_BUF_EVENT = /nvim_buf_(.*)_event/;
    var NeovimClient = class extends Neovim_1.Neovim {
      constructor(options = {}) {
        super({
          logger: options.logger
        });
        this.attachedBuffers = /* @__PURE__ */ new Map();
        const transport = options.transport || new transport_1.Transport();
        this.setTransport(transport);
        this.requestQueue = [];
        this.transportAttached = false;
        this.handleRequest = this.handleRequest.bind(this);
        this.handleNotification = this.handleNotification.bind(this);
      }
      /** Attaches msgpack to read/write streams * */
      attach({ reader, writer }) {
        this.transport.attach(writer, reader, this);
        this.transportAttached = true;
        this.setupTransport();
      }
      get isApiReady() {
        return this.transportAttached && typeof this._channelId !== "undefined";
      }
      get channelId() {
        return (() => __awaiter(this, void 0, void 0, function* () {
          yield this._isReady;
          return this._channelId;
        }))();
      }
      isAttached(buffer) {
        const key = `${buffer.data}`;
        return this.attachedBuffers.has(key);
      }
      handleRequest(method, args, resp, ...restArgs) {
        this.logger.info("handleRequest: ", method);
        if (!this.isApiReady && method !== "specs") {
          this.requestQueue.push({
            type: "request",
            args: [method, args, resp, ...restArgs]
          });
        } else {
          this.emit("request", method, args, resp);
        }
      }
      emitNotification(method, args) {
        if (method.endsWith("_event")) {
          if (!method.startsWith("nvim_buf_")) {
            this.logger.error("Unhandled event: ", method);
            return;
          }
          const shortName = method.replace(REGEX_BUF_EVENT, "$1");
          const [buffer] = args;
          const bufferKey = `${buffer.data}`;
          if (!this.attachedBuffers.has(bufferKey)) {
            return;
          }
          const bufferMap = this.attachedBuffers.get(bufferKey);
          const cbs = bufferMap.get(shortName) || [];
          cbs.forEach((cb) => cb(...args));
          if (shortName === "detach") {
            this.attachedBuffers.delete(bufferKey);
          }
        } else {
          this.emit("notification", method, args);
        }
      }
      handleNotification(method, args, ...restArgs) {
        this.logger.info("handleNotification: ", method);
        if (!this.isApiReady) {
          this.requestQueue.push({
            type: "notification",
            args: [method, args, ...restArgs]
          });
        } else {
          this.emitNotification(method, args);
        }
      }
      // Listen and setup handlers for transport
      setupTransport() {
        if (!this.transportAttached) {
          throw new Error("Not attached to input/output");
        }
        this.transport.on("request", this.handleRequest);
        this.transport.on("notification", this.handleNotification);
        this.transport.on("detach", () => {
          this.emit("disconnect");
          this.transport.removeAllListeners("request");
          this.transport.removeAllListeners("notification");
          this.transport.removeAllListeners("detach");
        });
        this._isReady = this.generateApi();
      }
      requestApi() {
        return new Promise((resolve, reject) => {
          this.transport.request("nvim_get_api_info", [], (err, res) => {
            if (err) {
              reject(err);
            } else {
              resolve(res);
            }
          });
        });
      }
      // Request API from neovim and augment this current class to add these APIs
      generateApi() {
        return __awaiter(this, void 0, void 0, function* () {
          let results;
          try {
            results = yield this.requestApi();
          } catch (err) {
            this.logger.error("Could not get vim api results");
            this.logger.error(err);
          }
          if (results) {
            try {
              const [
                channelId
                /* , encodedMetadata */
              ] = results;
              this._channelId = channelId;
              this.requestQueue.forEach((pending) => {
                if (pending.type === "notification") {
                  this.emitNotification(pending.args[0], pending.args[1]);
                } else {
                  this.emit(pending.type, ...pending.args);
                }
              });
              this.requestQueue = [];
              return true;
            } catch (err) {
              this.logger.error(`Could not dynamically generate neovim API: ${err}`, {
                error: err
              });
              this.logger.error(err.stack);
              return null;
            }
          }
          return null;
        });
      }
      attachBuffer(buffer, eventName, cb) {
        const bufferKey = `${buffer.data}`;
        if (!this.attachedBuffers.has(bufferKey)) {
          this.attachedBuffers.set(bufferKey, /* @__PURE__ */ new Map());
        }
        const bufferMap = this.attachedBuffers.get(bufferKey);
        if (!bufferMap.get(eventName)) {
          bufferMap.set(eventName, []);
        }
        const cbs = bufferMap.get(eventName);
        if (cbs.includes(cb))
          return cb;
        cbs.push(cb);
        bufferMap.set(eventName, cbs);
        this.attachedBuffers.set(bufferKey, bufferMap);
        return cb;
      }
      /**
       * Returns `true` if buffer should be detached
       */
      detachBuffer(buffer, eventName, cb) {
        const bufferKey = `${buffer.data}`;
        const bufferMap = this.attachedBuffers.get(bufferKey);
        if (!bufferMap)
          return false;
        const handlers = (bufferMap.get(eventName) || []).filter((handler) => handler !== cb);
        if (!handlers.length) {
          bufferMap.delete(eventName);
        } else {
          bufferMap.set(eventName, handlers);
        }
        if (!bufferMap.size) {
          this.attachedBuffers.delete(bufferKey);
          return true;
        }
        return false;
      }
    };
    exports.NeovimClient = NeovimClient;
  }
});

// node_modules/neovim/lib/attach/attach.js
var require_attach = __commonJS({
  "node_modules/neovim/lib/attach/attach.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attach = void 0;
    var node_net_1 = require("net");
    var client_1 = require_client();
    var logger_1 = require_logger2();
    function attach2({ reader: _reader, writer: _writer, proc, socket, options = {} }) {
      let writer;
      let reader;
      if (socket) {
        const client = (0, node_net_1.createConnection)(socket);
        writer = client;
        reader = client;
      } else if (_reader && _writer) {
        writer = _writer;
        reader = _reader;
      } else if (proc) {
        writer = proc.stdin;
        reader = proc.stdout;
      }
      if (writer && reader) {
        const loggerInstance = options.logger || (0, logger_1.getLogger)();
        const neovim = new client_1.NeovimClient({ logger: loggerInstance });
        neovim.attach({
          writer,
          reader
        });
        return neovim;
      }
      throw new Error("Invalid arguments, could not attach");
    }
    exports.attach = attach2;
  }
});

// node_modules/neovim/lib/attach.js
var require_attach2 = __commonJS({
  "node_modules/neovim/lib/attach.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attach = void 0;
    var attach_1 = require_attach();
    Object.defineProperty(exports, "attach", { enumerable: true, get: function() {
      return attach_1.attach;
    } });
  }
});

// node_modules/neovim/lib/api/index.js
var require_api = __commonJS({
  "node_modules/neovim/lib/api/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tabpage = exports.Window = exports.Buffer = exports.NeovimClient = exports.Neovim = void 0;
    var Neovim_1 = require_Neovim();
    Object.defineProperty(exports, "Neovim", { enumerable: true, get: function() {
      return Neovim_1.Neovim;
    } });
    var client_1 = require_client();
    Object.defineProperty(exports, "NeovimClient", { enumerable: true, get: function() {
      return client_1.NeovimClient;
    } });
    var Buffer_1 = require_Buffer();
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: function() {
      return Buffer_1.Buffer;
    } });
    var Window_1 = require_Window();
    Object.defineProperty(exports, "Window", { enumerable: true, get: function() {
      return Window_1.Window;
    } });
    var Tabpage_1 = require_Tabpage();
    Object.defineProperty(exports, "Tabpage", { enumerable: true, get: function() {
      return Tabpage_1.Tabpage;
    } });
  }
});

// node_modules/neovim/lib/plugin/properties.js
var require_properties = __commonJS({
  "node_modules/neovim/lib/plugin/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NVIM_METHOD_NAME = exports.NVIM_SYNC = exports.NVIM_SPEC = exports.NVIM_DEV_MODE = exports.NVIM_PLUGIN = void 0;
    exports.NVIM_PLUGIN = "_nvim_plugin";
    exports.NVIM_DEV_MODE = "_nvim_dev_mode";
    exports.NVIM_SPEC = "_nvim_rpc_spec";
    exports.NVIM_SYNC = "_nvim_rpc_sync";
    exports.NVIM_METHOD_NAME = "_nvim_rpc_method_name";
  }
});

// node_modules/neovim/lib/host/NvimPlugin.js
var require_NvimPlugin = __commonJS({
  "node_modules/neovim/lib/host/NvimPlugin.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NvimPlugin = exports.callable = void 0;
    function callable(fn) {
      if (typeof fn === "function") {
        return fn;
      }
      if (Array.isArray(fn) && fn.length === 2) {
        return function(...args) {
          return fn[1].apply(fn[0], args);
        };
      }
      throw new Error();
    }
    exports.callable = callable;
    var NvimPlugin = class {
      constructor(filename, plugin, nvim) {
        this.filename = filename;
        this.nvim = nvim;
        this.dev = false;
        this.alwaysInit = false;
        this.autocmds = {};
        this.commands = {};
        this.functions = {};
        try {
          this.instance = new plugin(this);
        } catch (err) {
          if (err instanceof TypeError) {
            this.instance = plugin(this);
          } else {
            throw err;
          }
        }
      }
      setOptions(options) {
        this.dev = options.dev === void 0 ? this.dev : options.dev;
        this.alwaysInit = options.alwaysInit;
      }
      // Cache module (in dev mode will clear the require module cache)
      get shouldCacheModule() {
        return !this.dev;
      }
      registerAutocmd(name, fn, options) {
        if (!options.pattern) {
          this.nvim.logger.error(`registerAutocmd expected pattern option for ${name}`);
          return;
        }
        const spec = {
          type: "autocmd",
          name,
          sync: options && !!options.sync,
          opts: {}
        };
        ["pattern", "eval"].forEach((option) => {
          if (options && typeof options[option] !== "undefined") {
            spec.opts[option] = options[option];
          }
        });
        try {
          this.autocmds[`${name} ${options.pattern}`] = {
            fn: callable(fn),
            spec
          };
        } catch (err) {
          this.nvim.logger.error(`registerAutocmd expected callable argument for ${name}`);
        }
      }
      registerCommand(name, fn, options) {
        const spec = {
          type: "command",
          name,
          sync: options && !!options.sync,
          opts: {}
        };
        ["range", "nargs", "complete"].forEach((option) => {
          if (options && typeof options[option] !== "undefined") {
            spec.opts[option] = options[option];
          }
        });
        try {
          this.commands[name] = {
            fn: callable(fn),
            spec
          };
        } catch (err) {
          this.nvim.logger.error(`registerCommand expected callable argument for ${name}`);
        }
      }
      registerFunction(name, fn, options) {
        const spec = {
          type: "function",
          name,
          sync: options && !!options.sync,
          opts: {}
        };
        ["range", "eval"].forEach((option) => {
          if (options && typeof options[option] !== "undefined") {
            spec.opts[option] = options[option];
          }
        });
        try {
          this.functions[name] = {
            fn: callable(fn),
            spec
          };
        } catch (err) {
          this.nvim.logger.error(`registerFunction expected callable argument for ${name}`);
        }
      }
      get specs() {
        const autocmds = Object.keys(this.autocmds).map((key) => this.autocmds[key].spec);
        const commands = Object.keys(this.commands).map((key) => this.commands[key].spec);
        const functions = Object.keys(this.functions).map((key) => this.functions[key].spec);
        return autocmds.concat(commands).concat(functions);
      }
      handleRequest(name, type, args) {
        return __awaiter(this, void 0, void 0, function* () {
          let handlers;
          switch (type) {
            case "autocmd":
              handlers = this.autocmds;
              break;
            case "command":
              handlers = this.commands;
              break;
            case "function":
              handlers = this.functions;
              break;
            default:
              const errMsg = `No handler for unknown type ${type}: "${name}" in ${this.filename}`;
              this.nvim.logger.error(errMsg);
              throw new Error(errMsg);
          }
          if (handlers.hasOwnProperty(name)) {
            const handler = handlers[name];
            try {
              return handler.spec.sync ? handler.fn(...args) : yield handler.fn(...args);
            } catch (err) {
              const msg = `Error in plugin for ${type}:${name}: ${err.message}`;
              this.nvim.logger.error(`${msg} (file: ${this.filename}, stack: ${err.stack})`);
              throw new Error(err);
            }
          } else {
            const errMsg = `Missing handler for ${type}: "${name}" in ${this.filename}`;
            this.nvim.logger.error(errMsg);
            throw new Error(errMsg);
          }
        });
      }
    };
    exports.NvimPlugin = NvimPlugin;
  }
});

// node_modules/neovim/lib/plugin/plugin.js
var require_plugin = __commonJS({
  "node_modules/neovim/lib/plugin/plugin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.plugin = exports.NvimPlugin = exports.Neovim = void 0;
    var properties_1 = require_properties();
    var Neovim_1 = require_Neovim();
    Object.defineProperty(exports, "Neovim", { enumerable: true, get: function() {
      return Neovim_1.Neovim;
    } });
    var NvimPlugin_1 = require_NvimPlugin();
    Object.defineProperty(exports, "NvimPlugin", { enumerable: true, get: function() {
      return NvimPlugin_1.NvimPlugin;
    } });
    function wrapper(cls, options) {
      return class extends cls {
        constructor(...args) {
          const plugin2 = args[0];
          super(plugin2.nvim, plugin2);
          this.setApi(plugin2.nvim);
          if (options) {
            plugin2.setOptions(options);
          }
          plugin2.nvim.logger.info(`Decorating class ${cls}`);
          Object.getOwnPropertyNames(cls.prototype).forEach((methodName) => {
            plugin2.nvim.logger.info(`Method name ${methodName}`);
            plugin2.nvim.logger.info(`${cls.prototype[methodName]} ${typeof cls.prototype[methodName]}`);
            plugin2.nvim.logger.info(`${this} ${typeof this}`);
            const method = cls.prototype[methodName];
            if (method && method[properties_1.NVIM_SPEC]) {
              const spec = method[properties_1.NVIM_SPEC];
              switch (spec.type) {
                case "autocmd":
                  const autoCmdOpts = {
                    pattern: spec.opts.pattern,
                    sync: spec.sync
                  };
                  if (typeof spec.opts.eval !== "undefined") {
                    autoCmdOpts.eval = spec.opts.eval;
                  }
                  plugin2.registerAutocmd(spec.name, [this, method], autoCmdOpts);
                  break;
                case "command":
                  const cmdOpts = {
                    sync: spec.sync
                  };
                  if (typeof spec.opts.range !== "undefined") {
                    cmdOpts.range = spec.opts.range;
                  }
                  if (typeof spec.opts.nargs !== "undefined") {
                    cmdOpts.nargs = spec.opts.nargs;
                  }
                  if (typeof spec.opts.complete !== "undefined") {
                    cmdOpts.complete = spec.opts.complete;
                  }
                  plugin2.registerCommand(spec.name, [this, method], cmdOpts);
                  break;
                case "function":
                  const funcOpts = {
                    sync: spec.sync
                  };
                  if (typeof spec.opts.range !== "undefined") {
                    funcOpts.range = spec.opts.range;
                  }
                  if (typeof spec.opts.eval !== "undefined") {
                    funcOpts.eval = spec.opts.eval;
                  }
                  plugin2.registerFunction(spec.name, [this, method], funcOpts);
                  break;
                default:
                  break;
              }
            }
          });
        }
        setApi(nvim) {
          this.nvim = nvim;
        }
      };
    }
    function plugin(outter) {
      return typeof outter !== "function" ? (cls) => wrapper(cls, outter) : wrapper(outter);
    }
    exports.plugin = plugin;
  }
});

// node_modules/neovim/lib/plugin/function.js
var require_function = __commonJS({
  "node_modules/neovim/lib/plugin/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nvimFunction = void 0;
    var properties_1 = require_properties();
    function nvimFunction(name, options = {}) {
      return function(cls, methodName) {
        const sync = options && !!options.sync;
        const isMethod = typeof methodName === "string";
        const f = isMethod ? cls[methodName] : cls;
        const opts = {};
        if (options && options.range) {
          opts.range = options.range;
        }
        if (options && options.eval) {
          opts.eval = options.eval;
        }
        Object.defineProperty(f, properties_1.NVIM_METHOD_NAME, { value: `function:${name}` });
        Object.defineProperty(f, properties_1.NVIM_SYNC, { value: !!sync });
        Object.defineProperty(f, properties_1.NVIM_SPEC, {
          value: {
            type: "function",
            name,
            sync: !!sync,
            opts
          }
        });
        if (isMethod) {
          cls[methodName] = f;
        }
        return cls;
      };
    }
    exports.nvimFunction = nvimFunction;
  }
});

// node_modules/neovim/lib/plugin/autocmd.js
var require_autocmd = __commonJS({
  "node_modules/neovim/lib/plugin/autocmd.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.autocmd = void 0;
    var properties_1 = require_properties();
    function autocmd(name, options) {
      return function(cls, methodName) {
        const sync = options && !!options.sync;
        const isMethod = typeof methodName === "string";
        const f = isMethod ? cls[methodName] : cls;
        const opts = {
          pattern: ""
        };
        ["pattern", "eval"].forEach((option) => {
          if (options && typeof options[option] !== "undefined") {
            opts[option] = options[option];
          }
        });
        const nameWithPattern = `${name}${options.pattern ? `:${options.pattern}` : ""}`;
        Object.defineProperty(f, properties_1.NVIM_METHOD_NAME, {
          value: `autocmd:${nameWithPattern}`
        });
        Object.defineProperty(f, properties_1.NVIM_SYNC, { value: !!sync });
        Object.defineProperty(f, properties_1.NVIM_SPEC, {
          value: {
            type: "autocmd",
            name,
            sync: !!sync,
            opts
          }
        });
        if (isMethod) {
          cls[methodName] = f;
        }
        return cls;
      };
    }
    exports.autocmd = autocmd;
  }
});

// node_modules/neovim/lib/plugin/command.js
var require_command = __commonJS({
  "node_modules/neovim/lib/plugin/command.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.command = void 0;
    var properties_1 = require_properties();
    function command(name, options) {
      return function(cls, methodName) {
        const sync = options && !!options.sync;
        const isMethod = typeof methodName === "string";
        const f = isMethod ? cls[methodName] : cls;
        const opts = {};
        ["range", "nargs", "complete"].forEach((option) => {
          if (options && typeof options[option] !== "undefined") {
            opts[option] = options[option];
          }
        });
        Object.defineProperty(f, properties_1.NVIM_METHOD_NAME, { value: `command:${name}` });
        Object.defineProperty(f, properties_1.NVIM_SYNC, { value: !!sync });
        Object.defineProperty(f, properties_1.NVIM_SPEC, {
          value: {
            type: "command",
            name,
            sync: !!sync,
            opts
          }
        });
        if (isMethod) {
          cls[methodName] = f;
        }
        return cls;
      };
    }
    exports.command = command;
  }
});

// node_modules/neovim/lib/plugin/index.js
var require_plugin2 = __commonJS({
  "node_modules/neovim/lib/plugin/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Command = exports.Autocmd = exports.Function = exports.Plugin = void 0;
    var plugin_1 = require_plugin();
    Object.defineProperty(exports, "Plugin", { enumerable: true, get: function() {
      return plugin_1.plugin;
    } });
    var function_1 = require_function();
    Object.defineProperty(exports, "Function", { enumerable: true, get: function() {
      return function_1.nvimFunction;
    } });
    var autocmd_1 = require_autocmd();
    Object.defineProperty(exports, "Autocmd", { enumerable: true, get: function() {
      return autocmd_1.autocmd;
    } });
    var command_1 = require_command();
    Object.defineProperty(exports, "Command", { enumerable: true, get: function() {
      return command_1.command;
    } });
  }
});

// node_modules/neovim/lib/plugin.js
var require_plugin3 = __commonJS({
  "node_modules/neovim/lib/plugin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Command = exports.Autocmd = exports.Function = exports.Plugin = void 0;
    var index_1 = require_plugin2();
    Object.defineProperty(exports, "Plugin", { enumerable: true, get: function() {
      return index_1.Plugin;
    } });
    Object.defineProperty(exports, "Function", { enumerable: true, get: function() {
      return index_1.Function;
    } });
    Object.defineProperty(exports, "Autocmd", { enumerable: true, get: function() {
      return index_1.Autocmd;
    } });
    Object.defineProperty(exports, "Command", { enumerable: true, get: function() {
      return index_1.Command;
    } });
  }
});

// node_modules/neovim/lib/host/factory.js
var require_factory = __commonJS({
  "node_modules/neovim/lib/host/factory.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadPlugin = void 0;
    var path = __importStar(require("path"));
    var Module = require("module");
    var NvimPlugin_1 = require_NvimPlugin();
    function createPlugin(filename, nvim, options = {}) {
      try {
        nvim.logger.debug(`createPlugin.${filename}.clearCache: ${options && !options.cache}`);
        if (options && !options.cache) {
          try {
            delete Module._cache[require.resolve(filename)];
          } catch (err) {
          }
        }
        const defaultImport = require(filename);
        const plugin = defaultImport && defaultImport.default || defaultImport;
        if (typeof plugin === "function") {
          return new NvimPlugin_1.NvimPlugin(filename, plugin, nvim);
        }
      } catch (err) {
        const file = path.basename(filename);
        nvim.logger.error(`[${file}] ${err.stack}`);
        nvim.logger.error(`[${file}] Error loading child ChildPlugin ${filename}`);
      }
      return null;
    }
    function loadPlugin(filename, nvim, options = {}) {
      try {
        return createPlugin(filename, nvim, options);
      } catch (err) {
        return null;
      }
    }
    exports.loadPlugin = loadPlugin;
  }
});

// node_modules/neovim/lib/utils/findNvim.js
var require_findNvim = __commonJS({
  "node_modules/neovim/lib/utils/findNvim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exportsForTesting = exports.findNvim = void 0;
    var node_child_process_1 = require("child_process");
    var node_path_1 = require("path");
    var node_fs_1 = require("fs");
    var versionRegex = /^(\d+)\.(\d+)\.(\d+)(?:-(.+))?$/;
    var nvimVersionRegex = /^NVIM\s+v(.+)$/m;
    var buildTypeRegex = /^Build\s+type:\s+(.+)$/m;
    var luaJitVersionRegex = /^LuaJIT\s+(.+)$/m;
    var windows = process.platform === "win32";
    function parseVersion(version) {
      if (typeof version !== "string") {
        throw new TypeError("Invalid version format: not a string");
      }
      const match = version.match(versionRegex);
      if (!match) {
        return void 0;
      }
      const [, major, minor, patch, prerelease] = match;
      const majorNumber = Number(major);
      const minorNumber = Number(minor);
      const patchNumber = Number(patch);
      const versionParts = [
        majorNumber,
        minorNumber,
        patchNumber
      ];
      if (prerelease !== void 0) {
        versionParts.push(prerelease);
      } else {
        versionParts.push("zzz");
      }
      return versionParts;
    }
    function compareVersions(a, b) {
      const versionA = parseVersion(a);
      const versionB = parseVersion(b);
      const length = Math.min(versionA.length, versionB.length);
      for (let i = 0; i < length; i = i + 1) {
        const partA = versionA[i];
        const partB = versionB[i];
        if (partA < partB) {
          return -1;
        }
        if (partA > partB) {
          return 1;
        }
      }
      if (versionB.length > versionA.length) {
        return -1;
      }
      return 0;
    }
    function findNvim3(opt = {}) {
      const paths = process.env.PATH.split(node_path_1.delimiter);
      const pathLength = paths.length;
      const matches = new Array();
      const invalid = new Array();
      for (let i = 0; i !== pathLength; i = i + 1) {
        const nvimPath = (0, node_path_1.join)(paths[i], windows ? "nvim.exe" : "nvim");
        if ((0, node_fs_1.existsSync)(nvimPath)) {
          try {
            (0, node_fs_1.accessSync)(nvimPath, node_fs_1.constants.X_OK);
            const nvimVersionFull = (0, node_child_process_1.execFileSync)(nvimPath, [
              "--version"
            ]).toString();
            const nvimVersionMatch = nvimVersionRegex.exec(nvimVersionFull);
            const buildTypeMatch = buildTypeRegex.exec(nvimVersionFull);
            const luaJitVersionMatch = luaJitVersionRegex.exec(nvimVersionFull);
            if (nvimVersionMatch && buildTypeMatch && luaJitVersionMatch) {
              if ("minVersion" in opt && compareVersions(opt.minVersion, nvimVersionMatch[1]) === 1) {
                invalid.push({
                  nvimVersion: nvimVersionMatch[1],
                  path: nvimPath,
                  buildType: buildTypeMatch[1],
                  luaJitVersion: luaJitVersionMatch[1]
                });
              } else {
                matches.push({
                  nvimVersion: nvimVersionMatch[1],
                  path: nvimPath,
                  buildType: buildTypeMatch[1],
                  luaJitVersion: luaJitVersionMatch[1]
                });
              }
            }
          } catch (e) {
            invalid.push({
              path: nvimPath,
              error: e
            });
          }
        }
      }
      if (opt.orderBy === void 0 || opt.orderBy === "desc") {
        matches.sort((a, b) => compareVersions(b.nvimVersion, a.nvimVersion));
      }
      return {
        matches,
        invalid
      };
    }
    exports.findNvim = findNvim3;
    if (process.env.NODE_ENV === "test") {
      exports.exportsForTesting = {
        parseVersion,
        compareVersions
      };
    }
  }
});

// node_modules/neovim/lib/index.js
var require_lib = __commonJS({
  "node_modules/neovim/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findNvim = exports.loadPlugin = exports.NvimPlugin = exports.Command = exports.Autocmd = exports.Function = exports.Plugin = exports.Window = exports.Tabpage = exports.Buffer = exports.NeovimClient = exports.Neovim = exports.attach = void 0;
    var attach_1 = require_attach2();
    Object.defineProperty(exports, "attach", { enumerable: true, get: function() {
      return attach_1.attach;
    } });
    var index_1 = require_api();
    Object.defineProperty(exports, "Neovim", { enumerable: true, get: function() {
      return index_1.Neovim;
    } });
    Object.defineProperty(exports, "NeovimClient", { enumerable: true, get: function() {
      return index_1.NeovimClient;
    } });
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: function() {
      return index_1.Buffer;
    } });
    Object.defineProperty(exports, "Tabpage", { enumerable: true, get: function() {
      return index_1.Tabpage;
    } });
    Object.defineProperty(exports, "Window", { enumerable: true, get: function() {
      return index_1.Window;
    } });
    var plugin_1 = require_plugin3();
    Object.defineProperty(exports, "Plugin", { enumerable: true, get: function() {
      return plugin_1.Plugin;
    } });
    Object.defineProperty(exports, "Function", { enumerable: true, get: function() {
      return plugin_1.Function;
    } });
    Object.defineProperty(exports, "Autocmd", { enumerable: true, get: function() {
      return plugin_1.Autocmd;
    } });
    Object.defineProperty(exports, "Command", { enumerable: true, get: function() {
      return plugin_1.Command;
    } });
    var NvimPlugin_1 = require_NvimPlugin();
    Object.defineProperty(exports, "NvimPlugin", { enumerable: true, get: function() {
      return NvimPlugin_1.NvimPlugin;
    } });
    var factory_1 = require_factory();
    Object.defineProperty(exports, "loadPlugin", { enumerable: true, get: function() {
      return factory_1.loadPlugin;
    } });
    var findNvim_1 = require_findNvim();
    Object.defineProperty(exports, "findNvim", { enumerable: true, get: function() {
      return findNvim_1.findNvim;
    } });
  }
});

// node_modules/systeminformation/package.json
var require_package2 = __commonJS({
  "node_modules/systeminformation/package.json"(exports, module2) {
    module2.exports = {
      name: "systeminformation",
      version: "5.23.5",
      description: "Advanced, lightweight system and OS information library",
      license: "MIT",
      author: "Sebastian Hildebrandt <hildebrandt@plus-innovations.com> (https://plus-innovations.com)",
      homepage: "https://systeminformation.io",
      main: "./lib/index.js",
      bin: {
        systeminformation: "lib/cli.js"
      },
      types: "./lib/index.d.ts",
      scripts: {
        test: "node ./test/test.js"
      },
      files: [
        "lib/"
      ],
      keywords: [
        "system information",
        "sysinfo",
        "monitor",
        "monitoring",
        "os",
        "linux",
        "osx",
        "windows",
        "freebsd",
        "openbsd",
        "netbsd",
        "cpu",
        "cpuload",
        "physical cores",
        "logical cores",
        "processor",
        "cores",
        "threads",
        "socket type",
        "memory",
        "file system",
        "fsstats",
        "diskio",
        "block devices",
        "netstats",
        "network",
        "network interfaces",
        "network connections",
        "network stats",
        "iface",
        "printer",
        "processes",
        "users",
        "internet",
        "battery",
        "docker",
        "docker stats",
        "docker processes",
        "graphics",
        "graphic card",
        "graphic controller",
        "gpu",
        "display",
        "smart",
        "disk layout",
        "usb",
        "audio",
        "bluetooth",
        "wifi",
        "wifinetworks",
        "virtual box",
        "virtualbox",
        "vm",
        "backend",
        "hardware",
        "BIOS",
        "chassis"
      ],
      repository: {
        type: "git",
        url: "https://github.com/sebhildebrandt/systeminformation.git"
      },
      funding: {
        type: "Buy me a coffee",
        url: "https://www.buymeacoffee.com/systeminfo"
      },
      os: [
        "darwin",
        "linux",
        "win32",
        "freebsd",
        "openbsd",
        "netbsd",
        "sunos",
        "android"
      ],
      engines: {
        node: ">=8.0.0"
      }
    };
  }
});

// node_modules/systeminformation/lib/util.js
var require_util2 = __commonJS({
  "node_modules/systeminformation/lib/util.js"(exports) {
    "use strict";
    var os2 = require("os");
    var fs = require("fs");
    var path = require("path");
    var spawn2 = require("child_process").spawn;
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util = require("util");
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _cores = 0;
    var wmicPath = "";
    var codepage = "";
    var _smartMonToolsInstalled = null;
    var _rpi_cpuinfo = null;
    var WINDIR = process.env.WINDIR || "C:\\Windows";
    var _psChild;
    var _psResult = "";
    var _psCmds = [];
    var _psPersistent = false;
    var _psToUTF8 = "$OutputEncoding = [System.Console]::OutputEncoding = [System.Console]::InputEncoding = [System.Text.Encoding]::UTF8 ; ";
    var _psCmdStart = "--###START###--";
    var _psError = "--ERROR--";
    var _psCmdSeperator = "--###ENDCMD###--";
    var _psIdSeperator = "--##ID##--";
    var execOptsWin = {
      windowsHide: true,
      maxBuffer: 1024 * 2e4,
      encoding: "UTF-8",
      env: Object.assign({}, process.env, { LANG: "en_US.UTF-8" })
    };
    var execOptsLinux = {
      maxBuffer: 1024 * 2e4,
      encoding: "UTF-8",
      stdio: ["pipe", "pipe", "ignore"]
    };
    function toInt(value) {
      let result = parseInt(value, 10);
      if (isNaN(result)) {
        result = 0;
      }
      return result;
    }
    function splitByNumber(str) {
      let numberStarted = false;
      let num = "";
      let cpart = "";
      for (const c of str) {
        if (c >= "0" && c <= "9" || numberStarted) {
          numberStarted = true;
          num += c;
        } else {
          cpart += c;
        }
      }
      return [cpart, num];
    }
    var stringReplace = new String().replace;
    var stringToLower = new String().toLowerCase;
    var stringToString = new String().toString;
    var stringSubstr = new String().substr;
    var stringTrim = new String().trim;
    var stringStartWith = new String().startsWith;
    var mathMin = Math.min;
    function isFunction(functionToCheck) {
      let getType = {};
      return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
    }
    function unique(obj) {
      let uniques = [];
      let stringify = {};
      for (let i = 0; i < obj.length; i++) {
        let keys = Object.keys(obj[i]);
        keys.sort(function(a, b) {
          return a - b;
        });
        let str = "";
        for (let j = 0; j < keys.length; j++) {
          str += JSON.stringify(keys[j]);
          str += JSON.stringify(obj[i][keys[j]]);
        }
        if (!{}.hasOwnProperty.call(stringify, str)) {
          uniques.push(obj[i]);
          stringify[str] = true;
        }
      }
      return uniques;
    }
    function sortByKey(array, keys) {
      return array.sort(function(a, b) {
        let x = "";
        let y = "";
        keys.forEach(function(key) {
          x = x + a[key];
          y = y + b[key];
        });
        return x < y ? -1 : x > y ? 1 : 0;
      });
    }
    function cores() {
      if (_cores === 0) {
        _cores = os2.cpus().length;
      }
      return _cores;
    }
    function getValue(lines, property, separator, trimmed, lineMatch) {
      separator = separator || ":";
      property = property.toLowerCase();
      trimmed = trimmed || false;
      lineMatch = lineMatch || false;
      let result = "";
      lines.some((line) => {
        let lineLower = line.toLowerCase().replace(/\t/g, "");
        if (trimmed) {
          lineLower = lineLower.trim();
        }
        if (lineLower.startsWith(property) && (lineMatch ? lineLower.match(property + separator) || lineLower.match(property + " " + separator) : true)) {
          const parts = trimmed ? line.trim().split(separator) : line.split(separator);
          if (parts.length >= 2) {
            parts.shift();
            result = parts.join(separator).trim();
            return true;
          }
        }
      });
      return result;
    }
    function decodeEscapeSequence(str, base) {
      base = base || 16;
      return str.replace(/\\x([0-9A-Fa-f]{2})/g, function() {
        return String.fromCharCode(parseInt(arguments[1], base));
      });
    }
    function detectSplit(str) {
      let seperator = "";
      let part = 0;
      str.split("").forEach((element) => {
        if (element >= "0" && element <= "9") {
          if (part === 1) {
            part++;
          }
        } else {
          if (part === 0) {
            part++;
          }
          if (part === 1) {
            seperator += element;
          }
        }
      });
      return seperator;
    }
    function parseTime(t, pmDesignator) {
      pmDesignator = pmDesignator || "";
      t = t.toUpperCase();
      let hour = 0;
      let min = 0;
      let splitter = detectSplit(t);
      let parts = t.split(splitter);
      if (parts.length >= 2) {
        if (parts[2]) {
          parts[1] += parts[2];
        }
        let isPM = parts[1] && parts[1].toLowerCase().indexOf("pm") > -1 || parts[1].toLowerCase().indexOf("p.m.") > -1 || parts[1].toLowerCase().indexOf("p. m.") > -1 || parts[1].toLowerCase().indexOf("n") > -1 || parts[1].toLowerCase().indexOf("ch") > -1 || parts[1].toLowerCase().indexOf("\xF6s") > -1 || pmDesignator && parts[1].toLowerCase().indexOf(pmDesignator) > -1;
        hour = parseInt(parts[0], 10);
        min = parseInt(parts[1], 10);
        hour = isPM && hour < 12 ? hour + 12 : hour;
        return ("0" + hour).substr(-2) + ":" + ("0" + min).substr(-2);
      }
    }
    function parseDateTime(dt, culture) {
      const result = {
        date: "",
        time: ""
      };
      culture = culture || {};
      let dateFormat = (culture.dateFormat || "").toLowerCase();
      let pmDesignator = culture.pmDesignator || "";
      const parts = dt.split(" ");
      if (parts[0]) {
        if (parts[0].indexOf("/") >= 0) {
          const dtparts = parts[0].split("/");
          if (dtparts.length === 3) {
            if (dtparts[0].length === 4) {
              result.date = dtparts[0] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[2]).substr(-2);
            } else if (dtparts[2].length === 2) {
              if (dateFormat.indexOf("/d/") > -1 || dateFormat.indexOf("/dd/") > -1) {
                result.date = "20" + dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
              } else {
                result.date = "20" + dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
              }
            } else {
              const isEN = dt.toLowerCase().indexOf("pm") > -1 || dt.toLowerCase().indexOf("p.m.") > -1 || dt.toLowerCase().indexOf("p. m.") > -1 || dt.toLowerCase().indexOf("am") > -1 || dt.toLowerCase().indexOf("a.m.") > -1 || dt.toLowerCase().indexOf("a. m.") > -1;
              if ((isEN || dateFormat.indexOf("/d/") > -1 || dateFormat.indexOf("/dd/") > -1) && dateFormat.indexOf("dd/") !== 0) {
                result.date = dtparts[2] + "-" + ("0" + dtparts[0]).substr(-2) + "-" + ("0" + dtparts[1]).substr(-2);
              } else {
                result.date = dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
              }
            }
          }
        }
        if (parts[0].indexOf(".") >= 0) {
          const dtparts = parts[0].split(".");
          if (dtparts.length === 3) {
            if (dateFormat.indexOf(".d.") > -1 || dateFormat.indexOf(".dd.") > -1) {
              result.date = dtparts[2] + "-" + ("0" + dtparts[0]).substr(-2) + "-" + ("0" + dtparts[1]).substr(-2);
            } else {
              result.date = dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
            }
          }
        }
        if (parts[0].indexOf("-") >= 0) {
          const dtparts = parts[0].split("-");
          if (dtparts.length === 3) {
            result.date = dtparts[0] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[2]).substr(-2);
          }
        }
      }
      if (parts[1]) {
        parts.shift();
        let time = parts.join(" ");
        result.time = parseTime(time, pmDesignator);
      }
      return result;
    }
    function parseHead(head, rights) {
      let space = rights > 0;
      let count = 1;
      let from = 0;
      let to = 0;
      let result = [];
      for (let i = 0; i < head.length; i++) {
        if (count <= rights) {
          if (/\s/.test(head[i]) && !space) {
            to = i - 1;
            result.push({
              from,
              to: to + 1,
              cap: head.substring(from, to + 1)
            });
            from = to + 2;
            count++;
          }
          space = head[i] === " ";
        } else {
          if (!/\s/.test(head[i]) && space) {
            to = i - 1;
            if (from < to) {
              result.push({
                from,
                to,
                cap: head.substring(from, to)
              });
            }
            from = to + 1;
            count++;
          }
          space = head[i] === " ";
        }
      }
      to = 5e3;
      result.push({
        from,
        to,
        cap: head.substring(from, to)
      });
      let len = result.length;
      for (let i = 0; i < len; i++) {
        if (result[i].cap.replace(/\s/g, "").length === 0) {
          if (i + 1 < len) {
            result[i].to = result[i + 1].to;
            result[i].cap = result[i].cap + result[i + 1].cap;
            result.splice(i + 1, 1);
            len = len - 1;
          }
        }
      }
      return result;
    }
    function findObjectByKey(array, key, value) {
      for (let i = 0; i < array.length; i++) {
        if (array[i][key] === value) {
          return i;
        }
      }
      return -1;
    }
    function getWmic() {
      if (os2.type() === "Windows_NT" && !wmicPath) {
        wmicPath = WINDIR + "\\system32\\wbem\\wmic.exe";
        if (!fs.existsSync(wmicPath)) {
          try {
            const wmicPathArray = execSync("WHERE WMIC", execOptsWin).toString().split("\r\n");
            if (wmicPathArray && wmicPathArray.length) {
              wmicPath = wmicPathArray[0];
            } else {
              wmicPath = "wmic";
            }
          } catch (e) {
            wmicPath = "wmic";
          }
        }
      }
      return wmicPath;
    }
    function wmic(command) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          try {
            powerShell(getWmic() + " " + command).then((stdout) => {
              resolve(stdout, "");
            });
          } catch (e) {
            resolve("", e);
          }
        });
      });
    }
    function getVboxmanage() {
      return _windows ? `"${process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH}\\VBoxManage.exe"` : "vboxmanage";
    }
    function powerShellProceedResults(data) {
      let id = "";
      let parts;
      let res = "";
      if (data.indexOf(_psCmdStart) >= 0) {
        parts = data.split(_psCmdStart);
        const parts2 = parts[1].split(_psIdSeperator);
        id = parts2[0];
        if (parts2.length > 1) {
          data = parts2.slice(1).join(_psIdSeperator);
        }
      }
      if (data.indexOf(_psCmdSeperator) >= 0) {
        parts = data.split(_psCmdSeperator);
        res = parts[0];
      }
      let remove = -1;
      for (let i = 0; i < _psCmds.length; i++) {
        if (_psCmds[i].id === id) {
          remove = i;
          _psCmds[i].callback(res);
        }
      }
      if (remove >= 0) {
        _psCmds.splice(remove, 1);
      }
    }
    function powerShellStart() {
      if (!_psChild) {
        _psChild = spawn2("powershell.exe", ["-NoProfile", "-NoLogo", "-InputFormat", "Text", "-NoExit", "-Command", "-"], {
          stdio: "pipe",
          windowsHide: true,
          maxBuffer: 1024 * 2e4,
          encoding: "UTF-8",
          env: Object.assign({}, process.env, { LANG: "en_US.UTF-8" })
        });
        if (_psChild && _psChild.pid) {
          _psPersistent = true;
          _psChild.stdout.on("data", function(data) {
            _psResult = _psResult + data.toString("utf8");
            if (data.indexOf(_psCmdSeperator) >= 0) {
              powerShellProceedResults(_psResult);
              _psResult = "";
            }
          });
          _psChild.stderr.on("data", function() {
            powerShellProceedResults(_psResult + _psError);
          });
          _psChild.on("error", function() {
            powerShellProceedResults(_psResult + _psError);
          });
          _psChild.on("close", function() {
            if (_psChild) {
              _psChild.kill();
            }
          });
        }
      }
    }
    function powerShellRelease() {
      try {
        if (_psChild) {
          _psChild.stdin.write("exit" + os2.EOL);
          _psChild.stdin.end();
          _psPersistent = false;
        }
      } catch (e) {
        if (_psChild) {
          _psChild.kill();
        }
      }
      _psChild = null;
    }
    function powerShell(cmd) {
      if (_psPersistent) {
        const id = Math.random().toString(36).substring(2, 12);
        return new Promise((resolve) => {
          process.nextTick(() => {
            function callback(data) {
              resolve(data);
            }
            _psCmds.push({
              id,
              cmd,
              callback,
              start: new Date()
            });
            try {
              if (_psChild && _psChild.pid) {
                _psChild.stdin.write(_psToUTF8 + "echo " + _psCmdStart + id + _psIdSeperator + "; " + os2.EOL + cmd + os2.EOL + "echo " + _psCmdSeperator + os2.EOL);
              }
            } catch (e) {
              resolve("");
            }
          });
        });
      } else {
        let result = "";
        return new Promise((resolve) => {
          process.nextTick(() => {
            try {
              const child = spawn2("powershell.exe", ["-NoProfile", "-NoLogo", "-InputFormat", "Text", "-NoExit", "-ExecutionPolicy", "Unrestricted", "-Command", "-"], {
                stdio: "pipe",
                windowsHide: true,
                maxBuffer: 1024 * 2e4,
                encoding: "UTF-8",
                env: Object.assign({}, process.env, { LANG: "en_US.UTF-8" })
              });
              if (child && !child.pid) {
                child.on("error", function() {
                  resolve(result);
                });
              }
              if (child && child.pid) {
                child.stdout.on("data", function(data) {
                  result = result + data.toString("utf8");
                });
                child.stderr.on("data", function() {
                  child.kill();
                  resolve(result);
                });
                child.on("close", function() {
                  child.kill();
                  resolve(result);
                });
                child.on("error", function() {
                  child.kill();
                  resolve(result);
                });
                try {
                  child.stdin.write(_psToUTF8 + cmd + os2.EOL);
                  child.stdin.write("exit" + os2.EOL);
                  child.stdin.end();
                } catch (e) {
                  child.kill();
                  resolve(result);
                }
              } else {
                resolve(result);
              }
            } catch (e) {
              resolve(result);
            }
          });
        });
      }
    }
    function execSafe(cmd, args, options) {
      let result = "";
      options = options || {};
      return new Promise((resolve) => {
        process.nextTick(() => {
          try {
            const child = spawn2(cmd, args, options);
            if (child && !child.pid) {
              child.on("error", function() {
                resolve(result);
              });
            }
            if (child && child.pid) {
              child.stdout.on("data", function(data) {
                result += data.toString();
              });
              child.on("close", function() {
                child.kill();
                resolve(result);
              });
              child.on("error", function() {
                child.kill();
                resolve(result);
              });
            } else {
              resolve(result);
            }
          } catch (e) {
            resolve(result);
          }
        });
      });
    }
    function getCodepage() {
      if (_windows) {
        if (!codepage) {
          try {
            const stdout = execSync("chcp", execOptsWin);
            const lines = stdout.toString().split("\r\n");
            const parts = lines[0].split(":");
            codepage = parts.length > 1 ? parts[1].replace(".", "").trim() : "";
          } catch (err) {
            codepage = "437";
          }
        }
        return codepage;
      }
      if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {
        if (!codepage) {
          try {
            const stdout = execSync("echo $LANG", util.execOptsLinux);
            const lines = stdout.toString().split("\r\n");
            const parts = lines[0].split(".");
            codepage = parts.length > 1 ? parts[1].trim() : "";
            if (!codepage) {
              codepage = "UTF-8";
            }
          } catch (err) {
            codepage = "UTF-8";
          }
        }
        return codepage;
      }
    }
    function smartMonToolsInstalled() {
      if (_smartMonToolsInstalled !== null) {
        return _smartMonToolsInstalled;
      }
      _smartMonToolsInstalled = false;
      if (_windows) {
        try {
          const pathArray = execSync("WHERE smartctl 2>nul", execOptsWin).toString().split("\r\n");
          if (pathArray && pathArray.length) {
            _smartMonToolsInstalled = pathArray[0].indexOf(":\\") >= 0;
          } else {
            _smartMonToolsInstalled = false;
          }
        } catch (e) {
          _smartMonToolsInstalled = false;
        }
      }
      if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {
        try {
          const pathArray = execSync("which smartctl 2>/dev/null", execOptsLinux).toString().split("\r\n");
          _smartMonToolsInstalled = pathArray.length > 0;
        } catch (e) {
          util.noop();
        }
      }
      return _smartMonToolsInstalled;
    }
    function isRaspberry() {
      const PI_MODEL_NO = [
        "BCM2708",
        "BCM2709",
        "BCM2710",
        "BCM2711",
        "BCM2712",
        "BCM2835",
        "BCM2836",
        "BCM2837",
        "BCM2837B0"
      ];
      let cpuinfo = [];
      if (_rpi_cpuinfo !== null) {
        cpuinfo = _rpi_cpuinfo;
      } else {
        try {
          cpuinfo = fs.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).toString().split("\n");
          _rpi_cpuinfo = cpuinfo;
        } catch (e) {
          return false;
        }
      }
      const hardware = getValue(cpuinfo, "hardware");
      return hardware && PI_MODEL_NO.indexOf(hardware) > -1;
    }
    function isRaspbian() {
      let osrelease = [];
      try {
        osrelease = fs.readFileSync("/etc/os-release", { encoding: "utf8" }).toString().split("\n");
      } catch (e) {
        return false;
      }
      const id = getValue(osrelease, "id", "=");
      return id && id.indexOf("raspbian") > -1;
    }
    function execWin(cmd, opts, callback) {
      if (!callback) {
        callback = opts;
        opts = execOptsWin;
      }
      let newCmd = "chcp 65001 > nul && cmd /C " + cmd + " && chcp " + codepage + " > nul";
      exec2(newCmd, opts, function(error, stdout) {
        callback(error, stdout);
      });
    }
    function darwinXcodeExists() {
      const cmdLineToolsExists = fs.existsSync("/Library/Developer/CommandLineTools/usr/bin/");
      const xcodeAppExists = fs.existsSync("/Applications/Xcode.app/Contents/Developer/Tools");
      const xcodeExists = fs.existsSync("/Library/Developer/Xcode/");
      return cmdLineToolsExists || xcodeExists || xcodeAppExists;
    }
    function nanoSeconds() {
      const time = process.hrtime();
      if (!Array.isArray(time) || time.length !== 2) {
        return 0;
      }
      return +time[0] * 1e9 + +time[1];
    }
    function countUniqueLines(lines, startingWith) {
      startingWith = startingWith || "";
      const uniqueLines = [];
      lines.forEach((line) => {
        if (line.startsWith(startingWith)) {
          if (uniqueLines.indexOf(line) === -1) {
            uniqueLines.push(line);
          }
        }
      });
      return uniqueLines.length;
    }
    function countLines(lines, startingWith) {
      startingWith = startingWith || "";
      const uniqueLines = [];
      lines.forEach((line) => {
        if (line.startsWith(startingWith)) {
          uniqueLines.push(line);
        }
      });
      return uniqueLines.length;
    }
    function sanitizeShellString(str, strict) {
      if (typeof strict === "undefined") {
        strict = false;
      }
      const s = str || "";
      let result = "";
      const l = mathMin(s.length, 2e3);
      for (let i = 0; i <= l; i++) {
        if (!(s[i] === void 0 || s[i] === ">" || s[i] === "<" || s[i] === "*" || s[i] === "?" || s[i] === "[" || s[i] === "]" || s[i] === "|" || s[i] === "\u02DA" || s[i] === "$" || s[i] === ";" || s[i] === "&" || s[i] === "]" || s[i] === "#" || s[i] === "\\" || s[i] === "	" || s[i] === "\n" || s[i] === "\r" || s[i] === "'" || s[i] === "`" || s[i] === '"' || s[i].length > 1 || strict && s[i] === "(" || strict && s[i] === ")" || strict && s[i] === "@" || strict && s[i] === " " || strict && s[i] == "{" || strict && s[i] == ";" || strict && s[i] == "}")) {
          result = result + s[i];
        }
      }
      return result;
    }
    function isPrototypePolluted() {
      const s = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
      let notPolluted = true;
      let st = "";
      st.__proto__.replace = stringReplace;
      st.__proto__.toLowerCase = stringToLower;
      st.__proto__.toString = stringToString;
      st.__proto__.substr = stringSubstr;
      notPolluted = notPolluted || s.length !== 62;
      const ms = Date.now();
      if (typeof ms === "number" && ms > 16e11) {
        const l = ms % 100 + 15;
        for (let i = 0; i < l; i++) {
          const r = Math.random() * 61.99999999 + 1;
          const rs = parseInt(Math.floor(r).toString(), 10);
          const rs2 = parseInt(r.toString().split(".")[0], 10);
          const q = Math.random() * 61.99999999 + 1;
          const qs = parseInt(Math.floor(q).toString(), 10);
          const qs2 = parseInt(q.toString().split(".")[0], 10);
          notPolluted = notPolluted && r !== q;
          notPolluted = notPolluted && rs === rs2 && qs === qs2;
          st += s[rs - 1];
        }
        notPolluted = notPolluted && st.length === l;
        let p = Math.random() * l * 0.9999999999;
        let stm = st.substr(0, p) + " " + st.substr(p, 2e3);
        stm.__proto__.replace = stringReplace;
        let sto = stm.replace(/ /g, "");
        notPolluted = notPolluted && st === sto;
        p = Math.random() * l * 0.9999999999;
        stm = st.substr(0, p) + "{" + st.substr(p, 2e3);
        sto = stm.replace(/{/g, "");
        notPolluted = notPolluted && st === sto;
        p = Math.random() * l * 0.9999999999;
        stm = st.substr(0, p) + "*" + st.substr(p, 2e3);
        sto = stm.replace(/\*/g, "");
        notPolluted = notPolluted && st === sto;
        p = Math.random() * l * 0.9999999999;
        stm = st.substr(0, p) + "$" + st.substr(p, 2e3);
        sto = stm.replace(/\$/g, "");
        notPolluted = notPolluted && st === sto;
        const stl = st.toLowerCase();
        notPolluted = notPolluted && stl.length === l && stl[l - 1] && !stl[l];
        for (let i = 0; i < l; i++) {
          const s1 = st[i];
          s1.__proto__.toLowerCase = stringToLower;
          const s2 = stl ? stl[i] : "";
          const s1l = s1.toLowerCase();
          notPolluted = notPolluted && s1l[0] === s2 && s1l[0] && !s1l[1];
        }
      }
      return !notPolluted;
    }
    function hex2bin(hex) {
      return ("00000000" + parseInt(hex, 16).toString(2)).substr(-8);
    }
    function getFilesInPath(source) {
      const lstatSync = fs.lstatSync;
      const readdirSync = fs.readdirSync;
      const join = path.join;
      function isDirectory(source2) {
        return lstatSync(source2).isDirectory();
      }
      function isFile(source2) {
        return lstatSync(source2).isFile();
      }
      function getDirectories(source2) {
        return readdirSync(source2).map(function(name) {
          return join(source2, name);
        }).filter(isDirectory);
      }
      function getFiles(source2) {
        return readdirSync(source2).map(function(name) {
          return join(source2, name);
        }).filter(isFile);
      }
      function getFilesRecursively(source2) {
        try {
          let dirs = getDirectories(source2);
          let files = dirs.map(function(dir) {
            return getFilesRecursively(dir);
          }).reduce(function(a, b) {
            return a.concat(b);
          }, []);
          return files.concat(getFiles(source2));
        } catch (e) {
          return [];
        }
      }
      if (fs.existsSync(source)) {
        return getFilesRecursively(source);
      } else {
        return [];
      }
    }
    function decodePiCpuinfo(lines) {
      if (_rpi_cpuinfo === null) {
        _rpi_cpuinfo = lines;
      }
      const oldRevisionCodes = {
        "0002": {
          type: "B",
          revision: "1.0",
          memory: 256,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0003": {
          type: "B",
          revision: "1.0",
          memory: 256,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0004": {
          type: "B",
          revision: "2.0",
          memory: 256,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0005": {
          type: "B",
          revision: "2.0",
          memory: 256,
          manufacturer: "Qisda",
          processor: "BCM2835"
        },
        "0006": {
          type: "B",
          revision: "2.0",
          memory: 256,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0007": {
          type: "A",
          revision: "2.0",
          memory: 256,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0008": {
          type: "A",
          revision: "2.0",
          memory: 256,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0009": {
          type: "A",
          revision: "2.0",
          memory: 256,
          manufacturer: "Qisda",
          processor: "BCM2835"
        },
        "000d": {
          type: "B",
          revision: "2.0",
          memory: 512,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "000e": {
          type: "B",
          revision: "2.0",
          memory: 512,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "000f": {
          type: "B",
          revision: "2.0",
          memory: 512,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0010": {
          type: "B+",
          revision: "1.2",
          memory: 512,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0011": {
          type: "CM1",
          revision: "1.0",
          memory: 512,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0012": {
          type: "A+",
          revision: "1.1",
          memory: 256,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0013": {
          type: "B+",
          revision: "1.2",
          memory: 512,
          manufacturer: "Embest",
          processor: "BCM2835"
        },
        "0014": {
          type: "CM1",
          revision: "1.0",
          memory: 512,
          manufacturer: "Embest",
          processor: "BCM2835"
        },
        "0015": {
          type: "A+",
          revision: "1.1",
          memory: 256,
          manufacturer: "512MB	Embest",
          processor: "BCM2835"
        }
      };
      const processorList = [
        "BCM2835",
        "BCM2836",
        "BCM2837",
        "BCM2711",
        "BCM2712"
      ];
      const manufacturerList = [
        "Sony UK",
        "Egoman",
        "Embest",
        "Sony Japan",
        "Embest",
        "Stadium"
      ];
      const typeList = {
        "00": "A",
        "01": "B",
        "02": "A+",
        "03": "B+",
        "04": "2B",
        "05": "Alpha (early prototype)",
        "06": "CM1",
        "08": "3B",
        "09": "Zero",
        "0a": "CM3",
        "0c": "Zero W",
        "0d": "3B+",
        "0e": "3A+",
        "0f": "Internal use only",
        "10": "CM3+",
        "11": "4B",
        "12": "Zero 2 W",
        "13": "400",
        "14": "CM4",
        "15": "CM4S",
        "17": "5"
      };
      const revisionCode = getValue(lines, "revision", ":", true);
      const model = getValue(lines, "model:", ":", true);
      const serial = getValue(lines, "serial", ":", true);
      let result = {};
      if ({}.hasOwnProperty.call(oldRevisionCodes, revisionCode)) {
        result = {
          model,
          serial,
          revisionCode,
          memory: oldRevisionCodes[revisionCode].memory,
          manufacturer: oldRevisionCodes[revisionCode].manufacturer,
          processor: oldRevisionCodes[revisionCode].processor,
          type: oldRevisionCodes[revisionCode].type,
          revision: oldRevisionCodes[revisionCode].revision
        };
      } else {
        const revision = ("00000000" + getValue(lines, "revision", ":", true).toLowerCase()).substr(-8);
        const memSizeCode = parseInt(hex2bin(revision.substr(2, 1)).substr(5, 3), 2) || 0;
        const manufacturer = manufacturerList[parseInt(revision.substr(3, 1), 10)];
        const processor = processorList[parseInt(revision.substr(4, 1), 10)];
        const typeCode = revision.substr(5, 2);
        result = {
          model,
          serial,
          revisionCode,
          memory: 256 * Math.pow(2, memSizeCode),
          manufacturer,
          processor,
          type: {}.hasOwnProperty.call(typeList, typeCode) ? typeList[typeCode] : "",
          revision: "1." + revision.substr(7, 1)
        };
      }
      return result;
    }
    function getRpiGpu() {
      let cpuinfo = null;
      if (_rpi_cpuinfo !== null) {
        cpuinfo = _rpi_cpuinfo;
      } else {
        try {
          cpuinfo = fs.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).toString().split("\n");
          _rpi_cpuinfo = cpuinfo;
        } catch (e) {
          return false;
        }
      }
      const rpi = decodePiCpuinfo(cpuinfo);
      if (rpi.type === "4B" || rpi.type === "CM4" || rpi.type === "CM4S" || rpi.type === "400") {
        return "VideoCore VI";
      }
      if (rpi.type === "5") {
        return "VideoCore VII";
      }
      return "VideoCore IV";
    }
    function promiseAll(promises) {
      const resolvingPromises = promises.map(function(promise) {
        return new Promise(function(resolve) {
          let payload = new Array(2);
          promise.then(function(result) {
            payload[0] = result;
          }).catch(function(error) {
            payload[1] = error;
          }).then(function() {
            resolve(payload);
          });
        });
      });
      const errors = [];
      const results = [];
      return Promise.all(resolvingPromises).then(function(items) {
        items.forEach(function(payload) {
          if (payload[1]) {
            errors.push(payload[1]);
            results.push(null);
          } else {
            errors.push(null);
            results.push(payload[0]);
          }
        });
        return {
          errors,
          results
        };
      });
    }
    function promisify(nodeStyleFunction) {
      return function() {
        const args = Array.prototype.slice.call(arguments);
        return new Promise(function(resolve, reject) {
          args.push(function(err, data) {
            if (err) {
              reject(err);
            } else {
              resolve(data);
            }
          });
          nodeStyleFunction.apply(null, args);
        });
      };
    }
    function promisifySave(nodeStyleFunction) {
      return function() {
        const args = Array.prototype.slice.call(arguments);
        return new Promise(function(resolve) {
          args.push(function(err, data) {
            resolve(data);
          });
          nodeStyleFunction.apply(null, args);
        });
      };
    }
    function linuxVersion() {
      let result = "";
      if (_linux) {
        try {
          result = execSync("uname -v", util.execOptsLinux).toString();
        } catch (e) {
          result = "";
        }
      }
      return result;
    }
    function plistParser(xmlStr) {
      const tags = ["array", "dict", "key", "string", "integer", "date", "real", "data", "boolean", "arrayEmpty"];
      const startStr = "<plist version";
      let pos = xmlStr.indexOf(startStr);
      let len = xmlStr.length;
      while (xmlStr[pos] !== ">" && pos < len) {
        pos++;
      }
      let depth = 0;
      let inTagStart = false;
      let inTagContent = false;
      let inTagEnd = false;
      let metaData = [{ tagStart: "", tagEnd: "", tagContent: "", key: "", data: null }];
      let c = "";
      let cn = xmlStr[pos];
      while (pos < len) {
        c = cn;
        if (pos + 1 < len) {
          cn = xmlStr[pos + 1];
        }
        if (c === "<") {
          inTagContent = false;
          if (cn === "/") {
            inTagEnd = true;
          } else if (metaData[depth].tagStart) {
            metaData[depth].tagContent = "";
            if (!metaData[depth].data) {
              metaData[depth].data = metaData[depth].tagStart === "array" ? [] : {};
            }
            depth++;
            metaData.push({ tagStart: "", tagEnd: "", tagContent: "", key: null, data: null });
            inTagStart = true;
            inTagContent = false;
          } else if (!inTagStart) {
            inTagStart = true;
          }
        } else if (c === ">") {
          if (metaData[depth].tagStart === "true/") {
            inTagStart = false;
            inTagEnd = true;
            metaData[depth].tagStart = "";
            metaData[depth].tagEnd = "/boolean";
            metaData[depth].data = true;
          }
          if (metaData[depth].tagStart === "false/") {
            inTagStart = false;
            inTagEnd = true;
            metaData[depth].tagStart = "";
            metaData[depth].tagEnd = "/boolean";
            metaData[depth].data = false;
          }
          if (metaData[depth].tagStart === "array/") {
            inTagStart = false;
            inTagEnd = true;
            metaData[depth].tagStart = "";
            metaData[depth].tagEnd = "/arrayEmpty";
            metaData[depth].data = [];
          }
          if (inTagContent) {
            inTagContent = false;
          }
          if (inTagStart) {
            inTagStart = false;
            inTagContent = true;
            if (metaData[depth].tagStart === "array") {
              metaData[depth].data = [];
            }
            if (metaData[depth].tagStart === "dict") {
              metaData[depth].data = {};
            }
          }
          if (inTagEnd) {
            inTagEnd = false;
            if (metaData[depth].tagEnd && tags.indexOf(metaData[depth].tagEnd.substr(1)) >= 0) {
              if (metaData[depth].tagEnd === "/dict" || metaData[depth].tagEnd === "/array") {
                if (depth > 1 && metaData[depth - 2].tagStart === "array") {
                  metaData[depth - 2].data.push(metaData[depth - 1].data);
                }
                if (depth > 1 && metaData[depth - 2].tagStart === "dict") {
                  metaData[depth - 2].data[metaData[depth - 1].key] = metaData[depth - 1].data;
                }
                depth--;
                metaData.pop();
                metaData[depth].tagContent = "";
                metaData[depth].tagStart = "";
                metaData[depth].tagEnd = "";
              } else {
                if (metaData[depth].tagEnd === "/key" && metaData[depth].tagContent) {
                  metaData[depth].key = metaData[depth].tagContent;
                } else {
                  if (metaData[depth].tagEnd === "/real" && metaData[depth].tagContent) {
                    metaData[depth].data = parseFloat(metaData[depth].tagContent) || 0;
                  }
                  if (metaData[depth].tagEnd === "/integer" && metaData[depth].tagContent) {
                    metaData[depth].data = parseInt(metaData[depth].tagContent) || 0;
                  }
                  if (metaData[depth].tagEnd === "/string" && metaData[depth].tagContent) {
                    metaData[depth].data = metaData[depth].tagContent || "";
                  }
                  if (metaData[depth].tagEnd === "/boolean") {
                    metaData[depth].data = metaData[depth].tagContent || false;
                  }
                  if (metaData[depth].tagEnd === "/arrayEmpty") {
                    metaData[depth].data = metaData[depth].tagContent || [];
                  }
                  if (depth > 0 && metaData[depth - 1].tagStart === "array") {
                    metaData[depth - 1].data.push(metaData[depth].data);
                  }
                  if (depth > 0 && metaData[depth - 1].tagStart === "dict") {
                    metaData[depth - 1].data[metaData[depth].key] = metaData[depth].data;
                  }
                }
                metaData[depth].tagContent = "";
                metaData[depth].tagStart = "";
                metaData[depth].tagEnd = "";
              }
            }
            metaData[depth].tagEnd = "";
            inTagStart = false;
            inTagContent = false;
          }
        } else {
          if (inTagStart) {
            metaData[depth].tagStart += c;
          }
          if (inTagEnd) {
            metaData[depth].tagEnd += c;
          }
          if (inTagContent) {
            metaData[depth].tagContent += c;
          }
        }
        pos++;
      }
      return metaData[0].data;
    }
    function strIsNumeric(str) {
      return typeof str === "string" && !isNaN(str) && !isNaN(parseFloat(str));
    }
    function plistReader(output) {
      const lines = output.split("\n");
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].indexOf(" = ") >= 0) {
          const lineParts = lines[i].split(" = ");
          lineParts[0] = lineParts[0].trim();
          if (!lineParts[0].startsWith('"')) {
            lineParts[0] = '"' + lineParts[0] + '"';
          }
          lineParts[1] = lineParts[1].trim();
          if (lineParts[1].indexOf('"') === -1 && lineParts[1].endsWith(";")) {
            const valueString = lineParts[1].substring(0, lineParts[1].length - 1);
            if (!strIsNumeric(valueString)) {
              lineParts[1] = `"${valueString}";`;
            }
          }
          if (lineParts[1].indexOf('"') >= 0 && lineParts[1].endsWith(";")) {
            const valueString = lineParts[1].substring(0, lineParts[1].length - 1).replace(/"/g, "");
            if (strIsNumeric(valueString)) {
              lineParts[1] = `${valueString};`;
            }
          }
          lines[i] = lineParts.join(" : ");
        }
        lines[i] = lines[i].replace(/\(/g, "[").replace(/\)/g, "]").replace(/;/g, ",").trim();
        if (lines[i].startsWith("}") && lines[i - 1] && lines[i - 1].endsWith(",")) {
          lines[i - 1] = lines[i - 1].substring(0, lines[i - 1].length - 1);
        }
      }
      output = lines.join("");
      let obj = {};
      try {
        obj = JSON.parse(output);
      } catch (e) {
        noop();
      }
      return obj;
    }
    function semverCompare(v1, v2) {
      let res = 0;
      const parts1 = v1.split(".");
      const parts2 = v2.split(".");
      if (parts1[0] < parts2[0]) {
        res = 1;
      } else if (parts1[0] > parts2[0]) {
        res = -1;
      } else if (parts1[0] === parts2[0] && parts1.length >= 2 && parts2.length >= 2) {
        if (parts1[1] < parts2[1]) {
          res = 1;
        } else if (parts1[1] > parts2[1]) {
          res = -1;
        } else if (parts1[1] === parts2[1]) {
          if (parts1.length >= 3 && parts2.length >= 3) {
            if (parts1[2] < parts2[2]) {
              res = 1;
            } else if (parts1[2] > parts2[2]) {
              res = -1;
            }
          } else if (parts2.length >= 3) {
            res = 1;
          }
        }
      }
      return res;
    }
    function noop() {
    }
    exports.toInt = toInt;
    exports.splitByNumber = splitByNumber;
    exports.execOptsWin = execOptsWin;
    exports.execOptsLinux = execOptsLinux;
    exports.getCodepage = getCodepage;
    exports.execWin = execWin;
    exports.isFunction = isFunction;
    exports.unique = unique;
    exports.sortByKey = sortByKey;
    exports.cores = cores;
    exports.getValue = getValue;
    exports.decodeEscapeSequence = decodeEscapeSequence;
    exports.parseDateTime = parseDateTime;
    exports.parseHead = parseHead;
    exports.findObjectByKey = findObjectByKey;
    exports.getWmic = getWmic;
    exports.wmic = wmic;
    exports.darwinXcodeExists = darwinXcodeExists;
    exports.getVboxmanage = getVboxmanage;
    exports.powerShell = powerShell;
    exports.powerShellStart = powerShellStart;
    exports.powerShellRelease = powerShellRelease;
    exports.execSafe = execSafe;
    exports.nanoSeconds = nanoSeconds;
    exports.countUniqueLines = countUniqueLines;
    exports.countLines = countLines;
    exports.noop = noop;
    exports.isRaspberry = isRaspberry;
    exports.isRaspbian = isRaspbian;
    exports.sanitizeShellString = sanitizeShellString;
    exports.isPrototypePolluted = isPrototypePolluted;
    exports.decodePiCpuinfo = decodePiCpuinfo;
    exports.getRpiGpu = getRpiGpu;
    exports.promiseAll = promiseAll;
    exports.promisify = promisify;
    exports.promisifySave = promisifySave;
    exports.smartMonToolsInstalled = smartMonToolsInstalled;
    exports.linuxVersion = linuxVersion;
    exports.plistParser = plistParser;
    exports.plistReader = plistReader;
    exports.stringReplace = stringReplace;
    exports.stringToLower = stringToLower;
    exports.stringToString = stringToString;
    exports.stringSubstr = stringSubstr;
    exports.stringTrim = stringTrim;
    exports.stringStartWith = stringStartWith;
    exports.mathMin = mathMin;
    exports.WINDIR = WINDIR;
    exports.getFilesInPath = getFilesInPath;
    exports.semverCompare = semverCompare;
  }
});

// node_modules/systeminformation/lib/system.js
var require_system = __commonJS({
  "node_modules/systeminformation/lib/system.js"(exports) {
    "use strict";
    var fs = require("fs");
    var os2 = require("os");
    var util = require_util2();
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var execPromise = util.promisify(require("child_process").exec);
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function system(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            manufacturer: "",
            model: "Computer",
            version: "",
            serial: "-",
            uuid: "-",
            sku: "-",
            virtual: false
          };
          if (_linux || _freebsd || _openbsd || _netbsd) {
            exec2("export LC_ALL=C; dmidecode -t system 2>/dev/null; unset LC_ALL", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result.manufacturer = util.getValue(lines, "manufacturer");
              result.model = util.getValue(lines, "product name");
              result.version = util.getValue(lines, "version");
              result.serial = util.getValue(lines, "serial number");
              result.uuid = util.getValue(lines, "uuid").toLowerCase();
              result.sku = util.getValue(lines, "sku number");
              const cmd = `echo -n "product_name: "; cat /sys/devices/virtual/dmi/id/product_name 2>/dev/null; echo;
            echo -n "product_serial: "; cat /sys/devices/virtual/dmi/id/product_serial 2>/dev/null; echo;
            echo -n "product_uuid: "; cat /sys/devices/virtual/dmi/id/product_uuid 2>/dev/null; echo;
            echo -n "product_version: "; cat /sys/devices/virtual/dmi/id/product_version 2>/dev/null; echo;
            echo -n "sys_vendor: "; cat /sys/devices/virtual/dmi/id/sys_vendor 2>/dev/null; echo;`;
              try {
                lines = execSync(cmd, util.execOptsLinux).toString().split("\n");
                result.manufacturer = result.manufacturer === "" ? util.getValue(lines, "sys_vendor") : result.manufacturer;
                result.model = result.model === "" ? util.getValue(lines, "product_name") : result.model;
                result.version = result.version === "" ? util.getValue(lines, "product_version") : result.version;
                result.serial = result.serial === "" ? util.getValue(lines, "product_serial") : result.serial;
                result.uuid = result.uuid === "" ? util.getValue(lines, "product_uuid").toLowerCase() : result.uuid;
              } catch (e) {
                util.noop();
              }
              if (!result.serial || result.serial.toLowerCase().indexOf("o.e.m.") !== -1) {
                result.serial = "-";
              }
              if (!result.manufacturer || result.manufacturer.toLowerCase().indexOf("o.e.m.") !== -1) {
                result.manufacturer = "";
              }
              if (!result.model || result.model.toLowerCase().indexOf("o.e.m.") !== -1) {
                result.model = "Computer";
              }
              if (!result.version || result.version.toLowerCase().indexOf("o.e.m.") !== -1) {
                result.version = "";
              }
              if (!result.sku || result.sku.toLowerCase().indexOf("o.e.m.") !== -1) {
                result.sku = "-";
              }
              if (result.model.toLowerCase() === "virtualbox" || result.model.toLowerCase() === "kvm" || result.model.toLowerCase() === "virtual machine" || result.model.toLowerCase() === "bochs" || result.model.toLowerCase().startsWith("vmware") || result.model.toLowerCase().startsWith("droplet")) {
                result.virtual = true;
                switch (result.model.toLowerCase()) {
                  case "virtualbox":
                    result.virtualHost = "VirtualBox";
                    break;
                  case "vmware":
                    result.virtualHost = "VMware";
                    break;
                  case "kvm":
                    result.virtualHost = "KVM";
                    break;
                  case "bochs":
                    result.virtualHost = "bochs";
                    break;
                }
              }
              if (result.manufacturer.toLowerCase().startsWith("vmware") || result.manufacturer.toLowerCase() === "xen") {
                result.virtual = true;
                switch (result.manufacturer.toLowerCase()) {
                  case "vmware":
                    result.virtualHost = "VMware";
                    break;
                  case "xen":
                    result.virtualHost = "Xen";
                    break;
                }
              }
              if (!result.virtual) {
                try {
                  const disksById = execSync("ls -1 /dev/disk/by-id/ 2>/dev/null", util.execOptsLinux).toString();
                  if (disksById.indexOf("_QEMU_") >= 0) {
                    result.virtual = true;
                    result.virtualHost = "QEMU";
                  }
                  if (disksById.indexOf("_VBOX_") >= 0) {
                    result.virtual = true;
                    result.virtualHost = "VirtualBox";
                  }
                } catch (e) {
                  util.noop();
                }
              }
              if (!result.virtual && (os2.release().toLowerCase().indexOf("microsoft") >= 0 || os2.release().toLowerCase().endsWith("wsl2"))) {
                const kernelVersion = parseFloat(os2.release().toLowerCase());
                result.virtual = true;
                result.manufacturer = "Microsoft";
                result.model = "WSL";
                result.version = kernelVersion < 4.19 ? "1" : "2";
              }
              if ((_freebsd || _openbsd || _netbsd) && !result.virtualHost) {
                try {
                  const procInfo = execSync("dmidecode -t 4", util.execOptsLinux);
                  const procLines = procInfo.toString().split("\n");
                  const procManufacturer = util.getValue(procLines, "manufacturer", ":", true);
                  switch (procManufacturer.toLowerCase()) {
                    case "virtualbox":
                      result.virtualHost = "VirtualBox";
                      break;
                    case "vmware":
                      result.virtualHost = "VMware";
                      break;
                    case "kvm":
                      result.virtualHost = "KVM";
                      break;
                    case "bochs":
                      result.virtualHost = "bochs";
                      break;
                  }
                } catch (e) {
                  util.noop();
                }
              }
              if (fs.existsSync("/.dockerenv") || fs.existsSync("/.dockerinit")) {
                result.model = "Docker Container";
              }
              try {
                const stdout2 = execSync('dmesg 2>/dev/null | grep -iE "virtual|hypervisor" | grep -iE "vmware|qemu|kvm|xen" | grep -viE "Nested Virtualization|/virtual/"');
                let lines2 = stdout2.toString().split("\n");
                if (lines2.length > 0) {
                  if (result.model === "Computer") {
                    result.model = "Virtual machine";
                  }
                  result.virtual = true;
                  if (stdout2.toString().toLowerCase().indexOf("vmware") >= 0 && !result.virtualHost) {
                    result.virtualHost = "VMware";
                  }
                  if (stdout2.toString().toLowerCase().indexOf("qemu") >= 0 && !result.virtualHost) {
                    result.virtualHost = "QEMU";
                  }
                  if (stdout2.toString().toLowerCase().indexOf("xen") >= 0 && !result.virtualHost) {
                    result.virtualHost = "Xen";
                  }
                  if (stdout2.toString().toLowerCase().indexOf("kvm") >= 0 && !result.virtualHost) {
                    result.virtualHost = "KVM";
                  }
                }
              } catch (e) {
                util.noop();
              }
              if (result.manufacturer === "" && result.model === "Computer" && result.version === "") {
                fs.readFile("/proc/cpuinfo", function(error2, stdout2) {
                  if (!error2) {
                    let lines2 = stdout2.toString().split("\n");
                    result.model = util.getValue(lines2, "hardware", ":", true).toUpperCase();
                    result.version = util.getValue(lines2, "revision", ":", true).toLowerCase();
                    result.serial = util.getValue(lines2, "serial", ":", true);
                    const model = util.getValue(lines2, "model:", ":", true);
                    if ((result.model === "BCM2835" || result.model === "BCM2708" || result.model === "BCM2709" || result.model === "BCM2710" || result.model === "BCM2711" || result.model === "BCM2836" || result.model === "BCM2837") && model.toLowerCase().indexOf("raspberry") >= 0) {
                      const rPIRevision = util.decodePiCpuinfo(lines2);
                      result.model = rPIRevision.model;
                      result.version = rPIRevision.revisionCode;
                      result.manufacturer = "Raspberry Pi Foundation";
                      result.raspberry = {
                        manufacturer: rPIRevision.manufacturer,
                        processor: rPIRevision.processor,
                        type: rPIRevision.type,
                        revision: rPIRevision.revision
                      };
                    }
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          }
          if (_darwin) {
            exec2("ioreg -c IOPlatformExpertDevice -d 2", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().replace(/[<>"]/g, "").split("\n");
                const model = util.splitByNumber(util.getValue(lines, "model", "=", true));
                const version = util.getValue(lines, "version", "=", true);
                result.manufacturer = util.getValue(lines, "manufacturer", "=", true);
                result.model = version ? util.getValue(lines, "model", "=", true) : model[0];
                result.version = version || model[1];
                result.serial = util.getValue(lines, "ioplatformserialnumber", "=", true);
                result.uuid = util.getValue(lines, "ioplatformuuid", "=", true).toLowerCase();
                result.sku = util.getValue(lines, "board-id", "=", true) || util.getValue(lines, "target-sub-type", "=", true);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              util.powerShell("Get-CimInstance Win32_ComputerSystemProduct | select Name,Vendor,Version,IdentifyingNumber,UUID | fl").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.split("\r\n");
                  result.manufacturer = util.getValue(lines, "vendor", ":");
                  result.model = util.getValue(lines, "name", ":");
                  result.version = util.getValue(lines, "version", ":");
                  result.serial = util.getValue(lines, "identifyingnumber", ":");
                  result.uuid = util.getValue(lines, "uuid", ":").toLowerCase();
                  const model = result.model.toLowerCase();
                  if (model === "virtualbox" || model === "kvm" || model === "virtual machine" || model === "bochs" || model.startsWith("vmware") || model.startsWith("qemu") || model.startsWith("parallels")) {
                    result.virtual = true;
                    if (model.startsWith("virtualbox")) {
                      result.virtualHost = "VirtualBox";
                    }
                    if (model.startsWith("vmware")) {
                      result.virtualHost = "VMware";
                    }
                    if (model.startsWith("kvm")) {
                      result.virtualHost = "KVM";
                    }
                    if (model.startsWith("bochs")) {
                      result.virtualHost = "bochs";
                    }
                    if (model.startsWith("qemu")) {
                      result.virtualHost = "KVM";
                    }
                    if (model.startsWith("parallels")) {
                      result.virtualHost = "Parallels";
                    }
                  }
                  const manufacturer = result.manufacturer.toLowerCase();
                  if (manufacturer.startsWith("vmware") || manufacturer.startsWith("qemu") || manufacturer === "xen" || manufacturer.startsWith("parallels")) {
                    result.virtual = true;
                    if (manufacturer.startsWith("vmware")) {
                      result.virtualHost = "VMware";
                    }
                    if (manufacturer.startsWith("xen")) {
                      result.virtualHost = "Xen";
                    }
                    if (manufacturer.startsWith("qemu")) {
                      result.virtualHost = "KVM";
                    }
                    if (manufacturer.startsWith("parallels")) {
                      result.virtualHost = "Parallels";
                    }
                  }
                  util.powerShell('Get-CimInstance MS_Systeminformation -Namespace "root/wmi" | select systemsku | fl ').then((stdout2, error2) => {
                    if (!error2) {
                      let lines2 = stdout2.split("\r\n");
                      result.sku = util.getValue(lines2, "systemsku", ":");
                    }
                    if (!result.virtual) {
                      util.powerShell("Get-CimInstance Win32_bios | select Version, SerialNumber, SMBIOSBIOSVersion").then((stdout3, error3) => {
                        if (!error3) {
                          let lines2 = stdout3.toString();
                          if (lines2.indexOf("VRTUAL") >= 0 || lines2.indexOf("A M I ") >= 0 || lines2.indexOf("VirtualBox") >= 0 || lines2.indexOf("VMWare") >= 0 || lines2.indexOf("Xen") >= 0 || lines2.indexOf("Parallels") >= 0) {
                            result.virtual = true;
                            if (lines2.indexOf("VirtualBox") >= 0 && !result.virtualHost) {
                              result.virtualHost = "VirtualBox";
                            }
                            if (lines2.indexOf("VMware") >= 0 && !result.virtualHost) {
                              result.virtualHost = "VMware";
                            }
                            if (lines2.indexOf("Xen") >= 0 && !result.virtualHost) {
                              result.virtualHost = "Xen";
                            }
                            if (lines2.indexOf("VRTUAL") >= 0 && !result.virtualHost) {
                              result.virtualHost = "Hyper-V";
                            }
                            if (lines2.indexOf("A M I") >= 0 && !result.virtualHost) {
                              result.virtualHost = "Virtual PC";
                            }
                            if (lines2.indexOf("Parallels") >= 0 && !result.virtualHost) {
                              result.virtualHost = "Parallels";
                            }
                          }
                          if (callback) {
                            callback(result);
                          }
                          resolve(result);
                        } else {
                          if (callback) {
                            callback(result);
                          }
                          resolve(result);
                        }
                      });
                    } else {
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    }
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.system = system;
    function cleanDefaults(s) {
      const cmpStr = s.toLowerCase();
      if (cmpStr.indexOf("o.e.m.") === -1 && cmpStr.indexOf("default string") === -1 && cmpStr !== "default") {
        return s || "";
      }
      return "";
    }
    function bios(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            vendor: "",
            version: "",
            releaseDate: "",
            revision: ""
          };
          let cmd = "";
          if (_linux || _freebsd || _openbsd || _netbsd) {
            if (process.arch === "arm") {
              cmd = "cat /proc/cpuinfo | grep Serial";
            } else {
              cmd = "export LC_ALL=C; dmidecode -t bios 2>/dev/null; unset LC_ALL";
            }
            exec2(cmd, function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result.vendor = util.getValue(lines, "Vendor");
              result.version = util.getValue(lines, "Version");
              let datetime = util.getValue(lines, "Release Date");
              result.releaseDate = util.parseDateTime(datetime).date;
              result.revision = util.getValue(lines, "BIOS Revision");
              result.serial = util.getValue(lines, "SerialNumber");
              let language = util.getValue(lines, "Currently Installed Language").split("|")[0];
              if (language) {
                result.language = language;
              }
              if (lines.length && stdout.toString().indexOf("Characteristics:") >= 0) {
                const features = [];
                lines.forEach((line) => {
                  if (line.indexOf(" is supported") >= 0) {
                    const feature = line.split(" is supported")[0].trim();
                    features.push(feature);
                  }
                });
                result.features = features;
              }
              const cmd2 = `echo -n "bios_date: "; cat /sys/devices/virtual/dmi/id/bios_date 2>/dev/null; echo;
            echo -n "bios_vendor: "; cat /sys/devices/virtual/dmi/id/bios_vendor 2>/dev/null; echo;
            echo -n "bios_version: "; cat /sys/devices/virtual/dmi/id/bios_version 2>/dev/null; echo;`;
              try {
                lines = execSync(cmd2, util.execOptsLinux).toString().split("\n");
                result.vendor = !result.vendor ? util.getValue(lines, "bios_vendor") : result.vendor;
                result.version = !result.version ? util.getValue(lines, "bios_version") : result.version;
                datetime = util.getValue(lines, "bios_date");
                result.releaseDate = !result.releaseDate ? util.parseDateTime(datetime).date : result.releaseDate;
              } catch (e) {
                util.noop();
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            result.vendor = "Apple Inc.";
            exec2(
              "system_profiler SPHardwareDataType -json",
              function(error, stdout) {
                try {
                  const hardwareData = JSON.parse(stdout.toString());
                  if (hardwareData && hardwareData.SPHardwareDataType && hardwareData.SPHardwareDataType.length) {
                    let bootRomVersion = hardwareData.SPHardwareDataType[0].boot_rom_version;
                    bootRomVersion = bootRomVersion ? bootRomVersion.split("(")[0].trim() : null;
                    result.version = bootRomVersion;
                  }
                } catch (e) {
                  util.noop();
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            );
          }
          if (_sunos) {
            result.vendor = "Sun Microsystems";
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              util.powerShell('Get-CimInstance Win32_bios | select Description,Version,Manufacturer,@{n="ReleaseDate";e={$_.ReleaseDate.ToString("yyyy-MM-dd")}},BuildNumber,SerialNumber,SMBIOSBIOSVersion | fl').then((stdout, error) => {
                if (!error) {
                  let lines = stdout.toString().split("\r\n");
                  const description = util.getValue(lines, "description", ":");
                  const version = util.getValue(lines, "SMBIOSBIOSVersion", ":");
                  if (description.indexOf(" Version ") !== -1) {
                    result.vendor = description.split(" Version ")[0].trim();
                    result.version = description.split(" Version ")[1].trim();
                  } else if (description.indexOf(" Ver: ") !== -1) {
                    result.vendor = util.getValue(lines, "manufacturer", ":");
                    result.version = description.split(" Ver: ")[1].trim();
                  } else {
                    result.vendor = util.getValue(lines, "manufacturer", ":");
                    result.version = version || util.getValue(lines, "version", ":");
                  }
                  result.releaseDate = util.getValue(lines, "releasedate", ":");
                  result.revision = util.getValue(lines, "buildnumber", ":");
                  result.serial = cleanDefaults(util.getValue(lines, "serialnumber", ":"));
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.bios = bios;
    function baseboard(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            manufacturer: "",
            model: "",
            version: "",
            serial: "-",
            assetTag: "-",
            memMax: null,
            memSlots: null
          };
          let cmd = "";
          if (_linux || _freebsd || _openbsd || _netbsd) {
            if (process.arch === "arm") {
              cmd = "cat /proc/cpuinfo | grep Serial";
            } else {
              cmd = "export LC_ALL=C; dmidecode -t 2 2>/dev/null; unset LC_ALL";
            }
            const workload = [];
            workload.push(execPromise(cmd));
            workload.push(execPromise("export LC_ALL=C; dmidecode -t memory 2>/dev/null"));
            util.promiseAll(
              workload
            ).then((data) => {
              let lines = data.results[0] ? data.results[0].toString().split("\n") : [""];
              result.manufacturer = cleanDefaults(util.getValue(lines, "Manufacturer"));
              result.model = cleanDefaults(util.getValue(lines, "Product Name"));
              result.version = cleanDefaults(util.getValue(lines, "Version"));
              result.serial = cleanDefaults(util.getValue(lines, "Serial Number"));
              result.assetTag = cleanDefaults(util.getValue(lines, "Asset Tag"));
              const cmd2 = `echo -n "board_asset_tag: "; cat /sys/devices/virtual/dmi/id/board_asset_tag 2>/dev/null; echo;
            echo -n "board_name: "; cat /sys/devices/virtual/dmi/id/board_name 2>/dev/null; echo;
            echo -n "board_serial: "; cat /sys/devices/virtual/dmi/id/board_serial 2>/dev/null; echo;
            echo -n "board_vendor: "; cat /sys/devices/virtual/dmi/id/board_vendor 2>/dev/null; echo;
            echo -n "board_version: "; cat /sys/devices/virtual/dmi/id/board_version 2>/dev/null; echo;`;
              try {
                lines = execSync(cmd2, util.execOptsLinux).toString().split("\n");
                result.manufacturer = cleanDefaults(!result.manufacturer ? util.getValue(lines, "board_vendor") : result.manufacturer);
                result.model = cleanDefaults(!result.model ? util.getValue(lines, "board_name") : result.model);
                result.version = cleanDefaults(!result.version ? util.getValue(lines, "board_version") : result.version);
                result.serial = cleanDefaults(!result.serial ? util.getValue(lines, "board_serial") : result.serial);
                result.assetTag = cleanDefaults(!result.assetTag ? util.getValue(lines, "board_asset_tag") : result.assetTag);
              } catch (e) {
                util.noop();
              }
              lines = data.results[1] ? data.results[1].toString().split("\n") : [""];
              result.memMax = util.toInt(util.getValue(lines, "Maximum Capacity")) * 1024 * 1024 * 1024 || null;
              result.memSlots = util.toInt(util.getValue(lines, "Number Of Devices")) || null;
              let linesRpi = "";
              try {
                linesRpi = fs.readFileSync("/proc/cpuinfo").toString().split("\n");
              } catch (e) {
                util.noop();
              }
              if (linesRpi) {
                const hardware = util.getValue(linesRpi, "hardware");
                if (hardware.startsWith("BCM")) {
                  const rpi = util.decodePiCpuinfo(linesRpi);
                  result.manufacturer = rpi.manufacturer;
                  result.model = "Raspberry Pi";
                  result.serial = rpi.serial;
                  result.version = rpi.type + " - " + rpi.revision;
                  result.memMax = os2.totalmem();
                  result.memSlots = 0;
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            const workload = [];
            workload.push(execPromise("ioreg -c IOPlatformExpertDevice -d 2"));
            workload.push(execPromise("system_profiler SPMemoryDataType"));
            util.promiseAll(
              workload
            ).then((data) => {
              let lines = data.results[0] ? data.results[0].toString().replace(/[<>"]/g, "").split("\n") : [""];
              result.manufacturer = util.getValue(lines, "manufacturer", "=", true);
              result.model = util.getValue(lines, "model", "=", true);
              result.version = util.getValue(lines, "version", "=", true);
              result.serial = util.getValue(lines, "ioplatformserialnumber", "=", true);
              result.assetTag = util.getValue(lines, "board-id", "=", true);
              let devices = data.results[1] ? data.results[1].toString().split("        BANK ") : [""];
              if (devices.length === 1) {
                devices = data.results[1] ? data.results[1].toString().split("        DIMM") : [""];
              }
              devices.shift();
              result.memSlots = devices.length;
              if (os2.arch() === "arm64") {
                result.memSlots = 0;
                result.memMax = os2.totalmem();
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              const workload = [];
              const win10plus = parseInt(os2.release()) >= 10;
              const maxCapacityAttribute = win10plus ? "MaxCapacityEx" : "MaxCapacity";
              workload.push(util.powerShell("Get-CimInstance Win32_baseboard | select Model,Manufacturer,Product,Version,SerialNumber,PartNumber,SKU | fl"));
              workload.push(util.powerShell(`Get-CimInstance Win32_physicalmemoryarray | select ${maxCapacityAttribute}, MemoryDevices | fl`));
              util.promiseAll(
                workload
              ).then((data) => {
                let lines = data.results[0] ? data.results[0].toString().split("\r\n") : [""];
                result.manufacturer = cleanDefaults(util.getValue(lines, "manufacturer", ":"));
                result.model = cleanDefaults(util.getValue(lines, "model", ":"));
                if (!result.model) {
                  result.model = cleanDefaults(util.getValue(lines, "product", ":"));
                }
                result.version = cleanDefaults(util.getValue(lines, "version", ":"));
                result.serial = cleanDefaults(util.getValue(lines, "serialnumber", ":"));
                result.assetTag = cleanDefaults(util.getValue(lines, "partnumber", ":"));
                if (!result.assetTag) {
                  result.assetTag = cleanDefaults(util.getValue(lines, "sku", ":"));
                }
                lines = data.results[1] ? data.results[1].toString().split("\r\n") : [""];
                result.memMax = util.toInt(util.getValue(lines, maxCapacityAttribute, ":")) * (win10plus ? 1024 : 1) || null;
                result.memSlots = util.toInt(util.getValue(lines, "MemoryDevices", ":")) || null;
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.baseboard = baseboard;
    function macOsChassisType(model) {
      model = model.toLowerCase();
      if (model.startsWith("macbookair")) {
        return "Notebook";
      }
      if (model.startsWith("macbookpro")) {
        return "Laptop";
      }
      if (model.startsWith("macbook")) {
        return "Notebook";
      }
      if (model.startsWith("macmini")) {
        return "Desktop";
      }
      if (model.startsWith("imac")) {
        return "Desktop";
      }
      if (model.startsWith("macstudio")) {
        return "Desktop";
      }
      if (model.startsWith("macpro")) {
        return "Tower";
      }
      return "Other";
    }
    function chassis(callback) {
      const chassisTypes = [
        "Other",
        "Unknown",
        "Desktop",
        "Low Profile Desktop",
        "Pizza Box",
        "Mini Tower",
        "Tower",
        "Portable",
        "Laptop",
        "Notebook",
        "Hand Held",
        "Docking Station",
        "All in One",
        "Sub Notebook",
        "Space-Saving",
        "Lunch Box",
        "Main System Chassis",
        "Expansion Chassis",
        "SubChassis",
        "Bus Expansion Chassis",
        "Peripheral Chassis",
        "Storage Chassis",
        "Rack Mount Chassis",
        "Sealed-Case PC",
        "Multi-System Chassis",
        "Compact PCI",
        "Advanced TCA",
        "Blade",
        "Blade Enclosure",
        "Tablet",
        "Convertible",
        "Detachable",
        "IoT Gateway ",
        "Embedded PC",
        "Mini PC",
        "Stick PC"
      ];
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            manufacturer: "",
            model: "",
            type: "",
            version: "",
            serial: "-",
            assetTag: "-",
            sku: ""
          };
          if (_linux || _freebsd || _openbsd || _netbsd) {
            const cmd = `echo -n "chassis_asset_tag: "; cat /sys/devices/virtual/dmi/id/chassis_asset_tag 2>/dev/null; echo;
            echo -n "chassis_serial: "; cat /sys/devices/virtual/dmi/id/chassis_serial 2>/dev/null; echo;
            echo -n "chassis_type: "; cat /sys/devices/virtual/dmi/id/chassis_type 2>/dev/null; echo;
            echo -n "chassis_vendor: "; cat /sys/devices/virtual/dmi/id/chassis_vendor 2>/dev/null; echo;
            echo -n "chassis_version: "; cat /sys/devices/virtual/dmi/id/chassis_version 2>/dev/null; echo;`;
            exec2(cmd, function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result.manufacturer = cleanDefaults(util.getValue(lines, "chassis_vendor"));
              const ctype = parseInt(util.getValue(lines, "chassis_type").replace(/\D/g, ""));
              result.type = cleanDefaults(ctype && !isNaN(ctype) && ctype < chassisTypes.length ? chassisTypes[ctype - 1] : "");
              result.version = cleanDefaults(util.getValue(lines, "chassis_version"));
              result.serial = cleanDefaults(util.getValue(lines, "chassis_serial"));
              result.assetTag = cleanDefaults(util.getValue(lines, "chassis_asset_tag"));
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2("ioreg -c IOPlatformExpertDevice -d 2", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().replace(/[<>"]/g, "").split("\n");
                const model = util.getValue(lines, "model", "=", true);
                const modelParts = util.splitByNumber(model);
                const version = util.getValue(lines, "version", "=", true);
                result.manufacturer = util.getValue(lines, "manufacturer", "=", true);
                result.model = version ? util.getValue(lines, "model", "=", true) : modelParts[0];
                result.type = macOsChassisType(result.model);
                result.version = version || model;
                result.serial = util.getValue(lines, "ioplatformserialnumber", "=", true);
                result.assetTag = util.getValue(lines, "board-id", "=", true) || util.getValue(lines, "target-type", "=", true);
                result.sku = util.getValue(lines, "target-sub-type", "=", true);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              util.powerShell("Get-CimInstance Win32_SystemEnclosure | select Model,Manufacturer,ChassisTypes,Version,SerialNumber,PartNumber,SKU,SMBIOSAssetTag | fl").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.toString().split("\r\n");
                  result.manufacturer = cleanDefaults(util.getValue(lines, "manufacturer", ":"));
                  result.model = cleanDefaults(util.getValue(lines, "model", ":"));
                  const ctype = parseInt(util.getValue(lines, "ChassisTypes", ":").replace(/\D/g, ""));
                  result.type = ctype && !isNaN(ctype) && ctype < chassisTypes.length ? chassisTypes[ctype - 1] : "";
                  result.version = cleanDefaults(util.getValue(lines, "version", ":"));
                  result.serial = cleanDefaults(util.getValue(lines, "serialnumber", ":"));
                  result.assetTag = cleanDefaults(util.getValue(lines, "partnumber", ":"));
                  if (!result.assetTag) {
                    result.assetTag = cleanDefaults(util.getValue(lines, "SMBIOSAssetTag", ":"));
                  }
                  result.sku = cleanDefaults(util.getValue(lines, "sku", ":"));
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.chassis = chassis;
  }
});

// node_modules/systeminformation/lib/osinfo.js
var require_osinfo = __commonJS({
  "node_modules/systeminformation/lib/osinfo.js"(exports) {
    "use strict";
    var os2 = require("os");
    var fs = require("fs");
    var util = require_util2();
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function time() {
      let t = new Date().toString().split(" ");
      return {
        current: Date.now(),
        uptime: os2.uptime(),
        timezone: t.length >= 7 ? t[5] : "",
        timezoneName: Intl ? Intl.DateTimeFormat().resolvedOptions().timeZone : t.length >= 7 ? t.slice(6).join(" ").replace(/\(/g, "").replace(/\)/g, "") : ""
      };
    }
    exports.time = time;
    function getLogoFile(distro) {
      distro = distro || "";
      distro = distro.toLowerCase();
      let result = _platform;
      if (_windows) {
        result = "windows";
      } else if (distro.indexOf("mac os") !== -1) {
        result = "apple";
      } else if (distro.indexOf("arch") !== -1) {
        result = "arch";
      } else if (distro.indexOf("centos") !== -1) {
        result = "centos";
      } else if (distro.indexOf("coreos") !== -1) {
        result = "coreos";
      } else if (distro.indexOf("debian") !== -1) {
        result = "debian";
      } else if (distro.indexOf("deepin") !== -1) {
        result = "deepin";
      } else if (distro.indexOf("elementary") !== -1) {
        result = "elementary";
      } else if (distro.indexOf("fedora") !== -1) {
        result = "fedora";
      } else if (distro.indexOf("gentoo") !== -1) {
        result = "gentoo";
      } else if (distro.indexOf("mageia") !== -1) {
        result = "mageia";
      } else if (distro.indexOf("mandriva") !== -1) {
        result = "mandriva";
      } else if (distro.indexOf("manjaro") !== -1) {
        result = "manjaro";
      } else if (distro.indexOf("mint") !== -1) {
        result = "mint";
      } else if (distro.indexOf("mx") !== -1) {
        result = "mx";
      } else if (distro.indexOf("openbsd") !== -1) {
        result = "openbsd";
      } else if (distro.indexOf("freebsd") !== -1) {
        result = "freebsd";
      } else if (distro.indexOf("opensuse") !== -1) {
        result = "opensuse";
      } else if (distro.indexOf("pclinuxos") !== -1) {
        result = "pclinuxos";
      } else if (distro.indexOf("puppy") !== -1) {
        result = "puppy";
      } else if (distro.indexOf("raspbian") !== -1) {
        result = "raspbian";
      } else if (distro.indexOf("reactos") !== -1) {
        result = "reactos";
      } else if (distro.indexOf("redhat") !== -1) {
        result = "redhat";
      } else if (distro.indexOf("slackware") !== -1) {
        result = "slackware";
      } else if (distro.indexOf("sugar") !== -1) {
        result = "sugar";
      } else if (distro.indexOf("steam") !== -1) {
        result = "steam";
      } else if (distro.indexOf("suse") !== -1) {
        result = "suse";
      } else if (distro.indexOf("mate") !== -1) {
        result = "ubuntu-mate";
      } else if (distro.indexOf("lubuntu") !== -1) {
        result = "lubuntu";
      } else if (distro.indexOf("xubuntu") !== -1) {
        result = "xubuntu";
      } else if (distro.indexOf("ubuntu") !== -1) {
        result = "ubuntu";
      } else if (distro.indexOf("solaris") !== -1) {
        result = "solaris";
      } else if (distro.indexOf("tails") !== -1) {
        result = "tails";
      } else if (distro.indexOf("feren") !== -1) {
        result = "ferenos";
      } else if (distro.indexOf("robolinux") !== -1) {
        result = "robolinux";
      } else if (_linux && distro) {
        result = distro.toLowerCase().trim().replace(/\s+/g, "-");
      }
      return result;
    }
    function getFQDN() {
      let fqdn = os2.hostname;
      if (_linux || _darwin) {
        try {
          const stdout = execSync("hostnamectl --json short 2>/dev/null", util.execOptsLinux);
          const json = JSON.parse(stdout.toString());
          fqdn = json["StaticHostname"];
        } catch (e) {
          try {
            const stdout = execSync("hostname -f 2>/dev/null", util.execOptsLinux);
            fqdn = stdout.toString().split(os2.EOL)[0];
          } catch (e2) {
            util.noop();
          }
        }
      }
      if (_freebsd || _openbsd || _netbsd) {
        try {
          const stdout = execSync("hostname 2>/dev/null");
          fqdn = stdout.toString().split(os2.EOL)[0];
        } catch (e) {
          util.noop();
        }
      }
      if (_windows) {
        try {
          const stdout = execSync("echo %COMPUTERNAME%.%USERDNSDOMAIN%", util.execOptsWin);
          fqdn = stdout.toString().replace(".%USERDNSDOMAIN%", "").split(os2.EOL)[0];
        } catch (e) {
          util.noop();
        }
      }
      return fqdn;
    }
    function osInfo(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            platform: _platform === "win32" ? "Windows" : _platform,
            distro: "unknown",
            release: "unknown",
            codename: "",
            kernel: os2.release(),
            arch: os2.arch(),
            hostname: os2.hostname(),
            fqdn: getFQDN(),
            codepage: "",
            logofile: "",
            serial: "",
            build: "",
            servicepack: "",
            uefi: false
          };
          if (_linux) {
            exec2("cat /etc/*-release; cat /usr/lib/os-release; cat /etc/openwrt_release", function(error, stdout) {
              let release = {};
              let lines = stdout.toString().split("\n");
              lines.forEach(function(line) {
                if (line.indexOf("=") !== -1) {
                  release[line.split("=")[0].trim().toUpperCase()] = line.split("=")[1].trim();
                }
              });
              result.distro = (release.DISTRIB_ID || release.NAME || "unknown").replace(/"/g, "");
              result.logofile = getLogoFile(result.distro);
              let releaseVersion = (release.VERSION || "").replace(/"/g, "");
              let codename = (release.DISTRIB_CODENAME || release.VERSION_CODENAME || "").replace(/"/g, "");
              const prettyName = (release.PRETTY_NAME || "").replace(/"/g, "");
              if (prettyName.indexOf(result.distro + " ") === 0) {
                releaseVersion = prettyName.replace(result.distro + " ", "").trim();
              }
              if (releaseVersion.indexOf("(") >= 0) {
                codename = releaseVersion.split("(")[1].replace(/[()]/g, "").trim();
                releaseVersion = releaseVersion.split("(")[0].trim();
              }
              result.release = (releaseVersion || release.DISTRIB_RELEASE || release.VERSION_ID || "unknown").replace(/"/g, "");
              result.codename = codename;
              result.codepage = util.getCodepage();
              result.build = (release.BUILD_ID || "").replace(/"/g, "").trim();
              isUefiLinux().then((uefi) => {
                result.uefi = uefi;
                uuid().then((data) => {
                  result.serial = data.os;
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              });
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2("sysctl kern.ostype kern.osrelease kern.osrevision kern.hostuuid machdep.bootmethod kern.geom.confxml", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              const distro = util.getValue(lines, "kern.ostype");
              const logofile = getLogoFile(distro);
              const release = util.getValue(lines, "kern.osrelease").split("-")[0];
              const serial = util.getValue(lines, "kern.uuid");
              const bootmethod = util.getValue(lines, "machdep.bootmethod");
              const uefiConf = stdout.toString().indexOf("<type>efi</type>") >= 0;
              const uefi = bootmethod ? bootmethod.toLowerCase().indexOf("uefi") >= 0 : uefiConf ? uefiConf : null;
              result.distro = distro || result.distro;
              result.logofile = logofile || result.logofile;
              result.release = release || result.release;
              result.serial = serial || result.serial;
              result.codename = "";
              result.codepage = util.getCodepage();
              result.uefi = uefi || null;
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2("sw_vers; sysctl kern.ostype kern.osrelease kern.osrevision kern.uuid", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result.serial = util.getValue(lines, "kern.uuid");
              result.distro = util.getValue(lines, "ProductName");
              result.release = (util.getValue(lines, "ProductVersion", ":", true, true) + " " + util.getValue(lines, "ProductVersionExtra", ":", true, true)).trim();
              result.build = util.getValue(lines, "BuildVersion");
              result.logofile = getLogoFile(result.distro);
              result.codename = "macOS";
              result.codename = result.release.indexOf("10.4") > -1 ? "Mac OS X Tiger" : result.codename;
              result.codename = result.release.indexOf("10.5") > -1 ? "Mac OS X Leopard" : result.codename;
              result.codename = result.release.indexOf("10.6") > -1 ? "Mac OS X Snow Leopard" : result.codename;
              result.codename = result.release.indexOf("10.7") > -1 ? "Mac OS X Lion" : result.codename;
              result.codename = result.release.indexOf("10.8") > -1 ? "OS X Mountain Lion" : result.codename;
              result.codename = result.release.indexOf("10.9") > -1 ? "OS X Mavericks" : result.codename;
              result.codename = result.release.indexOf("10.10") > -1 ? "OS X Yosemite" : result.codename;
              result.codename = result.release.indexOf("10.11") > -1 ? "OS X El Capitan" : result.codename;
              result.codename = result.release.indexOf("10.12") > -1 ? "macOS Sierra" : result.codename;
              result.codename = result.release.indexOf("10.13") > -1 ? "macOS High Sierra" : result.codename;
              result.codename = result.release.indexOf("10.14") > -1 ? "macOS Mojave" : result.codename;
              result.codename = result.release.indexOf("10.15") > -1 ? "macOS Catalina" : result.codename;
              result.codename = result.release.startsWith("11.") ? "macOS Big Sur" : result.codename;
              result.codename = result.release.startsWith("12.") ? "macOS Monterey" : result.codename;
              result.codename = result.release.startsWith("13.") ? "macOS Ventura" : result.codename;
              result.codename = result.release.startsWith("14.") ? "macOS Sonoma" : result.codename;
              result.codename = result.release.startsWith("15.") ? "macOS Sequoia" : result.codename;
              result.uefi = true;
              result.codepage = util.getCodepage();
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            result.release = result.kernel;
            exec2("uname -o", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result.distro = lines[0];
              result.logofile = getLogoFile(result.distro);
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_windows) {
            result.logofile = getLogoFile();
            result.release = result.kernel;
            try {
              const workload = [];
              workload.push(util.powerShell("Get-CimInstance Win32_OperatingSystem | select Caption,SerialNumber,BuildNumber,ServicePackMajorVersion,ServicePackMinorVersion | fl"));
              workload.push(util.powerShell("(Get-CimInstance Win32_ComputerSystem).HypervisorPresent"));
              workload.push(util.powerShell("Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.SystemInformation]::TerminalServerSession"));
              util.promiseAll(
                workload
              ).then((data) => {
                let lines = data.results[0] ? data.results[0].toString().split("\r\n") : [""];
                result.distro = util.getValue(lines, "Caption", ":").trim();
                result.serial = util.getValue(lines, "SerialNumber", ":").trim();
                result.build = util.getValue(lines, "BuildNumber", ":").trim();
                result.servicepack = util.getValue(lines, "ServicePackMajorVersion", ":").trim() + "." + util.getValue(lines, "ServicePackMinorVersion", ":").trim();
                result.codepage = util.getCodepage();
                const hyperv = data.results[1] ? data.results[1].toString().toLowerCase() : "";
                result.hypervisor = hyperv.indexOf("true") !== -1;
                const term = data.results[2] ? data.results[2].toString() : "";
                result.remoteSession = term.toString().toLowerCase().indexOf("true") >= 0;
                isUefiWindows().then((uefi) => {
                  result.uefi = uefi;
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.osInfo = osInfo;
    function isUefiLinux() {
      return new Promise((resolve) => {
        process.nextTick(() => {
          fs.stat("/sys/firmware/efi", function(err) {
            if (!err) {
              return resolve(true);
            } else {
              exec2('dmesg | grep -E "EFI v"', function(error, stdout) {
                if (!error) {
                  const lines = stdout.toString().split("\n");
                  return resolve(lines.length > 0);
                }
                return resolve(false);
              });
            }
          });
        });
      });
    }
    function isUefiWindows() {
      return new Promise((resolve) => {
        process.nextTick(() => {
          try {
            exec2('findstr /C:"Detected boot environment" "%windir%\\Panther\\setupact.log"', util.execOptsWin, function(error, stdout) {
              if (!error) {
                const line = stdout.toString().split("\n\r")[0];
                return resolve(line.toLowerCase().indexOf("efi") >= 0);
              } else {
                exec2("echo %firmware_type%", util.execOptsWin, function(error2, stdout2) {
                  if (!error2) {
                    const line = stdout2.toString() || "";
                    return resolve(line.toLowerCase().indexOf("efi") >= 0);
                  } else {
                    return resolve(false);
                  }
                });
              }
            });
          } catch (e) {
            return resolve(false);
          }
        });
      });
    }
    function versions(apps, callback) {
      let versionObject = {
        kernel: os2.release(),
        openssl: "",
        systemOpenssl: "",
        systemOpensslLib: "",
        node: process.versions.node,
        v8: process.versions.v8,
        npm: "",
        yarn: "",
        pm2: "",
        gulp: "",
        grunt: "",
        git: "",
        tsc: "",
        mysql: "",
        redis: "",
        mongodb: "",
        apache: "",
        nginx: "",
        php: "",
        docker: "",
        postfix: "",
        postgresql: "",
        perl: "",
        python: "",
        python3: "",
        pip: "",
        pip3: "",
        java: "",
        gcc: "",
        virtualbox: "",
        bash: "",
        zsh: "",
        fish: "",
        powershell: "",
        dotnet: ""
      };
      function checkVersionParam(apps2) {
        if (apps2 === "*") {
          return {
            versions: versionObject,
            counter: 30
          };
        }
        if (!Array.isArray(apps2)) {
          apps2 = apps2.trim().toLowerCase().replace(/,+/g, "|").replace(/ /g, "|");
          apps2 = apps2.split("|");
          const result = {
            versions: {},
            counter: 0
          };
          apps2.forEach((el) => {
            if (el) {
              for (let key in versionObject) {
                if ({}.hasOwnProperty.call(versionObject, key)) {
                  if (key.toLowerCase() === el.toLowerCase() && !{}.hasOwnProperty.call(result.versions, key)) {
                    result.versions[key] = versionObject[key];
                    if (key === "openssl") {
                      result.versions.systemOpenssl = "";
                      result.versions.systemOpensslLib = "";
                    }
                    if (!result.versions[key]) {
                      result.counter++;
                    }
                  }
                }
              }
            }
          });
          return result;
        }
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (util.isFunction(apps) && !callback) {
            callback = apps;
            apps = "*";
          } else {
            apps = apps || "*";
            if (typeof apps !== "string") {
              if (callback) {
                callback({});
              }
              return resolve({});
            }
          }
          const appsObj = checkVersionParam(apps);
          let totalFunctions = appsObj.counter;
          let functionProcessed = function() {
            return function() {
              if (--totalFunctions === 0) {
                if (callback) {
                  callback(appsObj.versions);
                }
                resolve(appsObj.versions);
              }
            };
          }();
          let cmd = "";
          try {
            if ({}.hasOwnProperty.call(appsObj.versions, "openssl")) {
              appsObj.versions.openssl = process.versions.openssl;
              exec2("openssl version", function(error, stdout) {
                if (!error) {
                  let openssl_string = stdout.toString().split("\n")[0].trim();
                  let openssl = openssl_string.split(" ");
                  appsObj.versions.systemOpenssl = openssl.length > 0 ? openssl[1] : openssl[0];
                  appsObj.versions.systemOpensslLib = openssl.length > 0 ? openssl[0] : "openssl";
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "npm")) {
              exec2("npm -v", function(error, stdout) {
                if (!error) {
                  appsObj.versions.npm = stdout.toString().split("\n")[0];
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "pm2")) {
              cmd = "pm2";
              if (_windows) {
                cmd += ".cmd";
              }
              exec2(`${cmd} -v`, function(error, stdout) {
                if (!error) {
                  let pm2 = stdout.toString().split("\n")[0].trim();
                  if (!pm2.startsWith("[PM2]")) {
                    appsObj.versions.pm2 = pm2;
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "yarn")) {
              exec2("yarn --version", function(error, stdout) {
                if (!error) {
                  appsObj.versions.yarn = stdout.toString().split("\n")[0];
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "gulp")) {
              cmd = "gulp";
              if (_windows) {
                cmd += ".cmd";
              }
              exec2(`${cmd} --version`, function(error, stdout) {
                if (!error) {
                  const gulp = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.gulp = (gulp.toLowerCase().split("version")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "tsc")) {
              cmd = "tsc";
              if (_windows) {
                cmd += ".cmd";
              }
              exec2(`${cmd} --version`, function(error, stdout) {
                if (!error) {
                  const tsc = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.tsc = (tsc.toLowerCase().split("version")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "grunt")) {
              cmd = "grunt";
              if (_windows) {
                cmd += ".cmd";
              }
              exec2(`${cmd} --version`, function(error, stdout) {
                if (!error) {
                  const grunt = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.grunt = (grunt.toLowerCase().split("cli v")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "git")) {
              if (_darwin) {
                const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/git") || fs.existsSync("/opt/homebrew/bin/git");
                if (util.darwinXcodeExists() || gitHomebrewExists) {
                  exec2("git --version", function(error, stdout) {
                    if (!error) {
                      let git = stdout.toString().split("\n")[0] || "";
                      git = (git.toLowerCase().split("version")[1] || "").trim();
                      appsObj.versions.git = (git.split(" ")[0] || "").trim();
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              } else {
                exec2("git --version", function(error, stdout) {
                  if (!error) {
                    let git = stdout.toString().split("\n")[0] || "";
                    git = (git.toLowerCase().split("version")[1] || "").trim();
                    appsObj.versions.git = (git.split(" ")[0] || "").trim();
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "apache")) {
              exec2("apachectl -v 2>&1", function(error, stdout) {
                if (!error) {
                  const apache = (stdout.toString().split("\n")[0] || "").split(":");
                  appsObj.versions.apache = apache.length > 1 ? apache[1].replace("Apache", "").replace("/", "").split("(")[0].trim() : "";
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "nginx")) {
              exec2("nginx -v 2>&1", function(error, stdout) {
                if (!error) {
                  const nginx = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.nginx = (nginx.toLowerCase().split("/")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "mysql")) {
              exec2("mysql -V", function(error, stdout) {
                if (!error) {
                  let mysql = stdout.toString().split("\n")[0] || "";
                  mysql = mysql.toLowerCase();
                  if (mysql.indexOf(",") > -1) {
                    mysql = (mysql.split(",")[0] || "").trim();
                    const parts = mysql.split(" ");
                    appsObj.versions.mysql = (parts[parts.length - 1] || "").trim();
                  } else {
                    if (mysql.indexOf(" ver ") > -1) {
                      mysql = mysql.split(" ver ")[1];
                      appsObj.versions.mysql = mysql.split(" ")[0];
                    }
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "php")) {
              exec2("php -v", function(error, stdout) {
                if (!error) {
                  const php = stdout.toString().split("\n")[0] || "";
                  let parts = php.split("(");
                  if (parts[0].indexOf("-")) {
                    parts = parts[0].split("-");
                  }
                  appsObj.versions.php = parts[0].replace(/[^0-9.]/g, "");
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "redis")) {
              exec2("redis-server --version", function(error, stdout) {
                if (!error) {
                  const redis = stdout.toString().split("\n")[0] || "";
                  const parts = redis.split(" ");
                  appsObj.versions.redis = util.getValue(parts, "v", "=", true);
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "docker")) {
              exec2("docker --version", function(error, stdout) {
                if (!error) {
                  const docker = stdout.toString().split("\n")[0] || "";
                  const parts = docker.split(" ");
                  appsObj.versions.docker = parts.length > 2 && parts[2].endsWith(",") ? parts[2].slice(0, -1) : "";
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "postfix")) {
              exec2("postconf -d | grep mail_version", function(error, stdout) {
                if (!error) {
                  const postfix = stdout.toString().split("\n") || [];
                  appsObj.versions.postfix = util.getValue(postfix, "mail_version", "=", true);
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "mongodb")) {
              exec2("mongod --version", function(error, stdout) {
                if (!error) {
                  const mongodb = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.mongodb = (mongodb.toLowerCase().split(",")[0] || "").replace(/[^0-9.]/g, "");
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "postgresql")) {
              if (_linux) {
                exec2("locate bin/postgres", function(error, stdout) {
                  if (!error) {
                    const postgresqlBin = stdout.toString().split("\n").sort();
                    if (postgresqlBin.length) {
                      exec2(postgresqlBin[postgresqlBin.length - 1] + " -V", function(error2, stdout2) {
                        if (!error2) {
                          const postgresql = stdout2.toString().split("\n")[0].split(" ") || [];
                          appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                        }
                        functionProcessed();
                      });
                    } else {
                      functionProcessed();
                    }
                  } else {
                    exec2("psql -V", function(error2, stdout2) {
                      if (!error2) {
                        const postgresql = stdout2.toString().split("\n")[0].split(" ") || [];
                        appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                        appsObj.versions.postgresql = appsObj.versions.postgresql.split("-")[0];
                      }
                      functionProcessed();
                    });
                  }
                });
              } else {
                if (_windows) {
                  util.powerShell("Get-CimInstance Win32_Service | select caption | fl").then((stdout) => {
                    let serviceSections = stdout.split(/\n\s*\n/);
                    serviceSections.forEach((item) => {
                      if (item.trim() !== "") {
                        let lines = item.trim().split("\r\n");
                        let srvCaption = util.getValue(lines, "caption", ":", true).toLowerCase();
                        if (srvCaption.indexOf("postgresql") > -1) {
                          const parts = srvCaption.split(" server ");
                          if (parts.length > 1) {
                            appsObj.versions.postgresql = parts[1];
                          }
                        }
                      }
                    });
                    functionProcessed();
                  });
                } else {
                  exec2("postgres -V", function(error, stdout) {
                    if (!error) {
                      const postgresql = stdout.toString().split("\n")[0].split(" ") || [];
                      appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                    }
                    functionProcessed();
                  });
                }
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "perl")) {
              exec2("perl -v", function(error, stdout) {
                if (!error) {
                  const perl = stdout.toString().split("\n") || "";
                  while (perl.length > 0 && perl[0].trim() === "") {
                    perl.shift();
                  }
                  if (perl.length > 0) {
                    appsObj.versions.perl = perl[0].split("(").pop().split(")")[0].replace("v", "");
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "python")) {
              if (_darwin) {
                try {
                  const stdout = execSync("sw_vers");
                  const lines = stdout.toString().split("\n");
                  const osVersion = util.getValue(lines, "ProductVersion", ":");
                  const gitHomebrewExists1 = fs.existsSync("/usr/local/Cellar/python");
                  const gitHomebrewExists2 = fs.existsSync("/opt/homebrew/bin/python");
                  if (util.darwinXcodeExists() && util.semverCompare("12.0.1", osVersion) < 0 || gitHomebrewExists1 || gitHomebrewExists2) {
                    const cmd2 = gitHomebrewExists1 ? "/usr/local/Cellar/python -V 2>&1" : gitHomebrewExists2 ? "/opt/homebrew/bin/python -V 2>&1" : "python -V 2>&1";
                    exec2(cmd2, function(error, stdout2) {
                      if (!error) {
                        const python = stdout2.toString().split("\n")[0] || "";
                        appsObj.versions.python = python.toLowerCase().replace("python", "").trim();
                      }
                      functionProcessed();
                    });
                  } else {
                    functionProcessed();
                  }
                } catch (e) {
                  functionProcessed();
                }
              } else {
                exec2("python -V 2>&1", function(error, stdout) {
                  if (!error) {
                    const python = stdout.toString().split("\n")[0] || "";
                    appsObj.versions.python = python.toLowerCase().replace("python", "").trim();
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "python3")) {
              if (_darwin) {
                const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/python3") || fs.existsSync("/opt/homebrew/bin/python3");
                if (util.darwinXcodeExists() || gitHomebrewExists) {
                  exec2("python3 -V 2>&1", function(error, stdout) {
                    if (!error) {
                      const python = stdout.toString().split("\n")[0] || "";
                      appsObj.versions.python3 = python.toLowerCase().replace("python", "").trim();
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              } else {
                exec2("python3 -V 2>&1", function(error, stdout) {
                  if (!error) {
                    const python = stdout.toString().split("\n")[0] || "";
                    appsObj.versions.python3 = python.toLowerCase().replace("python", "").trim();
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "pip")) {
              if (_darwin) {
                const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/pip") || fs.existsSync("/opt/homebrew/bin/pip");
                if (util.darwinXcodeExists() || gitHomebrewExists) {
                  exec2("pip -V 2>&1", function(error, stdout) {
                    if (!error) {
                      const pip = stdout.toString().split("\n")[0] || "";
                      const parts = pip.split(" ");
                      appsObj.versions.pip = parts.length >= 2 ? parts[1] : "";
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              } else {
                exec2("pip -V 2>&1", function(error, stdout) {
                  if (!error) {
                    const pip = stdout.toString().split("\n")[0] || "";
                    const parts = pip.split(" ");
                    appsObj.versions.pip = parts.length >= 2 ? parts[1] : "";
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "pip3")) {
              if (_darwin) {
                const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/pip3") || fs.existsSync("/opt/homebrew/bin/pip3");
                if (util.darwinXcodeExists() || gitHomebrewExists) {
                  exec2("pip3 -V 2>&1", function(error, stdout) {
                    if (!error) {
                      const pip = stdout.toString().split("\n")[0] || "";
                      const parts = pip.split(" ");
                      appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : "";
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              } else {
                exec2("pip3 -V 2>&1", function(error, stdout) {
                  if (!error) {
                    const pip = stdout.toString().split("\n")[0] || "";
                    const parts = pip.split(" ");
                    appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : "";
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "java")) {
              if (_darwin) {
                exec2("/usr/libexec/java_home -V 2>&1", function(error, stdout) {
                  if (!error && stdout.toString().toLowerCase().indexOf("no java runtime") === -1) {
                    exec2("java -version 2>&1", function(error2, stdout2) {
                      if (!error2) {
                        const java = stdout2.toString().split("\n")[0] || "";
                        const parts = java.split('"');
                        appsObj.versions.java = parts.length === 3 ? parts[1].trim() : "";
                      }
                      functionProcessed();
                    });
                  } else {
                    functionProcessed();
                  }
                });
              } else {
                exec2("java -version 2>&1", function(error, stdout) {
                  if (!error) {
                    const java = stdout.toString().split("\n")[0] || "";
                    const parts = java.split('"');
                    appsObj.versions.java = parts.length === 3 ? parts[1].trim() : "";
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "gcc")) {
              if (_darwin && util.darwinXcodeExists() || !_darwin) {
                exec2("gcc -dumpversion", function(error, stdout) {
                  if (!error) {
                    appsObj.versions.gcc = stdout.toString().split("\n")[0].trim() || "";
                  }
                  if (appsObj.versions.gcc.indexOf(".") > -1) {
                    functionProcessed();
                  } else {
                    exec2("gcc --version", function(error2, stdout2) {
                      if (!error2) {
                        const gcc = stdout2.toString().split("\n")[0].trim();
                        if (gcc.indexOf("gcc") > -1 && gcc.indexOf(")") > -1) {
                          const parts = gcc.split(")");
                          appsObj.versions.gcc = parts[1].trim() || appsObj.versions.gcc;
                        }
                      }
                      functionProcessed();
                    });
                  }
                });
              } else {
                functionProcessed();
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "virtualbox")) {
              exec2(util.getVboxmanage() + " -v 2>&1", function(error, stdout) {
                if (!error) {
                  const vbox = stdout.toString().split("\n")[0] || "";
                  const parts = vbox.split("r");
                  appsObj.versions.virtualbox = parts[0];
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "bash")) {
              exec2("bash --version", function(error, stdout) {
                if (!error) {
                  const line = stdout.toString().split("\n")[0];
                  const parts = line.split(" version ");
                  if (parts.length > 1) {
                    appsObj.versions.bash = parts[1].split(" ")[0].split("(")[0];
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "zsh")) {
              exec2("zsh --version", function(error, stdout) {
                if (!error) {
                  const line = stdout.toString().split("\n")[0];
                  const parts = line.split("zsh ");
                  if (parts.length > 1) {
                    appsObj.versions.zsh = parts[1].split(" ")[0];
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "fish")) {
              exec2("fish --version", function(error, stdout) {
                if (!error) {
                  const line = stdout.toString().split("\n")[0];
                  const parts = line.split(" version ");
                  if (parts.length > 1) {
                    appsObj.versions.fish = parts[1].split(" ")[0];
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "powershell")) {
              if (_windows) {
                util.powerShell("$PSVersionTable").then((stdout) => {
                  const lines = stdout.toString().split("\n").map((line) => line.replace(/ +/g, " ").replace(/ +/g, ":"));
                  appsObj.versions.powershell = util.getValue(lines, "psversion");
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "dotnet")) {
              if (_windows) {
                util.powerShell('gci "HKLM:\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP" -recurse | gp -name Version,Release -EA 0 | where { $_.PSChildName -match "^(?!S)\\p{L}"} | select PSChildName, Version, Release').then((stdout) => {
                  const lines = stdout.toString().split("\r\n");
                  let dotnet = "";
                  lines.forEach((line) => {
                    line = line.replace(/ +/g, " ");
                    const parts = line.split(" ");
                    dotnet = dotnet || (parts[0].toLowerCase().startsWith("client") && parts.length > 2 ? parts[1].trim() : parts[0].toLowerCase().startsWith("full") && parts.length > 2 ? parts[1].trim() : "");
                  });
                  appsObj.versions.dotnet = dotnet.trim();
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            }
          } catch (e) {
            if (callback) {
              callback(appsObj.versions);
            }
            resolve(appsObj.versions);
          }
        });
      });
    }
    exports.versions = versions;
    function shell(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (_windows) {
            resolve("cmd");
          } else {
            let result = "";
            exec2("echo $SHELL", function(error, stdout) {
              if (!error) {
                result = stdout.toString().split("\n")[0];
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
        });
      });
    }
    exports.shell = shell;
    function getUniqueMacAdresses() {
      let macs = [];
      try {
        const ifaces = os2.networkInterfaces();
        for (let dev in ifaces) {
          if ({}.hasOwnProperty.call(ifaces, dev)) {
            ifaces[dev].forEach(function(details) {
              if (details && details.mac && details.mac !== "00:00:00:00:00:00") {
                const mac = details.mac.toLowerCase();
                if (macs.indexOf(mac) === -1) {
                  macs.push(mac);
                }
              }
            });
          }
        }
        macs = macs.sort(function(a, b) {
          if (a < b) {
            return -1;
          }
          if (a > b) {
            return 1;
          }
          return 0;
        });
      } catch (e) {
        macs.push("00:00:00:00:00:00");
      }
      return macs;
    }
    function uuid(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            os: "",
            hardware: "",
            macs: getUniqueMacAdresses()
          };
          let parts;
          if (_darwin) {
            exec2("system_profiler SPHardwareDataType -json", function(error, stdout) {
              if (!error) {
                try {
                  const jsonObj = JSON.parse(stdout.toString());
                  if (jsonObj.SPHardwareDataType && jsonObj.SPHardwareDataType.length > 0) {
                    const spHardware = jsonObj.SPHardwareDataType[0];
                    result.os = spHardware.platform_UUID.toLowerCase();
                    result.hardware = spHardware.serial_number;
                  }
                } catch (e) {
                  util.noop();
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_linux) {
            const cmd = `echo -n "os: "; cat /var/lib/dbus/machine-id 2> /dev/null ||
cat /etc/machine-id 2> /dev/null; echo;
echo -n "hardware: "; cat /sys/class/dmi/id/product_uuid 2> /dev/null; echo;`;
            exec2(cmd, function(error, stdout) {
              const lines = stdout.toString().split("\n");
              result.os = util.getValue(lines, "os").toLowerCase();
              result.hardware = util.getValue(lines, "hardware").toLowerCase();
              if (!result.hardware) {
                const lines2 = fs.readFileSync("/proc/cpuinfo", { encoding: "utf8" }).toString().split("\n");
                const serial = util.getValue(lines2, "serial");
                result.hardware = serial || "";
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2("sysctl -i kern.hostid kern.hostuuid", function(error, stdout) {
              const lines = stdout.toString().split("\n");
              result.os = util.getValue(lines, "kern.hostid", ":").toLowerCase();
              result.hardware = util.getValue(lines, "kern.hostuuid", ":").toLowerCase();
              if (result.os.indexOf("unknown") >= 0) {
                result.os = "";
              }
              if (result.hardware.indexOf("unknown") >= 0) {
                result.hardware = "";
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_windows) {
            let sysdir = "%windir%\\System32";
            if (process.arch === "ia32" && Object.prototype.hasOwnProperty.call(process.env, "PROCESSOR_ARCHITEW6432")) {
              sysdir = "%windir%\\sysnative\\cmd.exe /c %windir%\\System32";
            }
            util.powerShell("Get-CimInstance Win32_ComputerSystemProduct | select UUID | fl").then((stdout) => {
              let lines = stdout.split("\r\n");
              result.hardware = util.getValue(lines, "uuid", ":").toLowerCase();
              exec2(`${sysdir}\\reg query "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography" /v MachineGuid`, util.execOptsWin, function(error, stdout2) {
                parts = stdout2.toString().split("\n\r")[0].split("REG_SZ");
                result.os = parts.length > 1 ? parts[1].replace(/\r+|\n+|\s+/ig, "").toLowerCase() : "";
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            });
          }
        });
      });
    }
    exports.uuid = uuid;
  }
});

// node_modules/systeminformation/lib/cpu.js
var require_cpu = __commonJS({
  "node_modules/systeminformation/lib/cpu.js"(exports) {
    "use strict";
    var os2 = require("os");
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var fs = require("fs");
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _cpu_speed = 0;
    var _current_cpu = {
      user: 0,
      nice: 0,
      system: 0,
      idle: 0,
      irq: 0,
      steal: 0,
      guest: 0,
      load: 0,
      tick: 0,
      ms: 0,
      currentLoad: 0,
      currentLoadUser: 0,
      currentLoadSystem: 0,
      currentLoadNice: 0,
      currentLoadIdle: 0,
      currentLoadIrq: 0,
      currentLoadSteal: 0,
      currentLoadGuest: 0,
      rawCurrentLoad: 0,
      rawCurrentLoadUser: 0,
      rawCurrentLoadSystem: 0,
      rawCurrentLoadNice: 0,
      rawCurrentLoadIdle: 0,
      rawCurrentLoadIrq: 0,
      rawCurrentLoadSteal: 0,
      rawCurrentLoadGuest: 0
    };
    var _cpus = [];
    var _corecount = 0;
    var AMDBaseFrequencies = {
      "8346": "1.8",
      "8347": "1.9",
      "8350": "2.0",
      "8354": "2.2",
      "8356|SE": "2.4",
      "8356": "2.3",
      "8360": "2.5",
      "2372": "2.1",
      "2373": "2.1",
      "2374": "2.2",
      "2376": "2.3",
      "2377": "2.3",
      "2378": "2.4",
      "2379": "2.4",
      "2380": "2.5",
      "2381": "2.5",
      "2382": "2.6",
      "2384": "2.7",
      "2386": "2.8",
      "2387": "2.8",
      "2389": "2.9",
      "2393": "3.1",
      "8374": "2.2",
      "8376": "2.3",
      "8378": "2.4",
      "8379": "2.4",
      "8380": "2.5",
      "8381": "2.5",
      "8382": "2.6",
      "8384": "2.7",
      "8386": "2.8",
      "8387": "2.8",
      "8389": "2.9",
      "8393": "3.1",
      "2419EE": "1.8",
      "2423HE": "2.0",
      "2425HE": "2.1",
      "2427": "2.2",
      "2431": "2.4",
      "2435": "2.6",
      "2439SE": "2.8",
      "8425HE": "2.1",
      "8431": "2.4",
      "8435": "2.6",
      "8439SE": "2.8",
      "4122": "2.2",
      "4130": "2.6",
      "4162EE": "1.7",
      "4164EE": "1.8",
      "4170HE": "2.1",
      "4174HE": "2.3",
      "4176HE": "2.4",
      "4180": "2.6",
      "4184": "2.8",
      "6124HE": "1.8",
      "6128HE": "2.0",
      "6132HE": "2.2",
      "6128": "2.0",
      "6134": "2.3",
      "6136": "2.4",
      "6140": "2.6",
      "6164HE": "1.7",
      "6166HE": "1.8",
      "6168": "1.9",
      "6172": "2.1",
      "6174": "2.2",
      "6176": "2.3",
      "6176SE": "2.3",
      "6180SE": "2.5",
      "3250": "2.5",
      "3260": "2.7",
      "3280": "2.4",
      "4226": "2.7",
      "4228": "2.8",
      "4230": "2.9",
      "4234": "3.1",
      "4238": "3.3",
      "4240": "3.4",
      "4256": "1.6",
      "4274": "2.5",
      "4276": "2.6",
      "4280": "2.8",
      "4284": "3.0",
      "6204": "3.3",
      "6212": "2.6",
      "6220": "3.0",
      "6234": "2.4",
      "6238": "2.6",
      "6262HE": "1.6",
      "6272": "2.1",
      "6274": "2.2",
      "6276": "2.3",
      "6278": "2.4",
      "6282SE": "2.6",
      "6284SE": "2.7",
      "6308": "3.5",
      "6320": "2.8",
      "6328": "3.2",
      "6338P": "2.3",
      "6344": "2.6",
      "6348": "2.8",
      "6366": "1.8",
      "6370P": "2.0",
      "6376": "2.3",
      "6378": "2.4",
      "6380": "2.5",
      "6386": "2.8",
      "FX|4100": "3.6",
      "FX|4120": "3.9",
      "FX|4130": "3.8",
      "FX|4150": "3.8",
      "FX|4170": "4.2",
      "FX|6100": "3.3",
      "FX|6120": "3.6",
      "FX|6130": "3.6",
      "FX|6200": "3.8",
      "FX|8100": "2.8",
      "FX|8120": "3.1",
      "FX|8140": "3.2",
      "FX|8150": "3.6",
      "FX|8170": "3.9",
      "FX|4300": "3.8",
      "FX|4320": "4.0",
      "FX|4350": "4.2",
      "FX|6300": "3.5",
      "FX|6350": "3.9",
      "FX|8300": "3.3",
      "FX|8310": "3.4",
      "FX|8320": "3.5",
      "FX|8350": "4.0",
      "FX|8370": "4.0",
      "FX|9370": "4.4",
      "FX|9590": "4.7",
      "FX|8320E": "3.2",
      "FX|8370E": "3.3",
      // ZEN Desktop CPUs
      "1200": "3.1",
      "Pro 1200": "3.1",
      "1300X": "3.5",
      "Pro 1300": "3.5",
      "1400": "3.2",
      "1500X": "3.5",
      "Pro 1500": "3.5",
      "1600": "3.2",
      "1600X": "3.6",
      "Pro 1600": "3.2",
      "1700": "3.0",
      "Pro 1700": "3.0",
      "1700X": "3.4",
      "Pro 1700X": "3.4",
      "1800X": "3.6",
      "1900X": "3.8",
      "1920": "3.2",
      "1920X": "3.5",
      "1950X": "3.4",
      // ZEN Desktop APUs
      "200GE": "3.2",
      "Pro 200GE": "3.2",
      "220GE": "3.4",
      "240GE": "3.5",
      "3000G": "3.5",
      "300GE": "3.4",
      "3050GE": "3.4",
      "2200G": "3.5",
      "Pro 2200G": "3.5",
      "2200GE": "3.2",
      "Pro 2200GE": "3.2",
      "2400G": "3.6",
      "Pro 2400G": "3.6",
      "2400GE": "3.2",
      "Pro 2400GE": "3.2",
      // ZEN Mobile APUs
      "Pro 200U": "2.3",
      "300U": "2.4",
      "2200U": "2.5",
      "3200U": "2.6",
      "2300U": "2.0",
      "Pro 2300U": "2.0",
      "2500U": "2.0",
      "Pro 2500U": "2.2",
      "2600H": "3.2",
      "2700U": "2.0",
      "Pro 2700U": "2.2",
      "2800H": "3.3",
      // ZEN Server Processors
      "7351": "2.4",
      "7351P": "2.4",
      "7401": "2.0",
      "7401P": "2.0",
      "7551P": "2.0",
      "7551": "2.0",
      "7251": "2.1",
      "7261": "2.5",
      "7281": "2.1",
      "7301": "2.2",
      "7371": "3.1",
      "7451": "2.3",
      "7501": "2.0",
      "7571": "2.2",
      "7601": "2.2",
      // ZEN Embedded Processors
      "V1500B": "2.2",
      "V1780B": "3.35",
      "V1202B": "2.3",
      "V1404I": "2.0",
      "V1605B": "2.0",
      "V1756B": "3.25",
      "V1807B": "3.35",
      "3101": "2.1",
      "3151": "2.7",
      "3201": "1.5",
      "3251": "2.5",
      "3255": "2.5",
      "3301": "2.0",
      "3351": "1.9",
      "3401": "1.85",
      "3451": "2.15",
      // ZEN+ Desktop
      "1200|AF": "3.1",
      "2300X": "3.5",
      "2500X": "3.6",
      "2600": "3.4",
      "2600E": "3.1",
      "1600|AF": "3.2",
      "2600X": "3.6",
      "2700": "3.2",
      "2700E": "2.8",
      "Pro 2700": "3.2",
      "2700X": "3.7",
      "Pro 2700X": "3.6",
      "2920X": "3.5",
      "2950X": "3.5",
      "2970WX": "3.0",
      "2990WX": "3.0",
      // ZEN+ Desktop APU
      "Pro 300GE": "3.4",
      "Pro 3125GE": "3.4",
      "3150G": "3.5",
      "Pro 3150G": "3.5",
      "3150GE": "3.3",
      "Pro 3150GE": "3.3",
      "3200G": "3.6",
      "Pro 3200G": "3.6",
      "3200GE": "3.3",
      "Pro 3200GE": "3.3",
      "3350G": "3.6",
      "Pro 3350G": "3.6",
      "3350GE": "3.3",
      "Pro 3350GE": "3.3",
      "3400G": "3.7",
      "Pro 3400G": "3.7",
      "3400GE": "3.3",
      "Pro 3400GE": "3.3",
      // ZEN+ Mobile
      "3300U": "2.1",
      "PRO 3300U": "2.1",
      "3450U": "2.1",
      "3500U": "2.1",
      "PRO 3500U": "2.1",
      "3500C": "2.1",
      "3550H": "2.1",
      "3580U": "2.1",
      "3700U": "2.3",
      "PRO 3700U": "2.3",
      "3700C": "2.3",
      "3750H": "2.3",
      "3780U": "2.3",
      // ZEN2 Desktop CPUS
      "3100": "3.6",
      "3300X": "3.8",
      "3500": "3.6",
      "3500X": "3.6",
      "3600": "3.6",
      "Pro 3600": "3.6",
      "3600X": "3.8",
      "3600XT": "3.8",
      "Pro 3700": "3.6",
      "3700X": "3.6",
      "3800X": "3.9",
      "3800XT": "3.9",
      "3900": "3.1",
      "Pro 3900": "3.1",
      "3900X": "3.8",
      "3900XT": "3.8",
      "3950X": "3.5",
      "3960X": "3.8",
      "3970X": "3.7",
      "3990X": "2.9",
      "3945WX": "4.0",
      "3955WX": "3.9",
      "3975WX": "3.5",
      "3995WX": "2.7",
      // ZEN2 Desktop APUs
      "4300GE": "3.5",
      "Pro 4300GE": "3.5",
      "4300G": "3.8",
      "Pro 4300G": "3.8",
      "4600GE": "3.3",
      "Pro 4650GE": "3.3",
      "4600G": "3.7",
      "Pro 4650G": "3.7",
      "4700GE": "3.1",
      "Pro 4750GE": "3.1",
      "4700G": "3.6",
      "Pro 4750G": "3.6",
      "4300U": "2.7",
      "4450U": "2.5",
      "Pro 4450U": "2.5",
      "4500U": "2.3",
      "4600U": "2.1",
      "PRO 4650U": "2.1",
      "4680U": "2.1",
      "4600HS": "3.0",
      "4600H": "3.0",
      "4700U": "2.0",
      "PRO 4750U": "1.7",
      "4800U": "1.8",
      "4800HS": "2.9",
      "4800H": "2.9",
      "4900HS": "3.0",
      "4900H": "3.3",
      "5300U": "2.6",
      "5500U": "2.1",
      "5700U": "1.8",
      // ZEN2 - EPYC
      "7232P": "3.1",
      "7302P": "3.0",
      "7402P": "2.8",
      "7502P": "2.5",
      "7702P": "2.0",
      "7252": "3.1",
      "7262": "3.2",
      "7272": "2.9",
      "7282": "2.8",
      "7302": "3.0",
      "7352": "2.3",
      "7402": "2.8",
      "7452": "2.35",
      "7502": "2.5",
      "7532": "2.4",
      "7542": "2.9",
      "7552": "2.2",
      "7642": "2.3",
      "7662": "2.0",
      "7702": "2.0",
      "7742": "2.25",
      "7H12": "2.6",
      "7F32": "3.7",
      "7F52": "3.5",
      "7F72": "3.2",
      // Epyc (Milan)
      "7773X": "2.2",
      "7763": "2.45",
      "7713": "2.0",
      "7713P": "2.0",
      "7663": "2.0",
      "7643": "2.3",
      "7573X": "2.8",
      "75F3": "2.95",
      "7543": "2.8",
      "7543P": "2.8",
      "7513": "2.6",
      "7473X": "2.8",
      "7453": "2.75",
      "74F3": "3.2",
      "7443": "2.85",
      "7443P": "2.85",
      "7413": "2.65",
      "7373X": "3.05",
      "73F3": "3.5",
      "7343": "3.2",
      "7313": "3.0",
      "7313P": "3.0",
      "72F3": "3.7",
      // ZEN3
      "5600X": "3.7",
      "5800X": "3.8",
      "5900X": "3.7",
      "5950X": "3.4",
      "5945WX": "4.1",
      "5955WX": "4.0",
      "5965WX": "3.8",
      "5975WX": "3.6",
      "5995WX": "2.7",
      "7960X": "4.2",
      "7970X": "4.0",
      "7980X": "3.2",
      "7965WX": "4.2",
      "7975WX": "4.0",
      "7985WX": "3.2",
      "7995WX": "2.5",
      // ZEN4
      "9754": "2.25",
      "9754S": "2.25",
      "9734": "2.2",
      "9684X": "2.55",
      "9384X": "3.1",
      "9184X": "3.55",
      "9654P": "2.4",
      "9654": "2.4",
      "9634": "2.25",
      "9554P": "3.1",
      "9554": "3.1",
      "9534": "2.45",
      "9474F": "3.6",
      "9454P": "2.75",
      "9454": "2.75",
      "9374F": "3.85",
      "9354P": "3.25",
      "9354": "3.25",
      "9334": "2.7",
      "9274F": "4.05",
      "9254": "2.9",
      "9224": "2.5",
      "9174F": "4.1",
      "9124": "3.0"
    };
    var socketTypes = {
      1: "Other",
      2: "Unknown",
      3: "Daughter Board",
      4: "ZIF Socket",
      5: "Replacement/Piggy Back",
      6: "None",
      7: "LIF Socket",
      8: "Slot 1",
      9: "Slot 2",
      10: "370 Pin Socket",
      11: "Slot A",
      12: "Slot M",
      13: "423",
      14: "A (Socket 462)",
      15: "478",
      16: "754",
      17: "940",
      18: "939",
      19: "mPGA604",
      20: "LGA771",
      21: "LGA775",
      22: "S1",
      23: "AM2",
      24: "F (1207)",
      25: "LGA1366",
      26: "G34",
      27: "AM3",
      28: "C32",
      29: "LGA1156",
      30: "LGA1567",
      31: "PGA988A",
      32: "BGA1288",
      33: "rPGA988B",
      34: "BGA1023",
      35: "BGA1224",
      36: "LGA1155",
      37: "LGA1356",
      38: "LGA2011",
      39: "FS1",
      40: "FS2",
      41: "FM1",
      42: "FM2",
      43: "LGA2011-3",
      44: "LGA1356-3",
      45: "LGA1150",
      46: "BGA1168",
      47: "BGA1234",
      48: "BGA1364",
      49: "AM4",
      50: "LGA1151",
      51: "BGA1356",
      52: "BGA1440",
      53: "BGA1515",
      54: "LGA3647-1",
      55: "SP3",
      56: "SP3r2",
      57: "LGA2066",
      58: "BGA1392",
      59: "BGA1510",
      60: "BGA1528",
      61: "LGA4189",
      62: "LGA1200",
      63: "LGA4677",
      64: "LGA1700",
      65: "BGA1744",
      66: "BGA1781",
      67: "BGA1211",
      68: "BGA2422",
      69: "LGA1211",
      70: "LGA2422",
      71: "LGA5773",
      72: "BGA5773"
    };
    var socketTypesByName = {
      "LGA1150": "i7-5775C i3-4340 i3-4170 G3250 i3-4160T i3-4160 E3-1231 G3258 G3240 i7-4790S i7-4790K i7-4790 i5-4690K i5-4690 i5-4590T i5-4590S i5-4590 i5-4460 i3-4360 i3-4150 G1820 G3420 G3220 i7-4771 i5-4440 i3-4330 i3-4130T i3-4130 E3-1230 i7-4770S i7-4770K i7-4770 i5-4670K i5-4670 i5-4570T i5-4570S i5-4570 i5-4430",
      "LGA1151": "i9-9900KS E-2288G E-2224 G5420 i9-9900T i9-9900 i7-9700T i7-9700F i7-9700E i7-9700 i5-9600 i5-9500T i5-9500F i5-9500 i5-9400T i3-9350K i3-9300 i3-9100T i3-9100F i3-9100 G4930 i9-9900KF i7-9700KF i5-9600KF i5-9400F i5-9400 i3-9350KF i9-9900K i7-9700K i5-9600K G5500 G5400 i7-8700T i7-8086K i5-8600 i5-8500T i5-8500 i5-8400T i3-8300 i3-8100T G4900 i7-8700K i7-8700 i5-8600K i5-8400 i3-8350K i3-8100 E3-1270 G4600 G4560 i7-7700T i7-7700K i7-7700 i5-7600K i5-7600 i5-7500T i5-7500 i5-7400 i3-7350K i3-7300 i3-7100T i3-7100 G3930 G3900 G4400 i7-6700T i7-6700K i7-6700 i5-6600K i5-6600 i5-6500T i5-6500 i5-6400T i5-6400 i3-6300 i3-6100T i3-6100 E3-1270 E3-1270 T4500 T4400",
      "1155": "G440 G460 G465 G470 G530T G540T G550T G1610T G1620T G530 G540 G1610 G550 G1620 G555 G1630 i3-2100T i3-2120T i3-3220T i3-3240T i3-3250T i3-2100 i3-2105 i3-2102 i3-3210 i3-3220 i3-2125 i3-2120 i3-3225 i3-2130 i3-3245 i3-3240 i3-3250 i5-3570T i5-2500T i5-2400S i5-2405S i5-2390T i5-3330S i5-2500S i5-3335S i5-2300 i5-3450S i5-3340S i5-3470S i5-3475S i5-3470T i5-2310 i5-3550S i5-2320 i5-3330 i5-3350P i5-3450 i5-2400 i5-3340 i5-3570S i5-2380P i5-2450P i5-3470 i5-2500K i5-3550 i5-2500 i5-3570 i5-3570K i5-2550K i7-3770T i7-2600S i7-3770S i7-2600K i7-2600 i7-3770 i7-3770K i7-2700K G620T G630T G640T G2020T G645T G2100T G2030T G622 G860T G620 G632 G2120T G630 G640 G2010 G840 G2020 G850 G645 G2030 G860 G2120 G870 G2130 G2140 E3-1220L E3-1220L E3-1260L E3-1265L E3-1220 E3-1225 E3-1220 E3-1235 E3-1225 E3-1230 E3-1230 E3-1240 E3-1245 E3-1270 E3-1275 E3-1240 E3-1245 E3-1270 E3-1280 E3-1275 E3-1290 E3-1280 E3-1290"
    };
    function getSocketTypesByName(str) {
      let result = "";
      for (const key in socketTypesByName) {
        const names = socketTypesByName[key].split(" ");
        names.forEach((element) => {
          if (str.indexOf(element) >= 0) {
            result = key;
          }
        });
      }
      return result;
    }
    function cpuManufacturer(str) {
      let result = str;
      str = str.toLowerCase();
      if (str.indexOf("intel") >= 0) {
        result = "Intel";
      }
      if (str.indexOf("amd") >= 0) {
        result = "AMD";
      }
      if (str.indexOf("qemu") >= 0) {
        result = "QEMU";
      }
      if (str.indexOf("hygon") >= 0) {
        result = "Hygon";
      }
      if (str.indexOf("centaur") >= 0) {
        result = "WinChip/Via";
      }
      if (str.indexOf("vmware") >= 0) {
        result = "VMware";
      }
      if (str.indexOf("Xen") >= 0) {
        result = "Xen Hypervisor";
      }
      if (str.indexOf("tcg") >= 0) {
        result = "QEMU";
      }
      if (str.indexOf("apple") >= 0) {
        result = "Apple";
      }
      return result;
    }
    function cpuBrandManufacturer(res) {
      res.brand = res.brand.replace(/\(R\)+/g, "\xAE").replace(/\s+/g, " ").trim();
      res.brand = res.brand.replace(/\(TM\)+/g, "\u2122").replace(/\s+/g, " ").trim();
      res.brand = res.brand.replace(/\(C\)+/g, "\xA9").replace(/\s+/g, " ").trim();
      res.brand = res.brand.replace(/CPU+/g, "").replace(/\s+/g, " ").trim();
      res.manufacturer = cpuManufacturer(res.brand);
      let parts = res.brand.split(" ");
      parts.shift();
      res.brand = parts.join(" ");
      return res;
    }
    function getAMDSpeed(brand) {
      let result = "0";
      for (let key in AMDBaseFrequencies) {
        if ({}.hasOwnProperty.call(AMDBaseFrequencies, key)) {
          let parts = key.split("|");
          let found = 0;
          parts.forEach((item) => {
            if (brand.indexOf(item) > -1) {
              found++;
            }
          });
          if (found === parts.length) {
            result = AMDBaseFrequencies[key];
          }
        }
      }
      return parseFloat(result);
    }
    function getCpu() {
      return new Promise((resolve) => {
        process.nextTick(() => {
          const UNKNOWN = "unknown";
          let result = {
            manufacturer: UNKNOWN,
            brand: UNKNOWN,
            vendor: "",
            family: "",
            model: "",
            stepping: "",
            revision: "",
            voltage: "",
            speed: 0,
            speedMin: 0,
            speedMax: 0,
            governor: "",
            cores: util.cores(),
            physicalCores: util.cores(),
            performanceCores: util.cores(),
            efficiencyCores: 0,
            processors: 1,
            socket: "",
            flags: "",
            virtualization: false,
            cache: {}
          };
          cpuFlags().then((flags) => {
            result.flags = flags;
            result.virtualization = flags.indexOf("vmx") > -1 || flags.indexOf("svm") > -1;
            if (_darwin) {
              exec2("sysctl machdep.cpu hw.cpufrequency_max hw.cpufrequency_min hw.packages hw.physicalcpu_max hw.ncpu hw.tbfrequency hw.cpufamily hw.cpusubfamily", function(error, stdout) {
                let lines = stdout.toString().split("\n");
                const modelline = util.getValue(lines, "machdep.cpu.brand_string");
                const modellineParts = modelline.split("@");
                result.brand = modellineParts[0].trim();
                const speed = modellineParts[1] ? modellineParts[1].trim() : "0";
                result.speed = parseFloat(speed.replace(/GHz+/g, ""));
                let tbFrequency = util.getValue(lines, "hw.tbfrequency") / 1e9;
                tbFrequency = tbFrequency < 0.1 ? tbFrequency * 100 : tbFrequency;
                result.speed = result.speed === 0 ? tbFrequency : result.speed;
                _cpu_speed = result.speed;
                result = cpuBrandManufacturer(result);
                result.speedMin = util.getValue(lines, "hw.cpufrequency_min") ? util.getValue(lines, "hw.cpufrequency_min") / 1e9 : result.speed;
                result.speedMax = util.getValue(lines, "hw.cpufrequency_max") ? util.getValue(lines, "hw.cpufrequency_max") / 1e9 : result.speed;
                result.vendor = util.getValue(lines, "machdep.cpu.vendor") || "Apple";
                result.family = util.getValue(lines, "machdep.cpu.family") || util.getValue(lines, "hw.cpufamily");
                result.model = util.getValue(lines, "machdep.cpu.model");
                result.stepping = util.getValue(lines, "machdep.cpu.stepping") || util.getValue(lines, "hw.cpusubfamily");
                result.virtualization = true;
                const countProcessors = util.getValue(lines, "hw.packages");
                const countCores = util.getValue(lines, "hw.physicalcpu_max");
                const countThreads = util.getValue(lines, "hw.ncpu");
                if (os2.arch() === "arm64") {
                  result.socket = "SOC";
                  try {
                    const clusters = execSync("ioreg -c IOPlatformDevice -d 3 -r | grep cluster-type").toString().split("\n");
                    const efficiencyCores = clusters.filter((line) => line.indexOf('"E"') >= 0).length;
                    const performanceCores = clusters.filter((line) => line.indexOf('"P"') >= 0).length;
                    result.efficiencyCores = efficiencyCores;
                    result.performanceCores = performanceCores;
                  } catch (e) {
                    util.noop();
                  }
                }
                if (countProcessors) {
                  result.processors = parseInt(countProcessors) || 1;
                }
                if (countCores && countThreads) {
                  result.cores = parseInt(countThreads) || util.cores();
                  result.physicalCores = parseInt(countCores) || util.cores();
                }
                cpuCache().then((res) => {
                  result.cache = res;
                  resolve(result);
                });
              });
            }
            if (_linux) {
              let modelline = "";
              let lines = [];
              if (os2.cpus()[0] && os2.cpus()[0].model) {
                modelline = os2.cpus()[0].model;
              }
              exec2('export LC_ALL=C; lscpu; echo -n "Governor: "; cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null; echo; unset LC_ALL', function(error, stdout) {
                if (!error) {
                  lines = stdout.toString().split("\n");
                }
                modelline = util.getValue(lines, "model name") || modelline;
                modelline = util.getValue(lines, "bios model name") || modelline;
                const modellineParts = modelline.split("@");
                result.brand = modellineParts[0].trim();
                result.speed = modellineParts[1] ? parseFloat(modellineParts[1].trim()) : 0;
                if (result.speed === 0 && (result.brand.indexOf("AMD") > -1 || result.brand.toLowerCase().indexOf("ryzen") > -1)) {
                  result.speed = getAMDSpeed(result.brand);
                }
                if (result.speed === 0) {
                  const current = getCpuCurrentSpeedSync();
                  if (current.avg !== 0) {
                    result.speed = current.avg;
                  }
                }
                _cpu_speed = result.speed;
                result.speedMin = Math.round(parseFloat(util.getValue(lines, "cpu min mhz").replace(/,/g, ".")) / 10) / 100;
                result.speedMax = Math.round(parseFloat(util.getValue(lines, "cpu max mhz").replace(/,/g, ".")) / 10) / 100;
                result = cpuBrandManufacturer(result);
                result.vendor = cpuManufacturer(util.getValue(lines, "vendor id"));
                result.family = util.getValue(lines, "cpu family");
                result.model = util.getValue(lines, "model:");
                result.stepping = util.getValue(lines, "stepping");
                result.revision = util.getValue(lines, "cpu revision");
                result.cache.l1d = util.getValue(lines, "l1d cache");
                if (result.cache.l1d) {
                  result.cache.l1d = parseInt(result.cache.l1d) * (result.cache.l1d.indexOf("M") !== -1 ? 1024 * 1024 : result.cache.l1d.indexOf("K") !== -1 ? 1024 : 1);
                }
                result.cache.l1i = util.getValue(lines, "l1i cache");
                if (result.cache.l1i) {
                  result.cache.l1i = parseInt(result.cache.l1i) * (result.cache.l1i.indexOf("M") !== -1 ? 1024 * 1024 : result.cache.l1i.indexOf("K") !== -1 ? 1024 : 1);
                }
                result.cache.l2 = util.getValue(lines, "l2 cache");
                if (result.cache.l2) {
                  result.cache.l2 = parseInt(result.cache.l2) * (result.cache.l2.indexOf("M") !== -1 ? 1024 * 1024 : result.cache.l2.indexOf("K") !== -1 ? 1024 : 1);
                }
                result.cache.l3 = util.getValue(lines, "l3 cache");
                if (result.cache.l3) {
                  result.cache.l3 = parseInt(result.cache.l3) * (result.cache.l3.indexOf("M") !== -1 ? 1024 * 1024 : result.cache.l3.indexOf("K") !== -1 ? 1024 : 1);
                }
                const threadsPerCore = util.getValue(lines, "thread(s) per core") || "1";
                const processors = util.getValue(lines, "socket(s)") || "1";
                const threadsPerCoreInt = parseInt(threadsPerCore, 10);
                const processorsInt = parseInt(processors, 10) || 1;
                const coresPerSocket = parseInt(util.getValue(lines, "core(s) per socket"), 10);
                result.physicalCores = coresPerSocket ? coresPerSocket * processorsInt : result.cores / threadsPerCoreInt;
                result.performanceCores = threadsPerCoreInt > 1 ? result.cores - result.physicalCores : result.cores;
                result.efficiencyCores = threadsPerCoreInt > 1 ? result.cores - threadsPerCoreInt * result.performanceCores : 0;
                result.processors = processorsInt;
                result.governor = util.getValue(lines, "governor") || "";
                if (result.vendor === "ARM") {
                  const linesRpi = fs.readFileSync("/proc/cpuinfo").toString().split("\n");
                  const rPIRevision = util.decodePiCpuinfo(linesRpi);
                  if (rPIRevision.model.toLowerCase().indexOf("raspberry") >= 0) {
                    result.family = result.manufacturer;
                    result.manufacturer = rPIRevision.manufacturer;
                    result.brand = rPIRevision.processor;
                    result.revision = rPIRevision.revisionCode;
                    result.socket = "SOC";
                  }
                }
                let lines2 = [];
                exec2('export LC_ALL=C; dmidecode \u2013t 4 2>/dev/null | grep "Upgrade: Socket"; unset LC_ALL', function(error2, stdout2) {
                  lines2 = stdout2.toString().split("\n");
                  if (lines2 && lines2.length) {
                    result.socket = util.getValue(lines2, "Upgrade").replace("Socket", "").trim() || result.socket;
                  }
                  resolve(result);
                });
              });
            }
            if (_freebsd || _openbsd || _netbsd) {
              let modelline = "";
              let lines = [];
              if (os2.cpus()[0] && os2.cpus()[0].model) {
                modelline = os2.cpus()[0].model;
              }
              exec2("export LC_ALL=C; dmidecode -t 4; dmidecode -t 7 unset LC_ALL", function(error, stdout) {
                let cache = [];
                if (!error) {
                  const data = stdout.toString().split("# dmidecode");
                  const processor = data.length > 1 ? data[1] : "";
                  cache = data.length > 2 ? data[2].split("Cache Information") : [];
                  lines = processor.split("\n");
                }
                result.brand = modelline.split("@")[0].trim();
                result.speed = modelline.split("@")[1] ? parseFloat(modelline.split("@")[1].trim()) : 0;
                if (result.speed === 0 && (result.brand.indexOf("AMD") > -1 || result.brand.toLowerCase().indexOf("ryzen") > -1)) {
                  result.speed = getAMDSpeed(result.brand);
                }
                if (result.speed === 0) {
                  const current = getCpuCurrentSpeedSync();
                  if (current.avg !== 0) {
                    result.speed = current.avg;
                  }
                }
                _cpu_speed = result.speed;
                result.speedMin = result.speed;
                result.speedMax = Math.round(parseFloat(util.getValue(lines, "max speed").replace(/Mhz/g, "")) / 10) / 100;
                result = cpuBrandManufacturer(result);
                result.vendor = cpuManufacturer(util.getValue(lines, "manufacturer"));
                let sig = util.getValue(lines, "signature");
                sig = sig.split(",");
                for (let i = 0; i < sig.length; i++) {
                  sig[i] = sig[i].trim();
                }
                result.family = util.getValue(sig, "Family", " ", true);
                result.model = util.getValue(sig, "Model", " ", true);
                result.stepping = util.getValue(sig, "Stepping", " ", true);
                result.revision = "";
                const voltage = parseFloat(util.getValue(lines, "voltage"));
                result.voltage = isNaN(voltage) ? "" : voltage.toFixed(2);
                for (let i = 0; i < cache.length; i++) {
                  lines = cache[i].split("\n");
                  let cacheType = util.getValue(lines, "Socket Designation").toLowerCase().replace(" ", "-").split("-");
                  cacheType = cacheType.length ? cacheType[0] : "";
                  const sizeParts = util.getValue(lines, "Installed Size").split(" ");
                  let size = parseInt(sizeParts[0], 10);
                  const unit = sizeParts.length > 1 ? sizeParts[1] : "kb";
                  size = size * (unit === "kb" ? 1024 : unit === "mb" ? 1024 * 1024 : unit === "gb" ? 1024 * 1024 * 1024 : 1);
                  if (cacheType) {
                    if (cacheType === "l1") {
                      result.cache[cacheType + "d"] = size / 2;
                      result.cache[cacheType + "i"] = size / 2;
                    } else {
                      result.cache[cacheType] = size;
                    }
                  }
                }
                result.socket = util.getValue(lines, "Upgrade").replace("Socket", "").trim();
                const threadCount = util.getValue(lines, "thread count").trim();
                const coreCount = util.getValue(lines, "core count").trim();
                if (coreCount && threadCount) {
                  result.cores = parseInt(threadCount, 10);
                  result.physicalCores = parseInt(coreCount, 10);
                }
                resolve(result);
              });
            }
            if (_sunos) {
              resolve(result);
            }
            if (_windows) {
              try {
                const workload = [];
                workload.push(util.powerShell("Get-CimInstance Win32_processor | select Name, Revision, L2CacheSize, L3CacheSize, Manufacturer, MaxClockSpeed, Description, UpgradeMethod, Caption, NumberOfLogicalProcessors, NumberOfCores | fl"));
                workload.push(util.powerShell("Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl"));
                workload.push(util.powerShell("(Get-CimInstance Win32_ComputerSystem).HypervisorPresent"));
                Promise.all(
                  workload
                ).then((data) => {
                  let lines = data[0].split("\r\n");
                  let name = util.getValue(lines, "name", ":") || "";
                  if (name.indexOf("@") >= 0) {
                    result.brand = name.split("@")[0].trim();
                    result.speed = name.split("@")[1] ? parseFloat(name.split("@")[1].trim()) : 0;
                    _cpu_speed = result.speed;
                  } else {
                    result.brand = name.trim();
                    result.speed = 0;
                  }
                  result = cpuBrandManufacturer(result);
                  result.revision = util.getValue(lines, "revision", ":");
                  result.vendor = util.getValue(lines, "manufacturer", ":");
                  result.speedMax = Math.round(parseFloat(util.getValue(lines, "maxclockspeed", ":").replace(/,/g, ".")) / 10) / 100;
                  if (result.speed === 0 && (result.brand.indexOf("AMD") > -1 || result.brand.toLowerCase().indexOf("ryzen") > -1)) {
                    result.speed = getAMDSpeed(result.brand);
                  }
                  if (result.speed === 0) {
                    result.speed = result.speedMax;
                  }
                  result.speedMin = result.speed;
                  let description = util.getValue(lines, "description", ":").split(" ");
                  for (let i = 0; i < description.length; i++) {
                    if (description[i].toLowerCase().startsWith("family") && i + 1 < description.length && description[i + 1]) {
                      result.family = description[i + 1];
                    }
                    if (description[i].toLowerCase().startsWith("model") && i + 1 < description.length && description[i + 1]) {
                      result.model = description[i + 1];
                    }
                    if (description[i].toLowerCase().startsWith("stepping") && i + 1 < description.length && description[i + 1]) {
                      result.stepping = description[i + 1];
                    }
                  }
                  const socketId = util.getValue(lines, "UpgradeMethod", ":");
                  if (socketTypes[socketId]) {
                    result.socket = socketTypes[socketId];
                  }
                  const socketByName = getSocketTypesByName(name);
                  if (socketByName) {
                    result.socket = socketByName;
                  }
                  const countProcessors = util.countLines(lines, "Caption");
                  const countThreads = util.getValue(lines, "NumberOfLogicalProcessors", ":");
                  const countCores = util.getValue(lines, "NumberOfCores", ":");
                  if (countProcessors) {
                    result.processors = parseInt(countProcessors) || 1;
                  }
                  if (countCores && countThreads) {
                    result.cores = parseInt(countThreads) || util.cores();
                    result.physicalCores = parseInt(countCores) || util.cores();
                  }
                  if (countProcessors > 1) {
                    result.cores = result.cores * countProcessors;
                    result.physicalCores = result.physicalCores * countProcessors;
                  }
                  result.cache = parseWinCache(data[0], data[1]);
                  const hyperv = data[2] ? data[2].toString().toLowerCase() : "";
                  result.virtualization = hyperv.indexOf("true") !== -1;
                  resolve(result);
                });
              } catch (e) {
                resolve(result);
              }
            }
          });
        });
      });
    }
    function cpu(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          getCpu().then((result) => {
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        });
      });
    }
    exports.cpu = cpu;
    function getCpuCurrentSpeedSync() {
      let cpus = os2.cpus();
      let minFreq = 999999999;
      let maxFreq = 0;
      let avgFreq = 0;
      let cores = [];
      if (cpus && cpus.length) {
        for (let i in cpus) {
          if ({}.hasOwnProperty.call(cpus, i)) {
            let freq = cpus[i].speed > 100 ? (cpus[i].speed + 1) / 1e3 : cpus[i].speed / 10;
            avgFreq = avgFreq + freq;
            if (freq > maxFreq) {
              maxFreq = freq;
            }
            if (freq < minFreq) {
              minFreq = freq;
            }
            cores.push(parseFloat(freq.toFixed(2)));
          }
        }
        avgFreq = avgFreq / cpus.length;
        return {
          min: parseFloat(minFreq.toFixed(2)),
          max: parseFloat(maxFreq.toFixed(2)),
          avg: parseFloat(avgFreq.toFixed(2)),
          cores
        };
      } else {
        return {
          min: 0,
          max: 0,
          avg: 0,
          cores
        };
      }
    }
    function cpuCurrentSpeed(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = getCpuCurrentSpeedSync();
          if (result.avg === 0 && _cpu_speed !== 0) {
            const currCpuSpeed = parseFloat(_cpu_speed);
            result = {
              min: currCpuSpeed,
              max: currCpuSpeed,
              avg: currCpuSpeed,
              cores: []
            };
          }
          if (callback) {
            callback(result);
          }
          resolve(result);
        });
      });
    }
    exports.cpuCurrentSpeed = cpuCurrentSpeed;
    function cpuTemperature(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            main: null,
            cores: [],
            max: null,
            socket: [],
            chipset: null
          };
          if (_linux) {
            try {
              const cmd2 = 'cat /sys/class/thermal/thermal_zone*/type  2>/dev/null; echo "-----"; cat /sys/class/thermal/thermal_zone*/temp 2>/dev/null;';
              const parts = execSync(cmd2, util.execOptsLinux).toString().split("-----\n");
              if (parts.length === 2) {
                const lines = parts[0].split("\n");
                const lines2 = parts[1].split("\n");
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i].trim();
                  if (line.startsWith("acpi") && lines2[i]) {
                    result.socket.push(Math.round(parseInt(lines2[i], 10) / 100) / 10);
                  }
                  if (line.startsWith("pch") && lines2[i]) {
                    result.chipset = Math.round(parseInt(lines2[i], 10) / 100) / 10;
                  }
                }
              }
            } catch (e) {
              util.noop();
            }
            const cmd = 'for mon in /sys/class/hwmon/hwmon*; do for label in "$mon"/temp*_label; do if [ -f $label ]; then value=${label%_*}_input; echo $(cat "$label")___$(cat "$value"); fi; done; done;';
            try {
              exec2(cmd, function(error, stdout) {
                stdout = stdout.toString();
                const tdiePos = stdout.toLowerCase().indexOf("tdie");
                if (tdiePos !== -1) {
                  stdout = stdout.substring(tdiePos);
                }
                let lines = stdout.split("\n");
                let tctl = 0;
                lines.forEach((line) => {
                  const parts = line.split("___");
                  const label = parts[0];
                  const value = parts.length > 1 && parts[1] ? parts[1] : "0";
                  if (value && label && label.toLowerCase() === "tctl") {
                    tctl = result.main = Math.round(parseInt(value, 10) / 100) / 10;
                  }
                  if (value && (label === void 0 || label && label.toLowerCase().startsWith("core"))) {
                    result.cores.push(Math.round(parseInt(value, 10) / 100) / 10);
                  } else if (value && label && result.main === null && (label.toLowerCase().indexOf("package") >= 0 || label.toLowerCase().indexOf("physical") >= 0 || label.toLowerCase() === "tccd1")) {
                    result.main = Math.round(parseInt(value, 10) / 100) / 10;
                  }
                });
                if (tctl && result.main === null) {
                  result.main = tctl;
                }
                if (result.cores.length > 0) {
                  if (result.main === null) {
                    result.main = Math.round(result.cores.reduce((a, b) => a + b, 0) / result.cores.length);
                  }
                  let maxtmp = Math.max.apply(Math, result.cores);
                  result.max = maxtmp > result.main ? maxtmp : result.main;
                }
                if (result.main !== null) {
                  if (result.max === null) {
                    result.max = result.main;
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                  return;
                }
                exec2("sensors", function(error2, stdout2) {
                  if (!error2) {
                    let lines2 = stdout2.toString().split("\n");
                    let tdieTemp = null;
                    let newSectionStarts = true;
                    let section = "";
                    lines2.forEach(function(line) {
                      if (line.trim() === "") {
                        newSectionStarts = true;
                      } else if (newSectionStarts) {
                        if (line.trim().toLowerCase().startsWith("acpi")) {
                          section = "acpi";
                        }
                        if (line.trim().toLowerCase().startsWith("pch")) {
                          section = "pch";
                        }
                        if (line.trim().toLowerCase().startsWith("core")) {
                          section = "core";
                        }
                        newSectionStarts = false;
                      }
                      let regex = /[+-]([^°]*)/g;
                      let temps = line.match(regex);
                      let firstPart = line.split(":")[0].toUpperCase();
                      if (section === "acpi") {
                        if (firstPart.indexOf("TEMP") !== -1) {
                          result.socket.push(parseFloat(temps));
                        }
                      } else if (section === "pch") {
                        if (firstPart.indexOf("TEMP") !== -1 && !result.chipset) {
                          result.chipset = parseFloat(temps);
                        }
                      }
                      if (firstPart.indexOf("PHYSICAL") !== -1 || firstPart.indexOf("PACKAGE") !== -1) {
                        result.main = parseFloat(temps);
                      }
                      if (firstPart.indexOf("CORE ") !== -1) {
                        result.cores.push(parseFloat(temps));
                      }
                      if (firstPart.indexOf("TDIE") !== -1 && tdieTemp === null) {
                        tdieTemp = parseFloat(temps);
                      }
                    });
                    if (result.cores.length > 0) {
                      result.main = Math.round(result.cores.reduce((a, b) => a + b, 0) / result.cores.length);
                      let maxtmp = Math.max.apply(Math, result.cores);
                      result.max = maxtmp > result.main ? maxtmp : result.main;
                    } else {
                      if (result.main === null && tdieTemp !== null) {
                        result.main = tdieTemp;
                        result.max = tdieTemp;
                      }
                    }
                    if (result.main !== null || result.max !== null) {
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                      return;
                    }
                  }
                  fs.stat("/sys/class/thermal/thermal_zone0/temp", function(err) {
                    if (err === null) {
                      fs.readFile("/sys/class/thermal/thermal_zone0/temp", function(error3, stdout3) {
                        if (!error3) {
                          let lines2 = stdout3.toString().split("\n");
                          if (lines2.length > 0) {
                            result.main = parseFloat(lines2[0]) / 1e3;
                            result.max = result.main;
                          }
                        }
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      });
                    } else {
                      exec2("/opt/vc/bin/vcgencmd measure_temp", function(error3, stdout3) {
                        if (!error3) {
                          let lines2 = stdout3.toString().split("\n");
                          if (lines2.length > 0 && lines2[0].indexOf("=")) {
                            result.main = parseFloat(lines2[0].split("=")[1]);
                            result.max = result.main;
                          }
                        }
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      });
                    }
                  });
                });
              });
            } catch (er) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2("sysctl dev.cpu | grep temp", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                let sum = 0;
                lines.forEach(function(line) {
                  const parts = line.split(":");
                  if (parts.length > 1) {
                    const temp = parseFloat(parts[1].replace(",", "."));
                    if (temp > result.max) {
                      result.max = temp;
                    }
                    sum = sum + temp;
                    result.cores.push(temp);
                  }
                });
                if (result.cores.length) {
                  result.main = Math.round(sum / result.cores.length * 100) / 100;
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            let osxTemp = null;
            try {
              osxTemp = require("osx-temperature-sensor");
            } catch (er) {
              osxTemp = null;
            }
            if (osxTemp) {
              result = osxTemp.cpuTemperature();
              if (result.main) {
                result.main = Math.round(result.main * 100) / 100;
              }
              if (result.max) {
                result.max = Math.round(result.max * 100) / 100;
              }
              if (result.cores && result.cores.length) {
                for (let i = 0; i < result.cores.length; i++) {
                  result.cores[i] = Math.round(result.cores[i] * 100) / 100;
                }
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              util.powerShell('Get-CimInstance MSAcpi_ThermalZoneTemperature -Namespace "root/wmi" | Select CurrentTemperature').then((stdout, error) => {
                if (!error) {
                  let sum = 0;
                  let lines = stdout.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                  lines.forEach(function(line) {
                    let value = (parseInt(line, 10) - 2732) / 10;
                    if (!isNaN(value)) {
                      sum = sum + value;
                      if (value > result.max) {
                        result.max = value;
                      }
                      result.cores.push(value);
                    }
                  });
                  if (result.cores.length) {
                    result.main = sum / result.cores.length;
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.cpuTemperature = cpuTemperature;
    function cpuFlags(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = "";
          if (_windows) {
            try {
              exec2('reg query "HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0" /v FeatureSet', util.execOptsWin, function(error, stdout) {
                if (!error) {
                  let flag_hex = stdout.split("0x").pop().trim();
                  let flag_bin_unpadded = parseInt(flag_hex, 16).toString(2);
                  let flag_bin = "0".repeat(32 - flag_bin_unpadded.length) + flag_bin_unpadded;
                  let all_flags = [
                    "fpu",
                    "vme",
                    "de",
                    "pse",
                    "tsc",
                    "msr",
                    "pae",
                    "mce",
                    "cx8",
                    "apic",
                    "",
                    "sep",
                    "mtrr",
                    "pge",
                    "mca",
                    "cmov",
                    "pat",
                    "pse-36",
                    "psn",
                    "clfsh",
                    "",
                    "ds",
                    "acpi",
                    "mmx",
                    "fxsr",
                    "sse",
                    "sse2",
                    "ss",
                    "htt",
                    "tm",
                    "ia64",
                    "pbe"
                  ];
                  for (let f = 0; f < all_flags.length; f++) {
                    if (flag_bin[f] === "1" && all_flags[f] !== "") {
                      result += " " + all_flags[f];
                    }
                  }
                  result = result.trim().toLowerCase();
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_linux) {
            try {
              exec2("export LC_ALL=C; lscpu; unset LC_ALL", function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    if (line.split(":")[0].toUpperCase().indexOf("FLAGS") !== -1) {
                      result = line.split(":")[1].trim().toLowerCase();
                    }
                  });
                }
                if (!result) {
                  fs.readFile("/proc/cpuinfo", function(error2, stdout2) {
                    if (!error2) {
                      let lines = stdout2.toString().split("\n");
                      result = util.getValue(lines, "features", ":", true).toLowerCase();
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2("export LC_ALL=C; dmidecode -t 4 2>/dev/null; unset LC_ALL", function(error, stdout) {
              let flags = [];
              if (!error) {
                let parts = stdout.toString().split("	Flags:");
                const lines = parts.length > 1 ? parts[1].split("	Version:")[0].split("\n") : [];
                lines.forEach(function(line) {
                  let flag = (line.indexOf("(") ? line.split("(")[0].toLowerCase() : "").trim().replace(/\t/g, "");
                  if (flag) {
                    flags.push(flag);
                  }
                });
              }
              result = flags.join(" ").trim().toLowerCase();
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2("sysctl machdep.cpu.features", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                if (lines.length > 0 && lines[0].indexOf("machdep.cpu.features:") !== -1) {
                  result = lines[0].split(":")[1].trim().toLowerCase();
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.cpuFlags = cpuFlags;
    function cpuCache(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            l1d: null,
            l1i: null,
            l2: null,
            l3: null
          };
          if (_linux) {
            try {
              exec2("export LC_ALL=C; lscpu; unset LC_ALL", function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    let parts = line.split(":");
                    if (parts[0].toUpperCase().indexOf("L1D CACHE") !== -1) {
                      result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                    }
                    if (parts[0].toUpperCase().indexOf("L1I CACHE") !== -1) {
                      result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                    }
                    if (parts[0].toUpperCase().indexOf("L2 CACHE") !== -1) {
                      result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                    }
                    if (parts[0].toUpperCase().indexOf("L3 CACHE") !== -1) {
                      result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf("M") !== -1 ? 1024 * 1024 : parts[1].indexOf("K") !== -1 ? 1024 : 1);
                    }
                  });
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2("export LC_ALL=C; dmidecode -t 7 2>/dev/null; unset LC_ALL", function(error, stdout) {
              let cache = [];
              if (!error) {
                const data = stdout.toString();
                cache = data.split("Cache Information");
                cache.shift();
              }
              for (let i = 0; i < cache.length; i++) {
                const lines = cache[i].split("\n");
                let cacheType = util.getValue(lines, "Socket Designation").toLowerCase().replace(" ", "-").split("-");
                cacheType = cacheType.length ? cacheType[0] : "";
                const sizeParts = util.getValue(lines, "Installed Size").split(" ");
                let size = parseInt(sizeParts[0], 10);
                const unit = sizeParts.length > 1 ? sizeParts[1] : "kb";
                size = size * (unit === "kb" ? 1024 : unit === "mb" ? 1024 * 1024 : unit === "gb" ? 1024 * 1024 * 1024 : 1);
                if (cacheType) {
                  if (cacheType === "l1") {
                    result.cache[cacheType + "d"] = size / 2;
                    result.cache[cacheType + "i"] = size / 2;
                  } else {
                    result.cache[cacheType] = size;
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2("sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                lines.forEach(function(line) {
                  let parts = line.split(":");
                  if (parts[0].toLowerCase().indexOf("hw.l1icachesize") !== -1) {
                    result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts[0].toLowerCase().indexOf("hw.l1dcachesize") !== -1) {
                    result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts[0].toLowerCase().indexOf("hw.l2cachesize") !== -1) {
                    result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts[0].toLowerCase().indexOf("hw.l3cachesize") !== -1) {
                    result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              const workload = [];
              workload.push(util.powerShell("Get-CimInstance Win32_processor | select L2CacheSize, L3CacheSize | fl"));
              workload.push(util.powerShell("Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl"));
              Promise.all(
                workload
              ).then((data) => {
                result = parseWinCache(data[0], data[1]);
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    function parseWinCache(linesProc, linesCache) {
      let result = {
        l1d: null,
        l1i: null,
        l2: null,
        l3: null
      };
      let lines = linesProc.split("\r\n");
      result.l1d = 0;
      result.l1i = 0;
      result.l2 = util.getValue(lines, "l2cachesize", ":");
      result.l3 = util.getValue(lines, "l3cachesize", ":");
      if (result.l2) {
        result.l2 = parseInt(result.l2, 10) * 1024;
      } else {
        result.l2 = 0;
      }
      if (result.l3) {
        result.l3 = parseInt(result.l3, 10) * 1024;
      } else {
        result.l3 = 0;
      }
      const parts = linesCache.split(/\n\s*\n/);
      let l1i = 0;
      let l1d = 0;
      let l2 = 0;
      parts.forEach(function(part) {
        const lines2 = part.split("\r\n");
        const cacheType = util.getValue(lines2, "CacheType");
        const level = util.getValue(lines2, "Level");
        const installedSize = util.getValue(lines2, "InstalledSize");
        if (level === "3" && cacheType === "3") {
          result.l1i = result.l1i + parseInt(installedSize, 10) * 1024;
        }
        if (level === "3" && cacheType === "4") {
          result.l1d = result.l1d + parseInt(installedSize, 10) * 1024;
        }
        if (level === "3" && cacheType === "5") {
          l1i = parseInt(installedSize, 10) / 2;
          l1d = parseInt(installedSize, 10) / 2;
        }
        if (level === "4" && cacheType === "5") {
          l2 = l2 + parseInt(installedSize, 10) * 1024;
        }
      });
      if (!result.l1i && !result.l1d) {
        result.l1i = l1i;
        result.l1d = l1d;
      }
      if (l2) {
        result.l2 = l2;
      }
      return result;
    }
    exports.cpuCache = cpuCache;
    function getLoad() {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let loads = os2.loadavg().map(function(x) {
            return x / util.cores();
          });
          let avgLoad = parseFloat(Math.max.apply(Math, loads).toFixed(2));
          let result = {};
          let now = Date.now() - _current_cpu.ms;
          if (now >= 200) {
            _current_cpu.ms = Date.now();
            const cpus = os2.cpus().map(function(cpu2) {
              cpu2.times.steal = 0;
              cpu2.times.guest = 0;
              return cpu2;
            });
            let totalUser = 0;
            let totalSystem = 0;
            let totalNice = 0;
            let totalIrq = 0;
            let totalIdle = 0;
            let totalSteal = 0;
            let totalGuest = 0;
            let cores = [];
            _corecount = cpus && cpus.length ? cpus.length : 0;
            if (_linux) {
              try {
                const lines = execSync("cat /proc/stat 2>/dev/null | grep cpu", util.execOptsLinux).toString().split("\n");
                if (lines.length > 1) {
                  lines.shift();
                  if (lines.length === cpus.length) {
                    for (let i = 0; i < lines.length; i++) {
                      let parts = lines[i].split(" ");
                      if (parts.length >= 10) {
                        const steal = parseFloat(parts[8]) || 0;
                        const guest = parseFloat(parts[9]) || 0;
                        cpus[i].times.steal = steal;
                        cpus[i].times.guest = guest;
                      }
                    }
                  }
                }
              } catch (e) {
                util.noop();
              }
            }
            for (let i = 0; i < _corecount; i++) {
              const cpu2 = cpus[i].times;
              totalUser += cpu2.user;
              totalSystem += cpu2.sys;
              totalNice += cpu2.nice;
              totalIdle += cpu2.idle;
              totalIrq += cpu2.irq;
              totalSteal += cpu2.steal || 0;
              totalGuest += cpu2.guest || 0;
              let tmpTick = _cpus && _cpus[i] && _cpus[i].totalTick ? _cpus[i].totalTick : 0;
              let tmpLoad = _cpus && _cpus[i] && _cpus[i].totalLoad ? _cpus[i].totalLoad : 0;
              let tmpUser = _cpus && _cpus[i] && _cpus[i].user ? _cpus[i].user : 0;
              let tmpSystem = _cpus && _cpus[i] && _cpus[i].sys ? _cpus[i].sys : 0;
              let tmpNice = _cpus && _cpus[i] && _cpus[i].nice ? _cpus[i].nice : 0;
              let tmpIdle = _cpus && _cpus[i] && _cpus[i].idle ? _cpus[i].idle : 0;
              let tmpIrq = _cpus && _cpus[i] && _cpus[i].irq ? _cpus[i].irq : 0;
              let tmpSteal = _cpus && _cpus[i] && _cpus[i].steal ? _cpus[i].steal : 0;
              let tmpGuest = _cpus && _cpus[i] && _cpus[i].guest ? _cpus[i].guest : 0;
              _cpus[i] = cpu2;
              _cpus[i].totalTick = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].steal + _cpus[i].guest + _cpus[i].idle;
              _cpus[i].totalLoad = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].steal + _cpus[i].guest;
              _cpus[i].currentTick = _cpus[i].totalTick - tmpTick;
              _cpus[i].load = _cpus[i].totalLoad - tmpLoad;
              _cpus[i].loadUser = _cpus[i].user - tmpUser;
              _cpus[i].loadSystem = _cpus[i].sys - tmpSystem;
              _cpus[i].loadNice = _cpus[i].nice - tmpNice;
              _cpus[i].loadIdle = _cpus[i].idle - tmpIdle;
              _cpus[i].loadIrq = _cpus[i].irq - tmpIrq;
              _cpus[i].loadSteal = _cpus[i].steal - tmpSteal;
              _cpus[i].loadGuest = _cpus[i].guest - tmpGuest;
              cores[i] = {};
              cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;
              cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;
              cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;
              cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;
              cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;
              cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;
              cores[i].loadSteal = _cpus[i].loadSteal / _cpus[i].currentTick * 100;
              cores[i].loadGuest = _cpus[i].loadGuest / _cpus[i].currentTick * 100;
              cores[i].rawLoad = _cpus[i].load;
              cores[i].rawLoadUser = _cpus[i].loadUser;
              cores[i].rawLoadSystem = _cpus[i].loadSystem;
              cores[i].rawLoadNice = _cpus[i].loadNice;
              cores[i].rawLoadIdle = _cpus[i].loadIdle;
              cores[i].rawLoadIrq = _cpus[i].loadIrq;
              cores[i].rawLoadSteal = _cpus[i].loadSteal;
              cores[i].rawLoadGuest = _cpus[i].loadGuest;
            }
            let totalTick = totalUser + totalSystem + totalNice + totalIrq + totalSteal + totalGuest + totalIdle;
            let totalLoad = totalUser + totalSystem + totalNice + totalIrq + totalSteal + totalGuest;
            let currentTick = totalTick - _current_cpu.tick;
            result = {
              avgLoad,
              currentLoad: (totalLoad - _current_cpu.load) / currentTick * 100,
              currentLoadUser: (totalUser - _current_cpu.user) / currentTick * 100,
              currentLoadSystem: (totalSystem - _current_cpu.system) / currentTick * 100,
              currentLoadNice: (totalNice - _current_cpu.nice) / currentTick * 100,
              currentLoadIdle: (totalIdle - _current_cpu.idle) / currentTick * 100,
              currentLoadIrq: (totalIrq - _current_cpu.irq) / currentTick * 100,
              currentLoadSteal: (totalSteal - _current_cpu.steal) / currentTick * 100,
              currentLoadGuest: (totalGuest - _current_cpu.guest) / currentTick * 100,
              rawCurrentLoad: totalLoad - _current_cpu.load,
              rawCurrentLoadUser: totalUser - _current_cpu.user,
              rawCurrentLoadSystem: totalSystem - _current_cpu.system,
              rawCurrentLoadNice: totalNice - _current_cpu.nice,
              rawCurrentLoadIdle: totalIdle - _current_cpu.idle,
              rawCurrentLoadIrq: totalIrq - _current_cpu.irq,
              rawCurrentLoadSteal: totalSteal - _current_cpu.steal,
              rawCurrentLoadGuest: totalGuest - _current_cpu.guest,
              cpus: cores
            };
            _current_cpu = {
              user: totalUser,
              nice: totalNice,
              system: totalSystem,
              idle: totalIdle,
              irq: totalIrq,
              steal: totalSteal,
              guest: totalGuest,
              tick: totalTick,
              load: totalLoad,
              ms: _current_cpu.ms,
              currentLoad: result.currentLoad,
              currentLoadUser: result.currentLoadUser,
              currentLoadSystem: result.currentLoadSystem,
              currentLoadNice: result.currentLoadNice,
              currentLoadIdle: result.currentLoadIdle,
              currentLoadIrq: result.currentLoadIrq,
              currentLoadSteal: result.currentLoadSteal,
              currentLoadGuest: result.currentLoadGuest,
              rawCurrentLoad: result.rawCurrentLoad,
              rawCurrentLoadUser: result.rawCurrentLoadUser,
              rawCurrentLoadSystem: result.rawCurrentLoadSystem,
              rawCurrentLoadNice: result.rawCurrentLoadNice,
              rawCurrentLoadIdle: result.rawCurrentLoadIdle,
              rawCurrentLoadIrq: result.rawCurrentLoadIrq,
              rawCurrentLoadSteal: result.rawCurrentLoadSteal,
              rawCurrentLoadGuest: result.rawCurrentLoadGuest
            };
          } else {
            let cores = [];
            for (let i = 0; i < _corecount; i++) {
              cores[i] = {};
              cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;
              cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;
              cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;
              cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;
              cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;
              cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;
              cores[i].rawLoad = _cpus[i].load;
              cores[i].rawLoadUser = _cpus[i].loadUser;
              cores[i].rawLoadSystem = _cpus[i].loadSystem;
              cores[i].rawLoadNice = _cpus[i].loadNice;
              cores[i].rawLoadIdle = _cpus[i].loadIdle;
              cores[i].rawLoadIrq = _cpus[i].loadIrq;
              cores[i].rawLoadSteal = _cpus[i].loadSteal;
              cores[i].rawLoadGuest = _cpus[i].loadGuest;
            }
            result = {
              avgLoad,
              currentLoad: _current_cpu.currentLoad,
              currentLoadUser: _current_cpu.currentLoadUser,
              currentLoadSystem: _current_cpu.currentLoadSystem,
              currentLoadNice: _current_cpu.currentLoadNice,
              currentLoadIdle: _current_cpu.currentLoadIdle,
              currentLoadIrq: _current_cpu.currentLoadIrq,
              currentLoadSteal: _current_cpu.currentLoadSteal,
              currentLoadGuest: _current_cpu.currentLoadGuest,
              rawCurrentLoad: _current_cpu.rawCurrentLoad,
              rawCurrentLoadUser: _current_cpu.rawCurrentLoadUser,
              rawCurrentLoadSystem: _current_cpu.rawCurrentLoadSystem,
              rawCurrentLoadNice: _current_cpu.rawCurrentLoadNice,
              rawCurrentLoadIdle: _current_cpu.rawCurrentLoadIdle,
              rawCurrentLoadIrq: _current_cpu.rawCurrentLoadIrq,
              rawCurrentLoadSteal: _current_cpu.rawCurrentLoadSteal,
              rawCurrentLoadGuest: _current_cpu.rawCurrentLoadGuest,
              cpus: cores
            };
          }
          resolve(result);
        });
      });
    }
    function currentLoad(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          getLoad().then((result) => {
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        });
      });
    }
    exports.currentLoad = currentLoad;
    function getFullLoad() {
      return new Promise((resolve) => {
        process.nextTick(() => {
          const cpus = os2.cpus();
          let totalUser = 0;
          let totalSystem = 0;
          let totalNice = 0;
          let totalIrq = 0;
          let totalIdle = 0;
          let result = 0;
          if (cpus && cpus.length) {
            for (let i = 0, len = cpus.length; i < len; i++) {
              const cpu2 = cpus[i].times;
              totalUser += cpu2.user;
              totalSystem += cpu2.sys;
              totalNice += cpu2.nice;
              totalIrq += cpu2.irq;
              totalIdle += cpu2.idle;
            }
            let totalTicks = totalIdle + totalIrq + totalNice + totalSystem + totalUser;
            result = (totalTicks - totalIdle) / totalTicks * 100;
          }
          resolve(result);
        });
      });
    }
    function fullLoad(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          getFullLoad().then((result) => {
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        });
      });
    }
    exports.fullLoad = fullLoad;
  }
});

// node_modules/systeminformation/lib/memory.js
var require_memory = __commonJS({
  "node_modules/systeminformation/lib/memory.js"(exports) {
    "use strict";
    var os2 = require("os");
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util = require_util2();
    var fs = require("fs");
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var OSX_RAM_manufacturers = {
      "0x014F": "Transcend Information",
      "0x2C00": "Micron Technology Inc.",
      "0x802C": "Micron Technology Inc.",
      "0x80AD": "Hynix Semiconductor Inc.",
      "0x80CE": "Samsung Electronics Inc.",
      "0xAD00": "Hynix Semiconductor Inc.",
      "0xCE00": "Samsung Electronics Inc.",
      "0x02FE": "Elpida",
      "0x5105": "Qimonda AG i. In.",
      "0x8551": "Qimonda AG i. In.",
      "0x859B": "Crucial",
      "0x04CD": "G-Skill"
    };
    var LINUX_RAM_manufacturers = {
      "017A": "Apacer",
      "0198": "HyperX",
      "029E": "Corsair",
      "04CB": "A-DATA",
      "04CD": "G-Skill",
      "059B": "Crucial",
      "00CE": "Samsung",
      "1315": "Crucial",
      "014F": "Transcend Information",
      "2C00": "Micron Technology Inc.",
      "802C": "Micron Technology Inc.",
      "80AD": "Hynix Semiconductor Inc.",
      "80CE": "Samsung Electronics Inc.",
      "AD00": "Hynix Semiconductor Inc.",
      "CE00": "Samsung Electronics Inc.",
      "02FE": "Elpida",
      "5105": "Qimonda AG i. In.",
      "8551": "Qimonda AG i. In.",
      "859B": "Crucial"
    };
    function mem(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            total: os2.totalmem(),
            free: os2.freemem(),
            used: os2.totalmem() - os2.freemem(),
            active: os2.totalmem() - os2.freemem(),
            // temporarily (fallback)
            available: os2.freemem(),
            // temporarily (fallback)
            buffers: 0,
            cached: 0,
            slab: 0,
            buffcache: 0,
            swaptotal: 0,
            swapused: 0,
            swapfree: 0,
            writeback: null,
            dirty: null
          };
          if (_linux) {
            try {
              fs.readFile("/proc/meminfo", function(error, stdout) {
                if (!error) {
                  const lines = stdout.toString().split("\n");
                  result.total = parseInt(util.getValue(lines, "memtotal"), 10);
                  result.total = result.total ? result.total * 1024 : os2.totalmem();
                  result.free = parseInt(util.getValue(lines, "memfree"), 10);
                  result.free = result.free ? result.free * 1024 : os2.freemem();
                  result.used = result.total - result.free;
                  result.buffers = parseInt(util.getValue(lines, "buffers"), 10);
                  result.buffers = result.buffers ? result.buffers * 1024 : 0;
                  result.cached = parseInt(util.getValue(lines, "cached"), 10);
                  result.cached = result.cached ? result.cached * 1024 : 0;
                  result.slab = parseInt(util.getValue(lines, "slab"), 10);
                  result.slab = result.slab ? result.slab * 1024 : 0;
                  result.buffcache = result.buffers + result.cached + result.slab;
                  let available = parseInt(util.getValue(lines, "memavailable"), 10);
                  result.available = available ? available * 1024 : result.free + result.buffcache;
                  result.active = result.total - result.available;
                  result.swaptotal = parseInt(util.getValue(lines, "swaptotal"), 10);
                  result.swaptotal = result.swaptotal ? result.swaptotal * 1024 : 0;
                  result.swapfree = parseInt(util.getValue(lines, "swapfree"), 10);
                  result.swapfree = result.swapfree ? result.swapfree * 1024 : 0;
                  result.swapused = result.swaptotal - result.swapfree;
                  result.writeback = parseInt(util.getValue(lines, "writeback"), 10);
                  result.writeback = result.writeback ? result.writeback * 1024 : 0;
                  result.dirty = parseInt(util.getValue(lines, "dirty"), 10);
                  result.dirty = result.dirty ? result.dirty * 1024 : 0;
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            try {
              exec2("/sbin/sysctl hw.realmem hw.physmem vm.stats.vm.v_page_count vm.stats.vm.v_wire_count vm.stats.vm.v_active_count vm.stats.vm.v_inactive_count vm.stats.vm.v_cache_count vm.stats.vm.v_free_count vm.stats.vm.v_page_size", function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  const pagesize = parseInt(util.getValue(lines, "vm.stats.vm.v_page_size"), 10);
                  const inactive = parseInt(util.getValue(lines, "vm.stats.vm.v_inactive_count"), 10) * pagesize;
                  const cache = parseInt(util.getValue(lines, "vm.stats.vm.v_cache_count"), 10) * pagesize;
                  result.total = parseInt(util.getValue(lines, "hw.realmem"), 10);
                  if (isNaN(result.total)) {
                    result.total = parseInt(util.getValue(lines, "hw.physmem"), 10);
                  }
                  result.free = parseInt(util.getValue(lines, "vm.stats.vm.v_free_count"), 10) * pagesize;
                  result.buffcache = inactive + cache;
                  result.available = result.buffcache + result.free;
                  result.active = result.total - result.free - result.buffcache;
                  result.swaptotal = 0;
                  result.swapfree = 0;
                  result.swapused = 0;
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_darwin) {
            let pageSize = 4096;
            try {
              let sysPpageSize = util.toInt(execSync("sysctl -n vm.pagesize").toString());
              pageSize = sysPpageSize || pageSize;
            } catch (e) {
              util.noop();
            }
            try {
              exec2('vm_stat 2>/dev/null | grep "Pages active"', function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  result.active = parseInt(lines[0].split(":")[1], 10) * pageSize;
                  result.buffcache = result.used - result.active;
                  result.available = result.free + result.buffcache;
                }
                exec2("sysctl -n vm.swapusage 2>/dev/null", function(error2, stdout2) {
                  if (!error2) {
                    let lines = stdout2.toString().split("\n");
                    if (lines.length > 0) {
                      let firstline = lines[0].replace(/,/g, ".").replace(/M/g, "");
                      let lineArray = firstline.trim().split("  ");
                      lineArray.forEach((line) => {
                        if (line.toLowerCase().indexOf("total") !== -1) {
                          result.swaptotal = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                        }
                        if (line.toLowerCase().indexOf("used") !== -1) {
                          result.swapused = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                        }
                        if (line.toLowerCase().indexOf("free") !== -1) {
                          result.swapfree = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                        }
                      });
                    }
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_windows) {
            let swaptotal = 0;
            let swapused = 0;
            try {
              util.powerShell("Get-CimInstance Win32_PageFileUsage | Select AllocatedBaseSize, CurrentUsage").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                  lines.forEach(function(line) {
                    if (line !== "") {
                      line = line.trim().split(/\s\s+/);
                      swaptotal = swaptotal + (parseInt(line[0], 10) || 0);
                      swapused = swapused + (parseInt(line[1], 10) || 0);
                    }
                  });
                }
                result.swaptotal = swaptotal * 1024 * 1024;
                result.swapused = swapused * 1024 * 1024;
                result.swapfree = result.swaptotal - result.swapused;
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.mem = mem;
    function memLayout(callback) {
      function getManufacturerDarwin(manId) {
        if ({}.hasOwnProperty.call(OSX_RAM_manufacturers, manId)) {
          return OSX_RAM_manufacturers[manId];
        }
        return manId;
      }
      function getManufacturerLinux(manId) {
        const manIdSearch = manId.replace("0x", "").toUpperCase();
        if (manIdSearch.length === 4 && {}.hasOwnProperty.call(LINUX_RAM_manufacturers, manIdSearch)) {
          return LINUX_RAM_manufacturers[manIdSearch];
        }
        return manId;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = [];
          if (_linux || _freebsd || _openbsd || _netbsd) {
            exec2('export LC_ALL=C; dmidecode -t memory 2>/dev/null | grep -iE "Size:|Type|Speed|Manufacturer|Form Factor|Locator|Memory Device|Serial Number|Voltage|Part Number"; unset LC_ALL', function(error, stdout) {
              if (!error) {
                let devices = stdout.toString().split("Memory Device");
                devices.shift();
                devices.forEach(function(device) {
                  let lines = device.split("\n");
                  const sizeString = util.getValue(lines, "Size");
                  const size = sizeString.indexOf("GB") >= 0 ? parseInt(sizeString, 10) * 1024 * 1024 * 1024 : parseInt(sizeString, 10) * 1024 * 1024;
                  let bank = util.getValue(lines, "Bank Locator");
                  if (bank.toLowerCase().indexOf("bad") >= 0) {
                    bank = "";
                  }
                  if (parseInt(util.getValue(lines, "Size"), 10) > 0) {
                    const totalWidth = util.toInt(util.getValue(lines, "Total Width"));
                    const dataWidth = util.toInt(util.getValue(lines, "Data Width"));
                    result.push({
                      size,
                      bank,
                      type: util.getValue(lines, "Type:"),
                      ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,
                      clockSpeed: util.getValue(lines, "Configured Clock Speed:") ? parseInt(util.getValue(lines, "Configured Clock Speed:"), 10) : util.getValue(lines, "Speed:") ? parseInt(util.getValue(lines, "Speed:"), 10) : null,
                      formFactor: util.getValue(lines, "Form Factor:"),
                      manufacturer: getManufacturerLinux(util.getValue(lines, "Manufacturer:")),
                      partNum: util.getValue(lines, "Part Number:"),
                      serialNum: util.getValue(lines, "Serial Number:"),
                      voltageConfigured: parseFloat(util.getValue(lines, "Configured Voltage:")) || null,
                      voltageMin: parseFloat(util.getValue(lines, "Minimum Voltage:")) || null,
                      voltageMax: parseFloat(util.getValue(lines, "Maximum Voltage:")) || null
                    });
                  } else {
                    result.push({
                      size: 0,
                      bank,
                      type: "Empty",
                      ecc: null,
                      clockSpeed: 0,
                      formFactor: util.getValue(lines, "Form Factor:"),
                      partNum: "",
                      serialNum: "",
                      voltageConfigured: null,
                      voltageMin: null,
                      voltageMax: null
                    });
                  }
                });
              }
              if (!result.length) {
                result.push({
                  size: os2.totalmem(),
                  bank: "",
                  type: "",
                  ecc: null,
                  clockSpeed: 0,
                  formFactor: "",
                  partNum: "",
                  serialNum: "",
                  voltageConfigured: null,
                  voltageMin: null,
                  voltageMax: null
                });
                try {
                  let stdout2 = execSync("cat /proc/cpuinfo 2>/dev/null", util.execOptsLinux);
                  let lines = stdout2.toString().split("\n");
                  let model = util.getValue(lines, "hardware", ":", true).toUpperCase();
                  let version = util.getValue(lines, "revision", ":", true).toLowerCase();
                  if (model === "BCM2835" || model === "BCM2708" || model === "BCM2709" || model === "BCM2835" || model === "BCM2837") {
                    const clockSpeed = {
                      "0": 400,
                      "1": 450,
                      "2": 450,
                      "3": 3200
                    };
                    result[0].type = "LPDDR2";
                    result[0].type = version && version[2] && version[2] === "3" ? "LPDDR4" : result[0].type;
                    result[0].ecc = false;
                    result[0].clockSpeed = version && version[2] && clockSpeed[version[2]] || 400;
                    result[0].clockSpeed = version && version[4] && version[4] === "d" ? 500 : result[0].clockSpeed;
                    result[0].formFactor = "SoC";
                    stdout2 = execSync("vcgencmd get_config sdram_freq 2>/dev/null", util.execOptsLinux);
                    lines = stdout2.toString().split("\n");
                    let freq = parseInt(util.getValue(lines, "sdram_freq", "=", true), 10) || 0;
                    if (freq) {
                      result[0].clockSpeed = freq;
                    }
                    stdout2 = execSync("vcgencmd measure_volts sdram_p 2>/dev/null", util.execOptsLinux);
                    lines = stdout2.toString().split("\n");
                    let voltage = parseFloat(util.getValue(lines, "volt", "=", true)) || 0;
                    if (voltage) {
                      result[0].voltageConfigured = voltage;
                      result[0].voltageMin = voltage;
                      result[0].voltageMax = voltage;
                    }
                  }
                } catch (e) {
                  util.noop();
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2("system_profiler SPMemoryDataType", function(error, stdout) {
              if (!error) {
                const allLines = stdout.toString().split("\n");
                const eccStatus = util.getValue(allLines, "ecc", ":", true).toLowerCase();
                let devices = stdout.toString().split("        BANK ");
                let hasBank = true;
                if (devices.length === 1) {
                  devices = stdout.toString().split("        DIMM");
                  hasBank = false;
                }
                devices.shift();
                devices.forEach(function(device) {
                  let lines = device.split("\n");
                  const bank = (hasBank ? "BANK " : "DIMM") + lines[0].trim().split("/")[0];
                  const size = parseInt(util.getValue(lines, "          Size"));
                  if (size) {
                    result.push({
                      size: size * 1024 * 1024 * 1024,
                      bank,
                      type: util.getValue(lines, "          Type:"),
                      ecc: eccStatus ? eccStatus === "enabled" : null,
                      clockSpeed: parseInt(util.getValue(lines, "          Speed:"), 10),
                      formFactor: "",
                      manufacturer: getManufacturerDarwin(util.getValue(lines, "          Manufacturer:")),
                      partNum: util.getValue(lines, "          Part Number:"),
                      serialNum: util.getValue(lines, "          Serial Number:"),
                      voltageConfigured: null,
                      voltageMin: null,
                      voltageMax: null
                    });
                  } else {
                    result.push({
                      size: 0,
                      bank,
                      type: "Empty",
                      ecc: null,
                      clockSpeed: 0,
                      formFactor: "",
                      manufacturer: "",
                      partNum: "",
                      serialNum: "",
                      voltageConfigured: null,
                      voltageMin: null,
                      voltageMax: null
                    });
                  }
                });
              }
              if (!result.length) {
                const lines = stdout.toString().split("\n");
                const size = parseInt(util.getValue(lines, "      Memory:"));
                const type = util.getValue(lines, "      Type:");
                if (size && type) {
                  result.push({
                    size: size * 1024 * 1024 * 1024,
                    bank: "0",
                    type,
                    ecc: false,
                    clockSpeed: 0,
                    formFactor: "",
                    manufacturer: "Apple",
                    partNum: "",
                    serialNum: "",
                    voltageConfigured: null,
                    voltageMin: null,
                    voltageMax: null
                  });
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            const memoryTypes = "Unknown|Other|DRAM|Synchronous DRAM|Cache DRAM|EDO|EDRAM|VRAM|SRAM|RAM|ROM|FLASH|EEPROM|FEPROM|EPROM|CDRAM|3DRAM|SDRAM|SGRAM|RDRAM|DDR|DDR2|DDR2 FB-DIMM|Reserved|DDR3|FBD2|DDR4|LPDDR|LPDDR2|LPDDR3|LPDDR4|Logical non-volatile device|HBM|HBM2|DDR5|LPDDR5".split("|");
            const FormFactors = "Unknown|Other|SIP|DIP|ZIP|SOJ|Proprietary|SIMM|DIMM|TSOP|PGA|RIMM|SODIMM|SRIMM|SMD|SSMP|QFP|TQFP|SOIC|LCC|PLCC|BGA|FPBGA|LGA".split("|");
            try {
              util.powerShell("Get-CimInstance Win32_PhysicalMemory | select DataWidth,TotalWidth,Capacity,BankLabel,MemoryType,SMBIOSMemoryType,ConfiguredClockSpeed,FormFactor,Manufacturer,PartNumber,SerialNumber,ConfiguredVoltage,MinVoltage,MaxVoltage,Tag | fl").then((stdout, error) => {
                if (!error) {
                  let devices = stdout.toString().split(/\n\s*\n/);
                  devices.shift();
                  devices.forEach(function(device) {
                    let lines = device.split("\r\n");
                    const dataWidth = util.toInt(util.getValue(lines, "DataWidth", ":"));
                    const totalWidth = util.toInt(util.getValue(lines, "TotalWidth", ":"));
                    const size = parseInt(util.getValue(lines, "Capacity", ":"), 10) || 0;
                    const tag = util.getValue(lines, "Tag", ":");
                    const tagInt = util.splitByNumber(tag);
                    if (size) {
                      result.push({
                        size,
                        bank: util.getValue(lines, "BankLabel", ":") + (tagInt[1] ? "/" + tagInt[1] : ""),
                        // BankLabel
                        type: memoryTypes[parseInt(util.getValue(lines, "MemoryType", ":"), 10) || parseInt(util.getValue(lines, "SMBIOSMemoryType", ":"), 10)],
                        ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,
                        clockSpeed: parseInt(util.getValue(lines, "ConfiguredClockSpeed", ":"), 10) || parseInt(util.getValue(lines, "Speed", ":"), 10) || 0,
                        formFactor: FormFactors[parseInt(util.getValue(lines, "FormFactor", ":"), 10) || 0],
                        manufacturer: util.getValue(lines, "Manufacturer", ":"),
                        partNum: util.getValue(lines, "PartNumber", ":"),
                        serialNum: util.getValue(lines, "SerialNumber", ":"),
                        voltageConfigured: (parseInt(util.getValue(lines, "ConfiguredVoltage", ":"), 10) || 0) / 1e3,
                        voltageMin: (parseInt(util.getValue(lines, "MinVoltage", ":"), 10) || 0) / 1e3,
                        voltageMax: (parseInt(util.getValue(lines, "MaxVoltage", ":"), 10) || 0) / 1e3
                      });
                    }
                  });
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.memLayout = memLayout;
  }
});

// node_modules/systeminformation/lib/battery.js
var require_battery = __commonJS({
  "node_modules/systeminformation/lib/battery.js"(exports, module2) {
    "use strict";
    var exec2 = require("child_process").exec;
    var fs = require("fs");
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity) {
      const result = {};
      let status = util.getValue(lines, "BatteryStatus", ":").trim();
      if (status >= 0) {
        const statusValue = status ? parseInt(status) : 0;
        result.status = statusValue;
        result.hasBattery = true;
        result.maxCapacity = fullChargeCapacity || parseInt(util.getValue(lines, "DesignCapacity", ":") || 0);
        result.designedCapacity = parseInt(util.getValue(lines, "DesignCapacity", ":") || designedCapacity);
        result.voltage = parseInt(util.getValue(lines, "DesignVoltage", ":") || 0) / 1e3;
        result.capacityUnit = "mWh";
        result.percent = parseInt(util.getValue(lines, "EstimatedChargeRemaining", ":") || 0);
        result.currentCapacity = parseInt(result.maxCapacity * result.percent / 100);
        result.isCharging = statusValue >= 6 && statusValue <= 9 || statusValue === 11 || statusValue !== 3 && statusValue !== 1 && result.percent < 100;
        result.acConnected = result.isCharging || statusValue === 2;
        result.model = util.getValue(lines, "DeviceID", ":");
      } else {
        result.status = -1;
      }
      return result;
    }
    module2.exports = function(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            hasBattery: false,
            cycleCount: 0,
            isCharging: false,
            designedCapacity: 0,
            maxCapacity: 0,
            currentCapacity: 0,
            voltage: 0,
            capacityUnit: "",
            percent: 0,
            timeRemaining: null,
            acConnected: true,
            type: "",
            model: "",
            manufacturer: "",
            serial: ""
          };
          if (_linux) {
            let battery_path = "";
            if (fs.existsSync("/sys/class/power_supply/BAT1/uevent")) {
              battery_path = "/sys/class/power_supply/BAT1/";
            } else if (fs.existsSync("/sys/class/power_supply/BAT0/uevent")) {
              battery_path = "/sys/class/power_supply/BAT0/";
            }
            let acConnected = false;
            let acPath = "";
            if (fs.existsSync("/sys/class/power_supply/AC/online")) {
              acPath = "/sys/class/power_supply/AC/online";
            } else if (fs.existsSync("/sys/class/power_supply/AC0/online")) {
              acPath = "/sys/class/power_supply/AC0/online";
            }
            if (acPath) {
              const file = fs.readFileSync(acPath);
              acConnected = file.toString().trim() === "1";
            }
            if (battery_path) {
              fs.readFile(battery_path + "uevent", function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  result.isCharging = util.getValue(lines, "POWER_SUPPLY_STATUS", "=").toLowerCase() === "charging";
                  result.acConnected = acConnected || result.isCharging;
                  result.voltage = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_VOLTAGE_NOW", "="), 10) / 1e6;
                  result.capacityUnit = result.voltage ? "mWh" : "mAh";
                  result.cycleCount = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CYCLE_COUNT", "="), 10);
                  result.maxCapacity = Math.round(parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_FULL", "=", true, true), 10) / 1e3 * (result.voltage || 1));
                  const desingedMinVoltage = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_VOLTAGE_MIN_DESIGN", "="), 10) / 1e6;
                  result.designedCapacity = Math.round(parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_FULL_DESIGN", "=", true, true), 10) / 1e3 * (desingedMinVoltage || result.voltage || 1));
                  result.currentCapacity = Math.round(parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_NOW", "="), 10) / 1e3 * (result.voltage || 1));
                  if (!result.maxCapacity) {
                    result.maxCapacity = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_FULL", "=", true, true), 10) / 1e3;
                    result.designedCapacity = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_FULL_DESIGN", "=", true, true), 10) / 1e3 | result.maxCapacity;
                    result.currentCapacity = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_NOW", "="), 10) / 1e3;
                  }
                  const percent = util.getValue(lines, "POWER_SUPPLY_CAPACITY", "=");
                  const energy = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_ENERGY_NOW", "="), 10);
                  const power = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_POWER_NOW", "="), 10);
                  const current = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CURRENT_NOW", "="), 10);
                  const charge = parseInt("0" + util.getValue(lines, "POWER_SUPPLY_CHARGE_NOW", "="), 10);
                  result.percent = parseInt("0" + percent, 10);
                  if (result.maxCapacity && result.currentCapacity) {
                    result.hasBattery = true;
                    if (!percent) {
                      result.percent = 100 * result.currentCapacity / result.maxCapacity;
                    }
                  }
                  if (result.isCharging) {
                    result.hasBattery = true;
                  }
                  if (energy && power) {
                    result.timeRemaining = Math.floor(energy / power * 60);
                  } else if (current && charge) {
                    result.timeRemaining = Math.floor(charge / current * 60);
                  } else if (current && result.currentCapacity) {
                    result.timeRemaining = Math.floor(result.currentCapacity / current * 60);
                  }
                  result.type = util.getValue(lines, "POWER_SUPPLY_TECHNOLOGY", "=");
                  result.model = util.getValue(lines, "POWER_SUPPLY_MODEL_NAME", "=");
                  result.manufacturer = util.getValue(lines, "POWER_SUPPLY_MANUFACTURER", "=");
                  result.serial = util.getValue(lines, "POWER_SUPPLY_SERIAL_NUMBER", "=");
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2("sysctl -i hw.acpi.battery hw.acpi.acline", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              const batteries = parseInt("0" + util.getValue(lines, "hw.acpi.battery.units"), 10);
              const percent = parseInt("0" + util.getValue(lines, "hw.acpi.battery.life"), 10);
              result.hasBattery = batteries > 0;
              result.cycleCount = null;
              result.isCharging = util.getValue(lines, "hw.acpi.acline") !== "1";
              result.acConnected = result.isCharging;
              result.maxCapacity = null;
              result.currentCapacity = null;
              result.capacityUnit = "unknown";
              result.percent = batteries ? percent : null;
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2('ioreg -n AppleSmartBattery -r | egrep "CycleCount|IsCharging|DesignCapacity|MaxCapacity|CurrentCapacity|BatterySerialNumber|TimeRemaining|Voltage"; pmset -g batt | grep %', function(error, stdout) {
              if (stdout) {
                let lines = stdout.toString().replace(/ +/g, "").replace(/"+/g, "").replace(/-/g, "").split("\n");
                result.cycleCount = parseInt("0" + util.getValue(lines, "cyclecount", "="), 10);
                result.voltage = parseInt("0" + util.getValue(lines, "voltage", "="), 10) / 1e3;
                result.capacityUnit = result.voltage ? "mWh" : "mAh";
                result.maxCapacity = Math.round(parseInt("0" + util.getValue(lines, "applerawmaxcapacity", "="), 10) * (result.voltage || 1));
                result.currentCapacity = Math.round(parseInt("0" + util.getValue(lines, "applerawcurrentcapacity", "="), 10) * (result.voltage || 1));
                result.designedCapacity = Math.round(parseInt("0" + util.getValue(lines, "DesignCapacity", "="), 10) * (result.voltage || 1));
                result.manufacturer = "Apple";
                result.serial = util.getValue(lines, "BatterySerialNumber", "=");
                let percent = null;
                const line = util.getValue(lines, "internal", "Battery");
                let parts = line.split(";");
                if (parts && parts[0]) {
                  let parts2 = parts[0].split("	");
                  if (parts2 && parts2[1]) {
                    percent = parseFloat(parts2[1].trim().replace(/%/g, ""));
                  }
                }
                if (parts && parts[1]) {
                  result.isCharging = parts[1].trim() === "charging";
                  result.acConnected = parts[1].trim() !== "discharging";
                } else {
                  result.isCharging = util.getValue(lines, "ischarging", "=").toLowerCase() === "yes";
                  result.acConnected = result.isCharging;
                }
                if (result.maxCapacity && result.currentCapacity) {
                  result.hasBattery = true;
                  result.type = "Li-ion";
                  result.percent = percent !== null ? percent : Math.round(100 * result.currentCapacity / result.maxCapacity);
                  if (!result.isCharging) {
                    result.timeRemaining = parseInt("0" + util.getValue(lines, "TimeRemaining", "="), 10);
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_windows) {
            try {
              const workload = [];
              workload.push(util.powerShell("Get-CimInstance Win32_Battery | select BatteryStatus, DesignCapacity, DesignVoltage, EstimatedChargeRemaining, DeviceID | fl"));
              workload.push(util.powerShell("(Get-WmiObject -Class BatteryStaticData -Namespace ROOT/WMI).DesignedCapacity"));
              workload.push(util.powerShell("(Get-CimInstance -Class BatteryFullChargedCapacity -Namespace ROOT/WMI).FullChargedCapacity"));
              util.promiseAll(
                workload
              ).then((data) => {
                if (data) {
                  let parts = data.results[0].split(/\n\s*\n/);
                  let batteries = [];
                  const hasValue = (value) => /\S/.test(value);
                  for (let i = 0; i < parts.length; i++) {
                    if (hasValue(parts[i]) && (!batteries.length || !hasValue(parts[i - 1]))) {
                      batteries.push([]);
                    }
                    if (hasValue(parts[i])) {
                      batteries[batteries.length - 1].push(parts[i]);
                    }
                  }
                  let designCapacities = data.results[1].split("\r\n").filter((e) => e);
                  let fullChargeCapacities = data.results[2].split("\r\n").filter((e) => e);
                  if (batteries.length) {
                    let first = false;
                    let additionalBatteries = [];
                    for (let i = 0; i < batteries.length; i++) {
                      let lines = batteries[i][0].split("\r\n");
                      const designedCapacity = designCapacities && designCapacities.length >= i + 1 && designCapacities[i] ? util.toInt(designCapacities[i]) : 0;
                      const fullChargeCapacity = fullChargeCapacities && fullChargeCapacities.length >= i + 1 && fullChargeCapacities[i] ? util.toInt(fullChargeCapacities[i]) : 0;
                      const parsed = parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity);
                      if (!first && parsed.status > 0 && parsed.status !== 10) {
                        result.hasBattery = parsed.hasBattery;
                        result.maxCapacity = parsed.maxCapacity;
                        result.designedCapacity = parsed.designedCapacity;
                        result.voltage = parsed.voltage;
                        result.capacityUnit = parsed.capacityUnit;
                        result.percent = parsed.percent;
                        result.currentCapacity = parsed.currentCapacity;
                        result.isCharging = parsed.isCharging;
                        result.acConnected = parsed.acConnected;
                        result.model = parsed.model;
                        first = true;
                      } else if (parsed.status !== -1) {
                        additionalBatteries.push(
                          {
                            hasBattery: parsed.hasBattery,
                            maxCapacity: parsed.maxCapacity,
                            designedCapacity: parsed.designedCapacity,
                            voltage: parsed.voltage,
                            capacityUnit: parsed.capacityUnit,
                            percent: parsed.percent,
                            currentCapacity: parsed.currentCapacity,
                            isCharging: parsed.isCharging,
                            timeRemaining: null,
                            acConnected: parsed.acConnected,
                            model: parsed.model,
                            type: "",
                            manufacturer: "",
                            serial: ""
                          }
                        );
                      }
                    }
                    if (!first && additionalBatteries.length) {
                      result = additionalBatteries[0];
                      additionalBatteries.shift();
                    }
                    if (additionalBatteries.length) {
                      result.additionalBatteries = additionalBatteries;
                    }
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    };
  }
});

// node_modules/systeminformation/lib/graphics.js
var require_graphics = __commonJS({
  "node_modules/systeminformation/lib/graphics.js"(exports) {
    "use strict";
    var fs = require("fs");
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util = require_util2();
    var _platform = process.platform;
    var _nvidiaSmiPath = "";
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _resolutionX = 0;
    var _resolutionY = 0;
    var _pixelDepth = 0;
    var _refreshRate = 0;
    var videoTypes = {
      "-2": "UNINITIALIZED",
      "-1": "OTHER",
      "0": "HD15",
      "1": "SVIDEO",
      "2": "Composite video",
      "3": "Component video",
      "4": "DVI",
      "5": "HDMI",
      "6": "LVDS",
      "8": "D_JPN",
      "9": "SDI",
      "10": "DP",
      "11": "DP embedded",
      "12": "UDI",
      "13": "UDI embedded",
      "14": "SDTVDONGLE",
      "15": "MIRACAST",
      "2147483648": "INTERNAL"
    };
    function getVendorFromModel(model) {
      const manufacturers = [
        { pattern: "^LG.+", manufacturer: "LG" },
        { pattern: "^BENQ.+", manufacturer: "BenQ" },
        { pattern: "^ASUS.+", manufacturer: "Asus" },
        { pattern: "^DELL.+", manufacturer: "Dell" },
        { pattern: "^SAMSUNG.+", manufacturer: "Samsung" },
        { pattern: "^VIEWSON.+", manufacturer: "ViewSonic" },
        { pattern: "^SONY.+", manufacturer: "Sony" },
        { pattern: "^ACER.+", manufacturer: "Acer" },
        { pattern: "^AOC.+", manufacturer: "AOC Monitors" },
        { pattern: "^HP.+", manufacturer: "HP" },
        { pattern: "^EIZO.?", manufacturer: "Eizo" },
        { pattern: "^PHILIPS.?", manufacturer: "Philips" },
        { pattern: "^IIYAMA.?", manufacturer: "Iiyama" },
        { pattern: "^SHARP.?", manufacturer: "Sharp" },
        { pattern: "^NEC.?", manufacturer: "NEC" },
        { pattern: "^LENOVO.?", manufacturer: "Lenovo" },
        { pattern: "COMPAQ.?", manufacturer: "Compaq" },
        { pattern: "APPLE.?", manufacturer: "Apple" },
        { pattern: "INTEL.?", manufacturer: "Intel" },
        { pattern: "AMD.?", manufacturer: "AMD" },
        { pattern: "NVIDIA.?", manufacturer: "NVDIA" }
      ];
      let result = "";
      if (model) {
        model = model.toUpperCase();
        manufacturers.forEach((manufacturer) => {
          const re = RegExp(manufacturer.pattern);
          if (re.test(model)) {
            result = manufacturer.manufacturer;
          }
        });
      }
      return result;
    }
    function getVendorFromId(id) {
      const vendors = {
        "610": "Apple",
        "1e6d": "LG",
        "10ac": "DELL",
        "4dd9": "Sony",
        "38a3": "NEC"
      };
      return vendors[id] || "";
    }
    function vendorToId(str) {
      let result = "";
      str = (str || "").toLowerCase();
      if (str.indexOf("apple") >= 0) {
        result = "0x05ac";
      } else if (str.indexOf("nvidia") >= 0) {
        result = "0x10de";
      } else if (str.indexOf("intel") >= 0) {
        result = "0x8086";
      } else if (str.indexOf("ati") >= 0 || str.indexOf("amd") >= 0) {
        result = "0x1002";
      }
      return result;
    }
    function getMetalVersion(id) {
      const families = {
        "spdisplays_mtlgpufamilymac1": "mac1",
        "spdisplays_mtlgpufamilymac2": "mac2",
        "spdisplays_mtlgpufamilyapple1": "apple1",
        "spdisplays_mtlgpufamilyapple2": "apple2",
        "spdisplays_mtlgpufamilyapple3": "apple3",
        "spdisplays_mtlgpufamilyapple4": "apple4",
        "spdisplays_mtlgpufamilyapple5": "apple5",
        "spdisplays_mtlgpufamilyapple6": "apple6",
        "spdisplays_mtlgpufamilyapple7": "apple7",
        "spdisplays_metalfeaturesetfamily11": "family1_v1",
        "spdisplays_metalfeaturesetfamily12": "family1_v2",
        "spdisplays_metalfeaturesetfamily13": "family1_v3",
        "spdisplays_metalfeaturesetfamily14": "family1_v4",
        "spdisplays_metalfeaturesetfamily21": "family2_v1"
      };
      return families[id] || "";
    }
    function graphics(callback) {
      function parseLinesDarwin(graphicsArr) {
        const res = {
          controllers: [],
          displays: []
        };
        try {
          graphicsArr.forEach(function(item) {
            const bus = (item.sppci_bus || "").indexOf("builtin") > -1 ? "Built-In" : (item.sppci_bus || "").indexOf("pcie") > -1 ? "PCIe" : "";
            const vram = (parseInt(item.spdisplays_vram || "", 10) || 0) * ((item.spdisplays_vram || "").indexOf("GB") > -1 ? 1024 : 1);
            const vramDyn = (parseInt(item.spdisplays_vram_shared || "", 10) || 0) * ((item.spdisplays_vram_shared || "").indexOf("GB") > -1 ? 1024 : 1);
            let metalVersion = getMetalVersion(item.spdisplays_metal || item.spdisplays_metalfamily || "");
            res.controllers.push({
              vendor: getVendorFromModel(item.spdisplays_vendor || "") || item.spdisplays_vendor || "",
              model: item.sppci_model || "",
              bus,
              vramDynamic: bus === "Built-In",
              vram: vram || vramDyn || null,
              deviceId: item["spdisplays_device-id"] || "",
              vendorId: item["spdisplays_vendor-id"] || vendorToId((item["spdisplays_vendor"] || "") + (item.sppci_model || "")),
              external: item.sppci_device_type === "spdisplays_egpu",
              cores: item["sppci_cores"] || null,
              metalVersion
            });
            if (item.spdisplays_ndrvs && item.spdisplays_ndrvs.length) {
              item.spdisplays_ndrvs.forEach(function(displayItem) {
                const connectionType = displayItem["spdisplays_connection_type"] || "";
                const currentResolutionParts = (displayItem["_spdisplays_resolution"] || "").split("@");
                const currentResolution = currentResolutionParts[0].split("x");
                const pixelParts = (displayItem["_spdisplays_pixels"] || "").split("x");
                const pixelDepthString = displayItem["spdisplays_depth"] || "";
                const serial = displayItem["_spdisplays_display-serial-number"] || displayItem["_spdisplays_display-serial-number2"] || null;
                res.displays.push({
                  vendor: getVendorFromId(displayItem["_spdisplays_display-vendor-id"] || "") || getVendorFromModel(displayItem["_name"] || ""),
                  vendorId: displayItem["_spdisplays_display-vendor-id"] || "",
                  model: displayItem["_name"] || "",
                  productionYear: displayItem["_spdisplays_display-year"] || null,
                  serial: serial !== "0" ? serial : null,
                  displayId: displayItem["_spdisplays_displayID"] || null,
                  main: displayItem["spdisplays_main"] ? displayItem["spdisplays_main"] === "spdisplays_yes" : false,
                  builtin: (displayItem["spdisplays_display_type"] || "").indexOf("built-in") > -1,
                  connection: connectionType.indexOf("_internal") > -1 ? "Internal" : connectionType.indexOf("_displayport") > -1 ? "Display Port" : connectionType.indexOf("_hdmi") > -1 ? "HDMI" : null,
                  sizeX: null,
                  sizeY: null,
                  pixelDepth: pixelDepthString === "CGSThirtyBitColor" ? 30 : pixelDepthString === "CGSThirtytwoBitColor" ? 32 : pixelDepthString === "CGSTwentyfourBitColor" ? 24 : null,
                  resolutionX: pixelParts.length > 1 ? parseInt(pixelParts[0], 10) : null,
                  resolutionY: pixelParts.length > 1 ? parseInt(pixelParts[1], 10) : null,
                  currentResX: currentResolution.length > 1 ? parseInt(currentResolution[0], 10) : null,
                  currentResY: currentResolution.length > 1 ? parseInt(currentResolution[1], 10) : null,
                  positionX: 0,
                  positionY: 0,
                  currentRefreshRate: currentResolutionParts.length > 1 ? parseInt(currentResolutionParts[1], 10) : null
                });
              });
            }
          });
          return res;
        } catch (e) {
          return res;
        }
      }
      function parseLinesLinuxControllers(lines) {
        let controllers = [];
        let currentController = {
          vendor: "",
          subVendor: "",
          model: "",
          bus: "",
          busAddress: "",
          vram: null,
          vramDynamic: false,
          pciID: ""
        };
        let isGraphicsController = false;
        let pciIDs = [];
        try {
          pciIDs = execSync('export LC_ALL=C; dmidecode -t 9 2>/dev/null; unset LC_ALL | grep "Bus Address: "', util.execOptsLinux).toString().split("\n");
          for (let i2 = 0; i2 < pciIDs.length; i2++) {
            pciIDs[i2] = pciIDs[i2].replace("Bus Address:", "").replace("0000:", "").trim();
          }
          pciIDs = pciIDs.filter(function(el) {
            return el != null && el;
          });
        } catch (e) {
          util.noop();
        }
        let i = 1;
        lines.forEach((line) => {
          let subsystem = "";
          if (i < lines.length && lines[i]) {
            subsystem = lines[i];
            if (subsystem.indexOf(":") > 0) {
              subsystem = subsystem.split(":")[1];
            }
          }
          if ("" !== line.trim()) {
            if (" " !== line[0] && "	" !== line[0]) {
              let isExternal = pciIDs.indexOf(line.split(" ")[0]) >= 0;
              let vgapos = line.toLowerCase().indexOf(" vga ");
              let _3dcontrollerpos = line.toLowerCase().indexOf("3d controller");
              if (vgapos !== -1 || _3dcontrollerpos !== -1) {
                if (_3dcontrollerpos !== -1 && vgapos === -1) {
                  vgapos = _3dcontrollerpos;
                }
                if (currentController.vendor || currentController.model || currentController.bus || currentController.vram !== null || currentController.vramDynamic) {
                  controllers.push(currentController);
                  currentController = {
                    vendor: "",
                    model: "",
                    bus: "",
                    busAddress: "",
                    vram: null,
                    vramDynamic: false
                  };
                }
                const pciIDCandidate = line.split(" ")[0];
                if (/[\da-fA-F]{2}:[\da-fA-F]{2}\.[\da-fA-F]/.test(pciIDCandidate)) {
                  currentController.busAddress = pciIDCandidate;
                }
                isGraphicsController = true;
                let endpos = line.search(/\[[0-9a-f]{4}:[0-9a-f]{4}]|$/);
                let parts = line.substr(vgapos, endpos - vgapos).split(":");
                currentController.busAddress = line.substr(0, vgapos).trim();
                if (parts.length > 1) {
                  parts[1] = parts[1].trim();
                  if (parts[1].toLowerCase().indexOf("corporation") >= 0) {
                    currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("corporation") + 11).trim();
                    currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("corporation") + 11, 200).split("(")[0].trim();
                    currentController.bus = pciIDs.length > 0 && isExternal ? "PCIe" : "Onboard";
                    currentController.vram = null;
                    currentController.vramDynamic = false;
                  } else if (parts[1].toLowerCase().indexOf(" inc.") >= 0) {
                    if ((parts[1].match(/]/g) || []).length > 1) {
                      currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("]") + 1).trim();
                      currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("]") + 1, 200).trim().split("(")[0].trim();
                    } else {
                      currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(" inc.") + 5).trim();
                      currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(" inc.") + 5, 200).trim().split("(")[0].trim();
                    }
                    currentController.bus = pciIDs.length > 0 && isExternal ? "PCIe" : "Onboard";
                    currentController.vram = null;
                    currentController.vramDynamic = false;
                  } else if (parts[1].toLowerCase().indexOf(" ltd.") >= 0) {
                    if ((parts[1].match(/]/g) || []).length > 1) {
                      currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf("]") + 1).trim();
                      currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf("]") + 1, 200).trim().split("(")[0].trim();
                    } else {
                      currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(" ltd.") + 5).trim();
                      currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(" ltd.") + 5, 200).trim().split("(")[0].trim();
                    }
                  }
                  if (currentController.model && subsystem.indexOf(currentController.model) !== -1) {
                    const subVendor = subsystem.split(currentController.model)[0].trim();
                    if (subVendor) {
                      currentController.subVendor = subVendor;
                    }
                  }
                }
              } else {
                isGraphicsController = false;
              }
            }
            if (isGraphicsController) {
              let parts = line.split(":");
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("devicename") !== -1 && parts[1].toLowerCase().indexOf("onboard") !== -1) {
                currentController.bus = "Onboard";
              }
              if (parts.length > 1 && parts[0].replace(/ +/g, "").toLowerCase().indexOf("region") !== -1 && parts[1].toLowerCase().indexOf("memory") !== -1) {
                let memparts = parts[1].split("=");
                if (memparts.length > 1) {
                  currentController.vram = parseInt(memparts[1]);
                }
              }
            }
          }
          i++;
        });
        if (currentController.vendor || currentController.model || currentController.bus || currentController.busAddress || currentController.vram !== null || currentController.vramDynamic) {
          controllers.push(currentController);
        }
        return controllers;
      }
      function parseLinesLinuxClinfo(controllers, lines) {
        const fieldPattern = /\[([^\]]+)\]\s+(\w+)\s+(.*)/;
        const devices = lines.reduce((devices2, line) => {
          const field = fieldPattern.exec(line.trim());
          if (field) {
            if (!devices2[field[1]]) {
              devices2[field[1]] = {};
            }
            devices2[field[1]][field[2]] = field[3];
          }
          return devices2;
        }, {});
        for (let deviceId in devices) {
          const device = devices[deviceId];
          if (device["CL_DEVICE_TYPE"] === "CL_DEVICE_TYPE_GPU") {
            let busAddress;
            if (device["CL_DEVICE_TOPOLOGY_AMD"]) {
              const bdf = device["CL_DEVICE_TOPOLOGY_AMD"].match(/[a-zA-Z0-9]+:\d+\.\d+/);
              if (bdf) {
                busAddress = bdf[0];
              }
            } else if (device["CL_DEVICE_PCI_BUS_ID_NV"] && device["CL_DEVICE_PCI_SLOT_ID_NV"]) {
              const bus = parseInt(device["CL_DEVICE_PCI_BUS_ID_NV"]);
              const slot = parseInt(device["CL_DEVICE_PCI_SLOT_ID_NV"]);
              if (!isNaN(bus) && !isNaN(slot)) {
                const b = bus & 255;
                const d = slot >> 3 & 255;
                const f = slot & 7;
                busAddress = `${b.toString().padStart(2, "0")}:${d.toString().padStart(2, "0")}.${f}`;
              }
            }
            if (busAddress) {
              let controller = controllers.find((controller2) => controller2.busAddress === busAddress);
              if (!controller) {
                controller = {
                  vendor: "",
                  model: "",
                  bus: "",
                  busAddress,
                  vram: null,
                  vramDynamic: false
                };
                controllers.push(controller);
              }
              controller.vendor = device["CL_DEVICE_VENDOR"];
              if (device["CL_DEVICE_BOARD_NAME_AMD"]) {
                controller.model = device["CL_DEVICE_BOARD_NAME_AMD"];
              } else {
                controller.model = device["CL_DEVICE_NAME"];
              }
              const memory = parseInt(device["CL_DEVICE_GLOBAL_MEM_SIZE"]);
              if (!isNaN(memory)) {
                controller.vram = Math.round(memory / 1024 / 1024);
              }
            }
          }
        }
        return controllers;
      }
      function getNvidiaSmi() {
        if (_nvidiaSmiPath) {
          return _nvidiaSmiPath;
        }
        if (_windows) {
          try {
            const basePath = util.WINDIR + "\\System32\\DriverStore\\FileRepository";
            const candidateDirs = fs.readdirSync(basePath).filter((dir) => {
              return fs.readdirSync([basePath, dir].join("/")).includes("nvidia-smi.exe");
            });
            const targetDir = candidateDirs.reduce((prevDir, currentDir) => {
              const previousNvidiaSmi = fs.statSync([basePath, prevDir, "nvidia-smi.exe"].join("/"));
              const currentNvidiaSmi = fs.statSync([basePath, currentDir, "nvidia-smi.exe"].join("/"));
              return previousNvidiaSmi.ctimeMs > currentNvidiaSmi.ctimeMs ? prevDir : currentDir;
            });
            if (targetDir) {
              _nvidiaSmiPath = [basePath, targetDir, "nvidia-smi.exe"].join("/");
            }
          } catch (e) {
            util.noop();
          }
        } else if (_linux) {
          _nvidiaSmiPath = "nvidia-smi";
        }
        return _nvidiaSmiPath;
      }
      function nvidiaSmi(options) {
        const nvidiaSmiExe = getNvidiaSmi();
        options = options || util.execOptsWin;
        if (nvidiaSmiExe) {
          const nvidiaSmiOpts = "--query-gpu=driver_version,pci.sub_device_id,name,pci.bus_id,fan.speed,memory.total,memory.used,memory.free,utilization.gpu,utilization.memory,temperature.gpu,temperature.memory,power.draw,power.limit,clocks.gr,clocks.mem --format=csv,noheader,nounits";
          const cmd = nvidiaSmiExe + " " + nvidiaSmiOpts + (_linux ? "  2>/dev/null" : "");
          if (_linux) {
            options.stdio = ["pipe", "pipe", "ignore"];
          }
          try {
            const res = execSync(cmd, options).toString();
            return res;
          } catch (e) {
            util.noop();
          }
        }
        return "";
      }
      function nvidiaDevices() {
        function safeParseNumber(value) {
          if ([null, void 0].includes(value)) {
            return value;
          }
          return parseFloat(value);
        }
        const stdout = nvidiaSmi();
        if (!stdout) {
          return [];
        }
        const gpus = stdout.split("\n").filter(Boolean);
        let results = gpus.map((gpu) => {
          const splittedData = gpu.split(", ").map((value) => value.includes("N/A") ? void 0 : value);
          if (splittedData.length === 16) {
            return {
              driverVersion: splittedData[0],
              subDeviceId: splittedData[1],
              name: splittedData[2],
              pciBus: splittedData[3],
              fanSpeed: safeParseNumber(splittedData[4]),
              memoryTotal: safeParseNumber(splittedData[5]),
              memoryUsed: safeParseNumber(splittedData[6]),
              memoryFree: safeParseNumber(splittedData[7]),
              utilizationGpu: safeParseNumber(splittedData[8]),
              utilizationMemory: safeParseNumber(splittedData[9]),
              temperatureGpu: safeParseNumber(splittedData[10]),
              temperatureMemory: safeParseNumber(splittedData[11]),
              powerDraw: safeParseNumber(splittedData[12]),
              powerLimit: safeParseNumber(splittedData[13]),
              clockCore: safeParseNumber(splittedData[14]),
              clockMemory: safeParseNumber(splittedData[15])
            };
          } else {
            return {};
          }
        });
        results = results.filter((item) => {
          return "pciBus" in item;
        });
        return results;
      }
      function mergeControllerNvidia(controller, nvidia) {
        if (nvidia.driverVersion) {
          controller.driverVersion = nvidia.driverVersion;
        }
        if (nvidia.subDeviceId) {
          controller.subDeviceId = nvidia.subDeviceId;
        }
        if (nvidia.name) {
          controller.name = nvidia.name;
        }
        if (nvidia.pciBus) {
          controller.pciBus = nvidia.pciBus;
        }
        if (nvidia.fanSpeed) {
          controller.fanSpeed = nvidia.fanSpeed;
        }
        if (nvidia.memoryTotal) {
          controller.memoryTotal = nvidia.memoryTotal;
          controller.vram = nvidia.memoryTotal;
          controller.vramDynamic = false;
        }
        if (nvidia.memoryUsed) {
          controller.memoryUsed = nvidia.memoryUsed;
        }
        if (nvidia.memoryFree) {
          controller.memoryFree = nvidia.memoryFree;
        }
        if (nvidia.utilizationGpu) {
          controller.utilizationGpu = nvidia.utilizationGpu;
        }
        if (nvidia.utilizationMemory) {
          controller.utilizationMemory = nvidia.utilizationMemory;
        }
        if (nvidia.temperatureGpu) {
          controller.temperatureGpu = nvidia.temperatureGpu;
        }
        if (nvidia.temperatureMemory) {
          controller.temperatureMemory = nvidia.temperatureMemory;
        }
        if (nvidia.powerDraw) {
          controller.powerDraw = nvidia.powerDraw;
        }
        if (nvidia.powerLimit) {
          controller.powerLimit = nvidia.powerLimit;
        }
        if (nvidia.clockCore) {
          controller.clockCore = nvidia.clockCore;
        }
        if (nvidia.clockMemory) {
          controller.clockMemory = nvidia.clockMemory;
        }
        return controller;
      }
      function parseLinesLinuxEdid(edid) {
        let result = {
          vendor: "",
          model: "",
          deviceName: "",
          main: false,
          builtin: false,
          connection: "",
          sizeX: null,
          sizeY: null,
          pixelDepth: null,
          resolutionX: null,
          resolutionY: null,
          currentResX: null,
          currentResY: null,
          positionX: 0,
          positionY: 0,
          currentRefreshRate: null
        };
        let start = 108;
        if (edid.substr(start, 6) === "000000") {
          start += 36;
        }
        if (edid.substr(start, 6) === "000000") {
          start += 36;
        }
        if (edid.substr(start, 6) === "000000") {
          start += 36;
        }
        if (edid.substr(start, 6) === "000000") {
          start += 36;
        }
        result.resolutionX = parseInt("0x0" + edid.substr(start + 8, 1) + edid.substr(start + 4, 2));
        result.resolutionY = parseInt("0x0" + edid.substr(start + 14, 1) + edid.substr(start + 10, 2));
        result.sizeX = parseInt("0x0" + edid.substr(start + 28, 1) + edid.substr(start + 24, 2));
        result.sizeY = parseInt("0x0" + edid.substr(start + 29, 1) + edid.substr(start + 26, 2));
        start = edid.indexOf("000000fc00");
        if (start >= 0) {
          let model_raw = edid.substr(start + 10, 26);
          if (model_raw.indexOf("0a") !== -1) {
            model_raw = model_raw.substr(0, model_raw.indexOf("0a"));
          }
          try {
            if (model_raw.length > 2) {
              result.model = model_raw.match(/.{1,2}/g).map(function(v) {
                return String.fromCharCode(parseInt(v, 16));
              }).join("");
            }
          } catch (e) {
            util.noop();
          }
        } else {
          result.model = "";
        }
        return result;
      }
      function parseLinesLinuxDisplays(lines, depth) {
        let displays = [];
        let currentDisplay = {
          vendor: "",
          model: "",
          deviceName: "",
          main: false,
          builtin: false,
          connection: "",
          sizeX: null,
          sizeY: null,
          pixelDepth: null,
          resolutionX: null,
          resolutionY: null,
          currentResX: null,
          currentResY: null,
          positionX: 0,
          positionY: 0,
          currentRefreshRate: null
        };
        let is_edid = false;
        let is_current = false;
        let edid_raw = "";
        let start = 0;
        for (let i = 1; i < lines.length; i++) {
          if ("" !== lines[i].trim()) {
            if (" " !== lines[i][0] && "	" !== lines[i][0] && lines[i].toLowerCase().indexOf(" connected ") !== -1) {
              if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {
                displays.push(currentDisplay);
                currentDisplay = {
                  vendor: "",
                  model: "",
                  main: false,
                  builtin: false,
                  connection: "",
                  sizeX: null,
                  sizeY: null,
                  pixelDepth: null,
                  resolutionX: null,
                  resolutionY: null,
                  currentResX: null,
                  currentResY: null,
                  positionX: 0,
                  positionY: 0,
                  currentRefreshRate: null
                };
              }
              let parts = lines[i].split(" ");
              currentDisplay.connection = parts[0];
              currentDisplay.main = lines[i].toLowerCase().indexOf(" primary ") >= 0;
              currentDisplay.builtin = parts[0].toLowerCase().indexOf("edp") >= 0;
            }
            if (is_edid) {
              if (lines[i].search(/\S|$/) > start) {
                edid_raw += lines[i].toLowerCase().trim();
              } else {
                let edid_decoded = parseLinesLinuxEdid(edid_raw);
                currentDisplay.vendor = edid_decoded.vendor;
                currentDisplay.model = edid_decoded.model;
                currentDisplay.resolutionX = edid_decoded.resolutionX;
                currentDisplay.resolutionY = edid_decoded.resolutionY;
                currentDisplay.sizeX = edid_decoded.sizeX;
                currentDisplay.sizeY = edid_decoded.sizeY;
                currentDisplay.pixelDepth = depth;
                is_edid = false;
              }
            }
            if (lines[i].toLowerCase().indexOf("edid:") >= 0) {
              is_edid = true;
              start = lines[i].search(/\S|$/);
            }
            if (lines[i].toLowerCase().indexOf("*current") >= 0) {
              const parts1 = lines[i].split("(");
              if (parts1 && parts1.length > 1 && parts1[0].indexOf("x") >= 0) {
                const resParts = parts1[0].trim().split("x");
                currentDisplay.currentResX = util.toInt(resParts[0]);
                currentDisplay.currentResY = util.toInt(resParts[1]);
              }
              is_current = true;
            }
            if (is_current && lines[i].toLowerCase().indexOf("clock") >= 0 && lines[i].toLowerCase().indexOf("hz") >= 0 && lines[i].toLowerCase().indexOf("v: height") >= 0) {
              const parts1 = lines[i].split("clock");
              if (parts1 && parts1.length > 1 && parts1[1].toLowerCase().indexOf("hz") >= 0) {
                currentDisplay.currentRefreshRate = util.toInt(parts1[1]);
              }
              is_current = false;
            }
          }
        }
        if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {
          displays.push(currentDisplay);
        }
        return displays;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            controllers: [],
            displays: []
          };
          if (_darwin) {
            let cmd = "system_profiler -xml -detailLevel full SPDisplaysDataType";
            exec2(cmd, function(error, stdout) {
              if (!error) {
                try {
                  const output = stdout.toString();
                  result = parseLinesDarwin(util.plistParser(output)[0]._items);
                } catch (e) {
                  util.noop();
                }
                try {
                  stdout = execSync('defaults read /Library/Preferences/com.apple.windowserver.plist 2>/dev/null;defaults read /Library/Preferences/com.apple.windowserver.displays.plist 2>/dev/null; echo ""', { maxBuffer: 1024 * 2e4 });
                  const output = (stdout || "").toString();
                  const obj = util.plistReader(output);
                  if (obj["DisplayAnyUserSets"] && obj["DisplayAnyUserSets"]["Configs"] && obj["DisplayAnyUserSets"]["Configs"][0] && obj["DisplayAnyUserSets"]["Configs"][0]["DisplayConfig"]) {
                    const current = obj["DisplayAnyUserSets"]["Configs"][0]["DisplayConfig"];
                    let i = 0;
                    current.forEach((o) => {
                      if (o["CurrentInfo"] && o["CurrentInfo"]["OriginX"] !== void 0 && result.displays && result.displays[i]) {
                        result.displays[i].positionX = o["CurrentInfo"]["OriginX"];
                      }
                      if (o["CurrentInfo"] && o["CurrentInfo"]["OriginY"] !== void 0 && result.displays && result.displays[i]) {
                        result.displays[i].positionY = o["CurrentInfo"]["OriginY"];
                      }
                      i++;
                    });
                  }
                  if (obj["DisplayAnyUserSets"] && obj["DisplayAnyUserSets"].length > 0 && obj["DisplayAnyUserSets"][0].length > 0 && obj["DisplayAnyUserSets"][0][0]["DisplayID"]) {
                    const current = obj["DisplayAnyUserSets"][0];
                    let i = 0;
                    current.forEach((o) => {
                      if ("OriginX" in o && result.displays && result.displays[i]) {
                        result.displays[i].positionX = o["OriginX"];
                      }
                      if ("OriginY" in o && result.displays && result.displays[i]) {
                        result.displays[i].positionY = o["OriginY"];
                      }
                      if (o["Mode"] && o["Mode"]["BitsPerPixel"] !== void 0 && result.displays && result.displays[i]) {
                        result.displays[i].pixelDepth = o["Mode"]["BitsPerPixel"];
                      }
                      i++;
                    });
                  }
                } catch (e) {
                  util.noop();
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_linux) {
            if (util.isRaspberry() && util.isRaspbian()) {
              let cmd = `fbset -s | grep 'mode "'; vcgencmd get_mem gpu; tvservice -s; tvservice -n;`;
              exec2(cmd, function(error, stdout) {
                let lines = stdout.toString().split("\n");
                if (lines.length > 3 && lines[0].indexOf('mode "') >= -1 && lines[2].indexOf("0x12000a") > -1) {
                  const parts = lines[0].replace("mode", "").replace(/"/g, "").trim().split("x");
                  if (parts.length === 2) {
                    result.displays.push({
                      vendor: "",
                      model: util.getValue(lines, "device_name", "="),
                      main: true,
                      builtin: false,
                      connection: "HDMI",
                      sizeX: null,
                      sizeY: null,
                      pixelDepth: null,
                      resolutionX: parseInt(parts[0], 10),
                      resolutionY: parseInt(parts[1], 10),
                      currentResX: null,
                      currentResY: null,
                      positionX: 0,
                      positionY: 0,
                      currentRefreshRate: null
                    });
                  }
                }
                if (lines.length > 1 && stdout.toString().indexOf("gpu=") >= -1) {
                  result.controllers.push({
                    vendor: "Broadcom",
                    model: util.getRpiGpu(),
                    bus: "",
                    vram: util.getValue(lines, "gpu", "=").replace("M", ""),
                    vramDynamic: true
                  });
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } else {
              let cmd = "lspci -vvv  2>/dev/null";
              exec2(cmd, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  result.controllers = parseLinesLinuxControllers(lines);
                  const nvidiaData = nvidiaDevices();
                  result.controllers = result.controllers.map((controller) => {
                    return mergeControllerNvidia(controller, nvidiaData.find((contr) => contr.pciBus.toLowerCase().endsWith(controller.busAddress.toLowerCase())) || {});
                  });
                }
                let cmd2 = "clinfo --raw";
                exec2(cmd2, function(error2, stdout2) {
                  if (!error2) {
                    let lines = stdout2.toString().split("\n");
                    result.controllers = parseLinesLinuxClinfo(result.controllers, lines);
                  }
                  let cmd3 = "xdpyinfo 2>/dev/null | grep 'depth of root window' | awk '{ print $5 }'";
                  exec2(cmd3, function(error3, stdout3) {
                    let depth = 0;
                    if (!error3) {
                      let lines = stdout3.toString().split("\n");
                      depth = parseInt(lines[0]) || 0;
                    }
                    let cmd4 = "xrandr --verbose 2>/dev/null";
                    exec2(cmd4, function(error4, stdout4) {
                      if (!error4) {
                        let lines = stdout4.toString().split("\n");
                        result.displays = parseLinesLinuxDisplays(lines, depth);
                      }
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    });
                  });
                });
              });
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            if (callback) {
              callback(null);
            }
            resolve(null);
          }
          if (_sunos) {
            if (callback) {
              callback(null);
            }
            resolve(null);
          }
          if (_windows) {
            try {
              const workload = [];
              workload.push(util.powerShell("Get-CimInstance win32_VideoController | fl *"));
              workload.push(util.powerShell('gp "HKLM:\\SYSTEM\\ControlSet001\\Control\\Class\\{4d36e968-e325-11ce-bfc1-08002be10318}\\*" -ErrorAction SilentlyContinue | where MatchingDeviceId $null -NE | select MatchingDeviceId,HardwareInformation.qwMemorySize | fl'));
              workload.push(util.powerShell("Get-CimInstance win32_desktopmonitor | fl *"));
              workload.push(util.powerShell("Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorBasicDisplayParams | fl"));
              workload.push(util.powerShell("Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.Screen]::AllScreens"));
              workload.push(util.powerShell("Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorConnectionParams | fl"));
              workload.push(util.powerShell('gwmi WmiMonitorID -Namespace root\\wmi | ForEach-Object {(($_.ManufacturerName -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.ProductCodeID -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.UserFriendlyName -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.SerialNumberID -notmatch 0 | foreach {[char]$_}) -join "") + "|" + $_.InstanceName}'));
              const nvidiaData = nvidiaDevices();
              Promise.all(
                workload
              ).then((data) => {
                let csections = data[0].replace(/\r/g, "").split(/\n\s*\n/);
                let vsections = data[1].replace(/\r/g, "").split(/\n\s*\n/);
                result.controllers = parseLinesWindowsControllers(csections, vsections);
                result.controllers = result.controllers.map((controller) => {
                  if (controller.vendor.toLowerCase() === "nvidia") {
                    return mergeControllerNvidia(controller, nvidiaData.find((device) => {
                      let windowsSubDeviceId = (controller.subDeviceId || "").toLowerCase();
                      const nvidiaSubDeviceIdParts = device.subDeviceId.split("x");
                      let nvidiaSubDeviceId = nvidiaSubDeviceIdParts.length > 1 ? nvidiaSubDeviceIdParts[1].toLowerCase() : nvidiaSubDeviceIdParts[0].toLowerCase();
                      const lengthDifference = Math.abs(windowsSubDeviceId.length - nvidiaSubDeviceId.length);
                      if (windowsSubDeviceId.length > nvidiaSubDeviceId.length) {
                        for (let i = 0; i < lengthDifference; i++) {
                          nvidiaSubDeviceId = "0" + nvidiaSubDeviceId;
                        }
                      } else if (windowsSubDeviceId.length < nvidiaSubDeviceId.length) {
                        for (let i = 0; i < lengthDifference; i++) {
                          windowsSubDeviceId = "0" + windowsSubDeviceId;
                        }
                      }
                      return windowsSubDeviceId === nvidiaSubDeviceId;
                    }) || {});
                  } else {
                    return controller;
                  }
                });
                let dsections = data[2].replace(/\r/g, "").split(/\n\s*\n/);
                if (dsections[0].trim() === "") {
                  dsections.shift();
                }
                if (dsections.length && dsections[dsections.length - 1].trim() === "") {
                  dsections.pop();
                }
                let msections = data[3].replace(/\r/g, "").split("Active ");
                msections.shift();
                let ssections = data[4].replace(/\r/g, "").split("BitsPerPixel ");
                ssections.shift();
                let tsections = data[5].replace(/\r/g, "").split(/\n\s*\n/);
                tsections.shift();
                const res = data[6].replace(/\r/g, "").split(/\n/);
                let isections = [];
                res.forEach((element) => {
                  const parts = element.split("|");
                  if (parts.length === 5) {
                    isections.push({
                      vendor: parts[0],
                      code: parts[1],
                      model: parts[2],
                      serial: parts[3],
                      instanceId: parts[4]
                    });
                  }
                });
                result.displays = parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections);
                if (result.displays.length === 1) {
                  if (_resolutionX) {
                    result.displays[0].resolutionX = _resolutionX;
                    if (!result.displays[0].currentResX) {
                      result.displays[0].currentResX = _resolutionX;
                    }
                  }
                  if (_resolutionY) {
                    result.displays[0].resolutionY = _resolutionY;
                    if (result.displays[0].currentResY === 0) {
                      result.displays[0].currentResY = _resolutionY;
                    }
                  }
                  if (_pixelDepth) {
                    result.displays[0].pixelDepth = _pixelDepth;
                  }
                }
                result.displays = result.displays.map((element) => {
                  if (_refreshRate && !element.currentRefreshRate) {
                    element.currentRefreshRate = _refreshRate;
                  }
                  return element;
                });
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }).catch(() => {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
      function parseLinesWindowsControllers(sections, vections) {
        const memorySizes = {};
        for (const i in vections) {
          if ({}.hasOwnProperty.call(vections, i)) {
            if (vections[i].trim() !== "") {
              const lines = vections[i].trim().split("\n");
              const matchingDeviceId = util.getValue(lines, "MatchingDeviceId").match(/PCI\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);
              if (matchingDeviceId) {
                const quadWordmemorySize = parseInt(util.getValue(lines, "HardwareInformation.qwMemorySize"));
                if (!isNaN(quadWordmemorySize)) {
                  let deviceId = matchingDeviceId[1].toUpperCase() + "&" + matchingDeviceId[2].toUpperCase();
                  if (matchingDeviceId[3]) {
                    deviceId += "&" + matchingDeviceId[3].toUpperCase();
                  }
                  if (matchingDeviceId[4]) {
                    deviceId += "&" + matchingDeviceId[4].toUpperCase();
                  }
                  memorySizes[deviceId] = quadWordmemorySize;
                }
              }
            }
          }
        }
        let controllers = [];
        for (let i in sections) {
          if ({}.hasOwnProperty.call(sections, i)) {
            if (sections[i].trim() !== "") {
              let lines = sections[i].trim().split("\n");
              let pnpDeviceId = util.getValue(lines, "PNPDeviceID", ":").match(/PCI\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);
              let subDeviceId = null;
              let memorySize = null;
              if (pnpDeviceId) {
                subDeviceId = pnpDeviceId[3] || "";
                if (subDeviceId) {
                  subDeviceId = subDeviceId.split("_")[1];
                }
                if (memorySize == null && pnpDeviceId[3] && pnpDeviceId[4]) {
                  const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[3].toUpperCase() + "&" + pnpDeviceId[4].toUpperCase();
                  if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                    memorySize = memorySizes[deviceId];
                  }
                }
                if (memorySize == null && pnpDeviceId[3]) {
                  const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[3].toUpperCase();
                  if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                    memorySize = memorySizes[deviceId];
                  }
                }
                if (memorySize == null && pnpDeviceId[4]) {
                  const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[4].toUpperCase();
                  if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                    memorySize = memorySizes[deviceId];
                  }
                }
                if (memorySize == null) {
                  const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase();
                  if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                    memorySize = memorySizes[deviceId];
                  }
                }
              }
              controllers.push({
                vendor: util.getValue(lines, "AdapterCompatibility", ":"),
                model: util.getValue(lines, "name", ":"),
                bus: util.getValue(lines, "PNPDeviceID", ":").startsWith("PCI") ? "PCI" : "",
                vram: (memorySize == null ? util.toInt(util.getValue(lines, "AdapterRAM", ":")) : memorySize) / 1024 / 1024,
                vramDynamic: util.getValue(lines, "VideoMemoryType", ":") === "2",
                subDeviceId
              });
              _resolutionX = util.toInt(util.getValue(lines, "CurrentHorizontalResolution", ":")) || _resolutionX;
              _resolutionY = util.toInt(util.getValue(lines, "CurrentVerticalResolution", ":")) || _resolutionY;
              _refreshRate = util.toInt(util.getValue(lines, "CurrentRefreshRate", ":")) || _refreshRate;
              _pixelDepth = util.toInt(util.getValue(lines, "CurrentBitsPerPixel", ":")) || _pixelDepth;
            }
          }
        }
        return controllers;
      }
      function parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections) {
        let displays = [];
        let vendor = "";
        let model = "";
        let deviceID = "";
        let resolutionX = 0;
        let resolutionY = 0;
        if (dsections && dsections.length) {
          let linesDisplay = dsections[0].split("\n");
          vendor = util.getValue(linesDisplay, "MonitorManufacturer", ":");
          model = util.getValue(linesDisplay, "Name", ":");
          deviceID = util.getValue(linesDisplay, "PNPDeviceID", ":").replace(/&amp;/g, "&").toLowerCase();
          resolutionX = util.toInt(util.getValue(linesDisplay, "ScreenWidth", ":"));
          resolutionY = util.toInt(util.getValue(linesDisplay, "ScreenHeight", ":"));
        }
        for (let i = 0; i < ssections.length; i++) {
          if (ssections[i].trim() !== "") {
            ssections[i] = "BitsPerPixel " + ssections[i];
            msections[i] = "Active " + msections[i];
            if (tsections.length === 0 || tsections[i] === void 0) {
              tsections[i] = "Unknown";
            }
            let linesScreen = ssections[i].split("\n");
            let linesMonitor = msections[i].split("\n");
            let linesConnection = tsections[i].split("\n");
            const bitsPerPixel = util.getValue(linesScreen, "BitsPerPixel");
            const bounds = util.getValue(linesScreen, "Bounds").replace("{", "").replace("}", "").replace(/=/g, ":").split(",");
            const primary = util.getValue(linesScreen, "Primary");
            const sizeX = util.getValue(linesMonitor, "MaxHorizontalImageSize");
            const sizeY = util.getValue(linesMonitor, "MaxVerticalImageSize");
            const instanceName = util.getValue(linesMonitor, "InstanceName").toLowerCase();
            const videoOutputTechnology = util.getValue(linesConnection, "VideoOutputTechnology");
            const deviceName = util.getValue(linesScreen, "DeviceName");
            let displayVendor = "";
            let displayModel = "";
            isections.forEach((element) => {
              if (element.instanceId.toLowerCase().startsWith(instanceName) && vendor.startsWith("(") && model.startsWith("PnP")) {
                displayVendor = element.vendor;
                displayModel = element.model;
              }
            });
            displays.push({
              vendor: instanceName.startsWith(deviceID) && displayVendor === "" ? vendor : displayVendor,
              model: instanceName.startsWith(deviceID) && displayModel === "" ? model : displayModel,
              deviceName,
              main: primary.toLowerCase() === "true",
              builtin: videoOutputTechnology === "2147483648",
              connection: videoOutputTechnology && videoTypes[videoOutputTechnology] ? videoTypes[videoOutputTechnology] : "",
              resolutionX: util.toInt(util.getValue(bounds, "Width", ":")),
              resolutionY: util.toInt(util.getValue(bounds, "Height", ":")),
              sizeX: sizeX ? parseInt(sizeX, 10) : null,
              sizeY: sizeY ? parseInt(sizeY, 10) : null,
              pixelDepth: bitsPerPixel,
              currentResX: util.toInt(util.getValue(bounds, "Width", ":")),
              currentResY: util.toInt(util.getValue(bounds, "Height", ":")),
              positionX: util.toInt(util.getValue(bounds, "X", ":")),
              positionY: util.toInt(util.getValue(bounds, "Y", ":"))
            });
          }
        }
        if (ssections.length === 0) {
          displays.push({
            vendor,
            model,
            main: true,
            sizeX: null,
            sizeY: null,
            resolutionX,
            resolutionY,
            pixelDepth: null,
            currentResX: resolutionX,
            currentResY: resolutionY,
            positionX: 0,
            positionY: 0
          });
        }
        return displays;
      }
    }
    exports.graphics = graphics;
  }
});

// node_modules/systeminformation/lib/filesystem.js
var require_filesystem = __commonJS({
  "node_modules/systeminformation/lib/filesystem.js"(exports) {
    "use strict";
    var util = require_util2();
    var fs = require("fs");
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var execPromiseSave = util.promisifySave(require("child_process").exec);
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _fs_speed = {};
    var _disk_io = {};
    function fsSize(drive, callback) {
      if (util.isFunction(drive)) {
        callback = drive;
        drive = "";
      }
      let macOsDisks = [];
      let osMounts = [];
      function getmacOsFsType(fs2) {
        if (!fs2.startsWith("/")) {
          return "NFS";
        }
        const parts = fs2.split("/");
        const fsShort = parts[parts.length - 1];
        const macOsDisksSingle = macOsDisks.filter((item) => item.indexOf(fsShort) >= 0);
        if (macOsDisksSingle.length === 1 && macOsDisksSingle[0].indexOf("APFS") >= 0) {
          return "APFS";
        }
        return "HFS";
      }
      function isLinuxTmpFs(fs2) {
        const linuxTmpFileSystems = ["rootfs", "unionfs", "squashfs", "cramfs", "initrd", "initramfs", "devtmpfs", "tmpfs", "udev", "devfs", "specfs", "type", "appimaged"];
        let result = false;
        linuxTmpFileSystems.forEach((linuxFs) => {
          if (fs2.toLowerCase().indexOf(linuxFs) >= 0) {
            result = true;
          }
        });
        return result;
      }
      function filterLines(stdout) {
        let lines = stdout.toString().split("\n");
        lines.shift();
        if (stdout.toString().toLowerCase().indexOf("filesystem")) {
          let removeLines = 0;
          for (let i = 0; i < lines.length; i++) {
            if (lines[i] && lines[i].toLowerCase().startsWith("filesystem")) {
              removeLines = i;
            }
          }
          for (let i = 0; i < removeLines; i++) {
            lines.shift();
          }
        }
        return lines;
      }
      function parseDf(lines) {
        let data = [];
        lines.forEach(function(line) {
          if (line !== "") {
            line = line.replace(/ +/g, " ").split(" ");
            if (line && (line[0].startsWith("/") || line[6] && line[6] === "/" || line[0].indexOf("/") > 0 || line[0].indexOf(":") === 1 || !_darwin && !isLinuxTmpFs(line[1]))) {
              const fs2 = line[0];
              const fsType = _linux || _freebsd || _openbsd || _netbsd ? line[1] : getmacOsFsType(line[0]);
              const size = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[2] : line[1]) * 1024;
              const used = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[3] : line[2]) * 1024;
              const available = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[4] : line[3]) * 1024;
              const use = parseFloat((100 * (used / (used + available))).toFixed(2));
              let rw = osMounts && Object.keys(osMounts).length > 0 ? osMounts[fs2] || false : null;
              line.splice(0, _linux || _freebsd || _openbsd || _netbsd ? 6 : 5);
              const mount = line.join(" ");
              if (!data.find((el) => el.fs === fs2 && el.type === fsType)) {
                data.push({
                  fs: fs2,
                  type: fsType,
                  size,
                  used,
                  available,
                  use,
                  mount,
                  rw
                });
              }
            }
          }
        });
        return data;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          let data = [];
          if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
            let cmd = "";
            macOsDisks = [];
            osMounts = {};
            if (_darwin) {
              cmd = "df -kP";
              try {
                macOsDisks = execSync("diskutil list").toString().split("\n").filter((line) => {
                  return !line.startsWith("/") && line.indexOf(":") > 0;
                });
                execSync("mount").toString().split("\n").filter((line) => {
                  return line.startsWith("/");
                }).forEach((line) => {
                  osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("read-only") === -1;
                });
              } catch (e) {
                util.noop();
              }
            }
            if (_linux) {
              try {
                cmd = "export LC_ALL=C; df -lkPTx squashfs; unset LC_ALL";
                execSync("cat /proc/mounts 2>/dev/null", util.execOptsLinux).toString().split("\n").filter((line) => {
                  return line.startsWith("/");
                }).forEach((line) => {
                  osMounts[line.split(" ")[0]] = osMounts[line.split(" ")[0]] || false;
                  if (line.toLowerCase().indexOf("/snap/") === -1) {
                    osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("rw,") >= 0 || line.toLowerCase().indexOf(" rw ") >= 0;
                  }
                });
              } catch (e) {
                util.noop();
              }
            }
            if (_freebsd || _openbsd || _netbsd) {
              try {
                cmd = "df -lkPT";
                execSync("mount").toString().split("\n").forEach((line) => {
                  osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("read-only") === -1;
                });
              } catch (e) {
                util.noop();
              }
            }
            exec2(cmd, { maxBuffer: 1024 * 1024 }, function(error, stdout) {
              let lines = filterLines(stdout);
              data = parseDf(lines);
              if (drive) {
                data = data.filter((item) => {
                  return item.fs.toLowerCase().indexOf(drive.toLowerCase()) >= 0 || item.mount.toLowerCase().indexOf(drive.toLowerCase()) >= 0;
                });
              }
              if ((!error || data.length) && stdout.toString().trim() !== "") {
                if (callback) {
                  callback(data);
                }
                resolve(data);
              } else {
                exec2("df -kPT", { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
                  if (!error2) {
                    let lines2 = filterLines(stdout2);
                    data = parseDf(lines2);
                  }
                  if (callback) {
                    callback(data);
                  }
                  resolve(data);
                });
              }
            });
          }
          if (_sunos) {
            if (callback) {
              callback(data);
            }
            resolve(data);
          }
          if (_windows) {
            try {
              const cmd = `Get-WmiObject Win32_logicaldisk | select Access,Caption,FileSystem,FreeSpace,Size ${drive ? "| where -property Caption -eq " + drive : ""} | fl`;
              util.powerShell(cmd).then((stdout, error) => {
                if (!error) {
                  let devices = stdout.toString().split(/\n\s*\n/);
                  devices.forEach(function(device) {
                    let lines = device.split("\r\n");
                    const size = util.toInt(util.getValue(lines, "size", ":"));
                    const free = util.toInt(util.getValue(lines, "freespace", ":"));
                    const caption = util.getValue(lines, "caption", ":");
                    const rwValue = util.getValue(lines, "access", ":");
                    const rw = rwValue ? util.toInt(rwValue) !== 1 : null;
                    if (size) {
                      data.push({
                        fs: caption,
                        type: util.getValue(lines, "filesystem", ":"),
                        size,
                        used: size - free,
                        available: free,
                        use: parseFloat((100 * (size - free) / size).toFixed(2)),
                        mount: caption,
                        rw
                      });
                    }
                  });
                }
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
            } catch (e) {
              if (callback) {
                callback(data);
              }
              resolve(data);
            }
          }
        });
      });
    }
    exports.fsSize = fsSize;
    function fsOpenFiles(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          const result = {
            max: null,
            allocated: null,
            available: null
          };
          if (_freebsd || _openbsd || _netbsd || _darwin) {
            let cmd = "sysctl -i kern.maxfiles kern.num_files kern.open_files";
            exec2(cmd, { maxBuffer: 1024 * 1024 }, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result.max = parseInt(util.getValue(lines, "kern.maxfiles", ":"), 10);
                result.allocated = parseInt(util.getValue(lines, "kern.num_files", ":"), 10) || parseInt(util.getValue(lines, "kern.open_files", ":"), 10);
                result.available = result.max - result.allocated;
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_linux) {
            fs.readFile("/proc/sys/fs/file-nr", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                if (lines[0]) {
                  const parts = lines[0].replace(/\s+/g, " ").split(" ");
                  if (parts.length === 3) {
                    result.allocated = parseInt(parts[0], 10);
                    result.available = parseInt(parts[1], 10);
                    result.max = parseInt(parts[2], 10);
                    if (!result.available) {
                      result.available = result.max - result.allocated;
                    }
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              } else {
                fs.readFile("/proc/sys/fs/file-max", function(error2, stdout2) {
                  if (!error2) {
                    let lines = stdout2.toString().split("\n");
                    if (lines[0]) {
                      result.max = parseInt(lines[0], 10);
                    }
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              }
            });
          }
          if (_sunos) {
            if (callback) {
              callback(null);
            }
            resolve(null);
          }
          if (_windows) {
            if (callback) {
              callback(null);
            }
            resolve(null);
          }
        });
      });
    }
    exports.fsOpenFiles = fsOpenFiles;
    function parseBytes(s) {
      return parseInt(s.substr(s.indexOf(" (") + 2, s.indexOf(" Bytes)") - 10));
    }
    function parseDevices(lines) {
      let devices = [];
      let i = 0;
      lines.forEach((line) => {
        if (line.length > 0) {
          if (line[0] === "*") {
            i++;
          } else {
            let parts = line.split(":");
            if (parts.length > 1) {
              if (!devices[i]) {
                devices[i] = {
                  name: "",
                  identifier: "",
                  type: "disk",
                  fsType: "",
                  mount: "",
                  size: 0,
                  physical: "HDD",
                  uuid: "",
                  label: "",
                  model: "",
                  serial: "",
                  removable: false,
                  protocol: "",
                  group: "",
                  device: ""
                };
              }
              parts[0] = parts[0].trim().toUpperCase().replace(/ +/g, "");
              parts[1] = parts[1].trim();
              if ("DEVICEIDENTIFIER" === parts[0]) {
                devices[i].identifier = parts[1];
              }
              if ("DEVICENODE" === parts[0]) {
                devices[i].name = parts[1];
              }
              if ("VOLUMENAME" === parts[0]) {
                if (parts[1].indexOf("Not applicable") === -1) {
                  devices[i].label = parts[1];
                }
              }
              if ("PROTOCOL" === parts[0]) {
                devices[i].protocol = parts[1];
              }
              if ("DISKSIZE" === parts[0]) {
                devices[i].size = parseBytes(parts[1]);
              }
              if ("FILESYSTEMPERSONALITY" === parts[0]) {
                devices[i].fsType = parts[1];
              }
              if ("MOUNTPOINT" === parts[0]) {
                devices[i].mount = parts[1];
              }
              if ("VOLUMEUUID" === parts[0]) {
                devices[i].uuid = parts[1];
              }
              if ("READ-ONLYMEDIA" === parts[0] && parts[1] === "Yes") {
                devices[i].physical = "CD/DVD";
              }
              if ("SOLIDSTATE" === parts[0] && parts[1] === "Yes") {
                devices[i].physical = "SSD";
              }
              if ("VIRTUAL" === parts[0]) {
                devices[i].type = "virtual";
              }
              if ("REMOVABLEMEDIA" === parts[0]) {
                devices[i].removable = parts[1] === "Removable";
              }
              if ("PARTITIONTYPE" === parts[0]) {
                devices[i].type = "part";
              }
              if ("DEVICE/MEDIANAME" === parts[0]) {
                devices[i].model = parts[1];
              }
            }
          }
        }
      });
      return devices;
    }
    function parseBlk(lines) {
      let data = [];
      lines.filter((line) => line !== "").forEach((line) => {
        try {
          line = decodeURIComponent(line.replace(/\\x/g, "%"));
          line = line.replace(/\\/g, "\\\\");
          let disk = JSON.parse(line);
          data.push({
            "name": disk.name,
            "type": disk.type,
            "fsType": disk.fsType,
            "mount": disk.mountpoint,
            "size": parseInt(disk.size),
            "physical": disk.type === "disk" ? disk.rota === "0" ? "SSD" : "HDD" : disk.type === "rom" ? "CD/DVD" : "",
            "uuid": disk.uuid,
            "label": disk.label,
            "model": (disk.model || "").trim(),
            "serial": disk.serial,
            "removable": disk.rm === "1",
            "protocol": disk.tran,
            "group": disk.group || ""
          });
        } catch (e) {
          util.noop();
        }
      });
      data = util.unique(data);
      data = util.sortByKey(data, ["type", "name"]);
      return data;
    }
    function decodeMdabmData(lines) {
      const raid = util.getValue(lines, "md_level", "=");
      const label = util.getValue(lines, "md_name", "=");
      const uuid = util.getValue(lines, "md_uuid", "=");
      const members = [];
      lines.forEach((line) => {
        if (line.toLowerCase().startsWith("md_device_dev") && line.toLowerCase().indexOf("/dev/") > 0) {
          members.push(line.split("/dev/")[1]);
        }
      });
      return {
        raid,
        label,
        uuid,
        members
      };
    }
    function raidMatchLinux(data) {
      let result = data;
      try {
        data.forEach((element) => {
          if (element.type.startsWith("raid")) {
            const lines = execSync(`mdadm --export --detail /dev/${element.name}`, util.execOptsLinux).toString().split("\n");
            const mdData = decodeMdabmData(lines);
            element.label = mdData.label;
            element.uuid = mdData.uuid;
            if (mdData.members && mdData.members.length && mdData.raid === element.type) {
              result = result.map((blockdevice) => {
                if (blockdevice.fsType === "linux_raid_member" && mdData.members.indexOf(blockdevice.name) >= 0) {
                  blockdevice.group = element.name;
                }
                return blockdevice;
              });
            }
          }
        });
      } catch (e) {
        util.noop();
      }
      return result;
    }
    function getDevicesLinux(data) {
      const result = [];
      data.forEach((element) => {
        if (element.type.startsWith("disk")) {
          result.push(element.name);
        }
      });
      return result;
    }
    function matchDevicesLinux(data) {
      let result = data;
      try {
        const devices = getDevicesLinux(data);
        result = result.map((blockdevice) => {
          if (blockdevice.type.startsWith("part") || blockdevice.type.startsWith("disk")) {
            devices.forEach((element) => {
              if (blockdevice.name.startsWith(element)) {
                blockdevice.device = "/dev/" + element;
              }
            });
          }
          return blockdevice;
        });
      } catch (e) {
        util.noop();
      }
      return result;
    }
    function getDevicesMac(data) {
      const result = [];
      data.forEach((element) => {
        if (element.type.startsWith("disk")) {
          result.push({ name: element.name, model: element.model, device: element.name });
        }
        if (element.type.startsWith("virtual")) {
          let device = "";
          result.forEach((e) => {
            if (e.model === element.model) {
              device = e.device;
            }
          });
          if (device) {
            result.push({ name: element.name, model: element.model, device });
          }
        }
      });
      return result;
    }
    function matchDevicesMac(data) {
      let result = data;
      try {
        const devices = getDevicesMac(data);
        result = result.map((blockdevice) => {
          if (blockdevice.type.startsWith("part") || blockdevice.type.startsWith("disk") || blockdevice.type.startsWith("virtual")) {
            devices.forEach((element) => {
              if (blockdevice.name.startsWith(element.name)) {
                blockdevice.device = element.device;
              }
            });
          }
          return blockdevice;
        });
      } catch (e) {
        util.noop();
      }
      return result;
    }
    function getDevicesWin(diskDrives) {
      const result = [];
      diskDrives.forEach((element) => {
        const lines = element.split("\r\n");
        const device = util.getValue(lines, "DeviceID", ":");
        let partitions = element.split("@{DeviceID=");
        if (partitions.length > 1) {
          partitions = partitions.slice(1);
          partitions.forEach((partition) => {
            result.push({ name: partition.split(";")[0].toUpperCase(), device });
          });
        }
      });
      return result;
    }
    function matchDevicesWin(data, diskDrives) {
      const devices = getDevicesWin(diskDrives);
      data.map((element) => {
        const filteresDevices = devices.filter((e) => {
          return e.name === element.name.toUpperCase();
        });
        if (filteresDevices.length > 0) {
          element.device = filteresDevices[0].device;
        }
        return element;
      });
      return data;
    }
    function blkStdoutToObject(stdout) {
      return stdout.toString().replace(/NAME=/g, '{"name":').replace(/FSTYPE=/g, ',"fsType":').replace(/TYPE=/g, ',"type":').replace(/SIZE=/g, ',"size":').replace(/MOUNTPOINT=/g, ',"mountpoint":').replace(/UUID=/g, ',"uuid":').replace(/ROTA=/g, ',"rota":').replace(/RO=/g, ',"ro":').replace(/RM=/g, ',"rm":').replace(/TRAN=/g, ',"tran":').replace(/SERIAL=/g, ',"serial":').replace(/LABEL=/g, ',"label":').replace(/MODEL=/g, ',"model":').replace(/OWNER=/g, ',"owner":').replace(/GROUP=/g, ',"group":').replace(/\n/g, "}\n");
    }
    function blockDevices(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let data = [];
          if (_linux) {
            exec2("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER 2>/dev/null", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
              if (!error) {
                let lines = blkStdoutToObject(stdout).split("\n");
                data = parseBlk(lines);
                data = raidMatchLinux(data);
                data = matchDevicesLinux(data);
                if (callback) {
                  callback(data);
                }
                resolve(data);
              } else {
                exec2("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER 2>/dev/null", { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
                  if (!error2) {
                    let lines = blkStdoutToObject(stdout2).split("\n");
                    data = parseBlk(lines);
                    data = raidMatchLinux(data);
                  }
                  if (callback) {
                    callback(data);
                  }
                  resolve(data);
                });
              }
            });
          }
          if (_darwin) {
            exec2("diskutil info -all", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                data = parseDevices(lines);
                data = matchDevicesMac(data);
              }
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(data);
            }
            resolve(data);
          }
          if (_windows) {
            let drivetypes = ["Unknown", "NoRoot", "Removable", "Local", "Network", "CD/DVD", "RAM"];
            try {
              const workload = [];
              workload.push(util.powerShell("Get-CimInstance -ClassName Win32_LogicalDisk | select Caption,DriveType,Name,FileSystem,Size,VolumeSerialNumber,VolumeName | fl"));
              workload.push(util.powerShell("Get-WmiObject -Class Win32_diskdrive | Select-Object -Property PNPDeviceId,DeviceID, Model, Size, @{L='Partitions'; E={$_.GetRelated('Win32_DiskPartition').GetRelated('Win32_LogicalDisk') | Select-Object -Property DeviceID, VolumeName, Size, FreeSpace}} | fl"));
              util.promiseAll(
                workload
              ).then((res) => {
                let logicalDisks = res.results[0].toString().split(/\n\s*\n/);
                let diskDrives = res.results[1].toString().split(/\n\s*\n/);
                logicalDisks.forEach(function(device) {
                  let lines = device.split("\r\n");
                  let drivetype = util.getValue(lines, "drivetype", ":");
                  if (drivetype) {
                    data.push({
                      name: util.getValue(lines, "name", ":"),
                      identifier: util.getValue(lines, "caption", ":"),
                      type: "disk",
                      fsType: util.getValue(lines, "filesystem", ":").toLowerCase(),
                      mount: util.getValue(lines, "caption", ":"),
                      size: util.getValue(lines, "size", ":"),
                      physical: drivetype >= 0 && drivetype <= 6 ? drivetypes[drivetype] : drivetypes[0],
                      uuid: util.getValue(lines, "volumeserialnumber", ":"),
                      label: util.getValue(lines, "volumename", ":"),
                      model: "",
                      serial: util.getValue(lines, "volumeserialnumber", ":"),
                      removable: drivetype === "2",
                      protocol: "",
                      group: "",
                      device: ""
                    });
                  }
                });
                data = matchDevicesWin(data, diskDrives);
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
            } catch (e) {
              if (callback) {
                callback(data);
              }
              resolve(data);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            if (callback) {
              callback(null);
            }
            resolve(null);
          }
        });
      });
    }
    exports.blockDevices = blockDevices;
    function calcFsSpeed(rx, wx) {
      let result = {
        rx: 0,
        wx: 0,
        tx: 0,
        rx_sec: null,
        wx_sec: null,
        tx_sec: null,
        ms: 0
      };
      if (_fs_speed && _fs_speed.ms) {
        result.rx = rx;
        result.wx = wx;
        result.tx = result.rx + result.wx;
        result.ms = Date.now() - _fs_speed.ms;
        result.rx_sec = (result.rx - _fs_speed.bytes_read) / (result.ms / 1e3);
        result.wx_sec = (result.wx - _fs_speed.bytes_write) / (result.ms / 1e3);
        result.tx_sec = result.rx_sec + result.wx_sec;
        _fs_speed.rx_sec = result.rx_sec;
        _fs_speed.wx_sec = result.wx_sec;
        _fs_speed.tx_sec = result.tx_sec;
        _fs_speed.bytes_read = result.rx;
        _fs_speed.bytes_write = result.wx;
        _fs_speed.bytes_overall = result.rx + result.wx;
        _fs_speed.ms = Date.now();
        _fs_speed.last_ms = result.ms;
      } else {
        result.rx = rx;
        result.wx = wx;
        result.tx = result.rx + result.wx;
        _fs_speed.rx_sec = null;
        _fs_speed.wx_sec = null;
        _fs_speed.tx_sec = null;
        _fs_speed.bytes_read = result.rx;
        _fs_speed.bytes_write = result.wx;
        _fs_speed.bytes_overall = result.rx + result.wx;
        _fs_speed.ms = Date.now();
        _fs_speed.last_ms = 0;
      }
      return result;
    }
    function fsStats(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (_windows || _freebsd || _openbsd || _netbsd || _sunos) {
            return resolve(null);
          }
          let result = {
            rx: 0,
            wx: 0,
            tx: 0,
            rx_sec: null,
            wx_sec: null,
            tx_sec: null,
            ms: 0
          };
          let rx = 0;
          let wx = 0;
          if (_fs_speed && !_fs_speed.ms || _fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500) {
            if (_linux) {
              exec2("lsblk -r 2>/dev/null | grep /", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  let fs_filter = [];
                  lines.forEach(function(line) {
                    if (line !== "") {
                      line = line.trim().split(" ");
                      if (fs_filter.indexOf(line[0]) === -1) {
                        fs_filter.push(line[0]);
                      }
                    }
                  });
                  let output = fs_filter.join("|");
                  exec2('cat /proc/diskstats | egrep "' + output + '"', { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
                    if (!error2) {
                      let lines2 = stdout2.toString().split("\n");
                      lines2.forEach(function(line) {
                        line = line.trim();
                        if (line !== "") {
                          line = line.replace(/ +/g, " ").split(" ");
                          rx += parseInt(line[5]) * 512;
                          wx += parseInt(line[9]) * 512;
                        }
                      });
                      result = calcFsSpeed(rx, wx);
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            }
            if (_darwin) {
              exec2('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n "/IOBlockStorageDriver/,/Statistics/p" | grep "Statistics" | tr -cd "01234567890,\n"', { maxBuffer: 1024 * 1024 }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    line = line.trim();
                    if (line !== "") {
                      line = line.split(",");
                      rx += parseInt(line[2]);
                      wx += parseInt(line[9]);
                    }
                  });
                  result = calcFsSpeed(rx, wx);
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            }
          } else {
            result.ms = _fs_speed.last_ms;
            result.rx = _fs_speed.bytes_read;
            result.wx = _fs_speed.bytes_write;
            result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;
            result.rx_sec = _fs_speed.rx_sec;
            result.wx_sec = _fs_speed.wx_sec;
            result.tx_sec = _fs_speed.tx_sec;
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.fsStats = fsStats;
    function calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime) {
      let result = {
        rIO: 0,
        wIO: 0,
        tIO: 0,
        rIO_sec: null,
        wIO_sec: null,
        tIO_sec: null,
        rWaitTime: 0,
        wWaitTime: 0,
        tWaitTime: 0,
        rWaitPercent: null,
        wWaitPercent: null,
        tWaitPercent: null,
        ms: 0
      };
      if (_disk_io && _disk_io.ms) {
        result.rIO = rIO;
        result.wIO = wIO;
        result.tIO = rIO + wIO;
        result.ms = Date.now() - _disk_io.ms;
        result.rIO_sec = (result.rIO - _disk_io.rIO) / (result.ms / 1e3);
        result.wIO_sec = (result.wIO - _disk_io.wIO) / (result.ms / 1e3);
        result.tIO_sec = result.rIO_sec + result.wIO_sec;
        result.rWaitTime = rWaitTime;
        result.wWaitTime = wWaitTime;
        result.tWaitTime = tWaitTime;
        result.rWaitPercent = (result.rWaitTime - _disk_io.rWaitTime) * 100 / result.ms;
        result.wWaitPercent = (result.wWaitTime - _disk_io.wWaitTime) * 100 / result.ms;
        result.tWaitPercent = (result.tWaitTime - _disk_io.tWaitTime) * 100 / result.ms;
        _disk_io.rIO = rIO;
        _disk_io.wIO = wIO;
        _disk_io.rIO_sec = result.rIO_sec;
        _disk_io.wIO_sec = result.wIO_sec;
        _disk_io.tIO_sec = result.tIO_sec;
        _disk_io.rWaitTime = rWaitTime;
        _disk_io.wWaitTime = wWaitTime;
        _disk_io.tWaitTime = tWaitTime;
        _disk_io.rWaitPercent = result.rWaitPercent;
        _disk_io.wWaitPercent = result.wWaitPercent;
        _disk_io.tWaitPercent = result.tWaitPercent;
        _disk_io.last_ms = result.ms;
        _disk_io.ms = Date.now();
      } else {
        result.rIO = rIO;
        result.wIO = wIO;
        result.tIO = rIO + wIO;
        result.rWaitTime = rWaitTime;
        result.wWaitTime = wWaitTime;
        result.tWaitTime = tWaitTime;
        _disk_io.rIO = rIO;
        _disk_io.wIO = wIO;
        _disk_io.rIO_sec = null;
        _disk_io.wIO_sec = null;
        _disk_io.tIO_sec = null;
        _disk_io.rWaitTime = rWaitTime;
        _disk_io.wWaitTime = wWaitTime;
        _disk_io.tWaitTime = tWaitTime;
        _disk_io.rWaitPercent = null;
        _disk_io.wWaitPercent = null;
        _disk_io.tWaitPercent = null;
        _disk_io.last_ms = 0;
        _disk_io.ms = Date.now();
      }
      return result;
    }
    function disksIO(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (_windows) {
            return resolve(null);
          }
          if (_sunos) {
            return resolve(null);
          }
          let result = {
            rIO: 0,
            wIO: 0,
            tIO: 0,
            rIO_sec: null,
            wIO_sec: null,
            tIO_sec: null,
            rWaitTime: 0,
            wWaitTime: 0,
            tWaitTime: 0,
            rWaitPercent: null,
            wWaitPercent: null,
            tWaitPercent: null,
            ms: 0
          };
          let rIO = 0;
          let wIO = 0;
          let rWaitTime = 0;
          let wWaitTime = 0;
          let tWaitTime = 0;
          if (_disk_io && !_disk_io.ms || _disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500) {
            if (_linux || _freebsd || _openbsd || _netbsd) {
              let cmd = 'for mount in `lsblk 2>/dev/null | grep " disk " | sed "s/[\u2502\u2514\u2500\u251C]//g" | awk \'{$1=$1};1\' | cut -d " " -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r "s/ +/;/g" | sed -r "s/^;//"; done';
              exec2(cmd, { maxBuffer: 1024 * 1024 }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.split("\n");
                  lines.forEach(function(line) {
                    if (!line) {
                      return;
                    }
                    let stats = line.split(";");
                    rIO += parseInt(stats[0]);
                    wIO += parseInt(stats[4]);
                    rWaitTime += parseInt(stats[3]);
                    wWaitTime += parseInt(stats[7]);
                    tWaitTime += parseInt(stats[10]);
                  });
                  result = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            }
            if (_darwin) {
              exec2('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n "/IOBlockStorageDriver/,/Statistics/p" | grep "Statistics" | tr -cd "01234567890,\n"', { maxBuffer: 1024 * 1024 }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    line = line.trim();
                    if (line !== "") {
                      line = line.split(",");
                      rIO += parseInt(line[10]);
                      wIO += parseInt(line[0]);
                    }
                  });
                  result = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            }
          } else {
            result.rIO = _disk_io.rIO;
            result.wIO = _disk_io.wIO;
            result.tIO = _disk_io.rIO + _disk_io.wIO;
            result.ms = _disk_io.last_ms;
            result.rIO_sec = _disk_io.rIO_sec;
            result.wIO_sec = _disk_io.wIO_sec;
            result.tIO_sec = _disk_io.tIO_sec;
            result.rWaitTime = _disk_io.rWaitTime;
            result.wWaitTime = _disk_io.wWaitTime;
            result.tWaitTime = _disk_io.tWaitTime;
            result.rWaitPercent = _disk_io.rWaitPercent;
            result.wWaitPercent = _disk_io.wWaitPercent;
            result.tWaitPercent = _disk_io.tWaitPercent;
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.disksIO = disksIO;
    function diskLayout(callback) {
      function getVendorFromModel(model) {
        const diskManufacturers = [
          { pattern: "WESTERN.*", manufacturer: "Western Digital" },
          { pattern: "^WDC.*", manufacturer: "Western Digital" },
          { pattern: "WD.*", manufacturer: "Western Digital" },
          { pattern: "TOSHIBA.*", manufacturer: "Toshiba" },
          { pattern: "HITACHI.*", manufacturer: "Hitachi" },
          { pattern: "^IC.*", manufacturer: "Hitachi" },
          { pattern: "^HTS.*", manufacturer: "Hitachi" },
          { pattern: "SANDISK.*", manufacturer: "SanDisk" },
          { pattern: "KINGSTON.*", manufacturer: "Kingston Technology" },
          { pattern: "^SONY.*", manufacturer: "Sony" },
          { pattern: "TRANSCEND.*", manufacturer: "Transcend" },
          { pattern: "SAMSUNG.*", manufacturer: "Samsung" },
          { pattern: "^ST(?!I\\ ).*", manufacturer: "Seagate" },
          { pattern: "^STI\\ .*", manufacturer: "SimpleTech" },
          { pattern: "^D...-.*", manufacturer: "IBM" },
          { pattern: "^IBM.*", manufacturer: "IBM" },
          { pattern: "^FUJITSU.*", manufacturer: "Fujitsu" },
          { pattern: "^MP.*", manufacturer: "Fujitsu" },
          { pattern: "^MK.*", manufacturer: "Toshiba" },
          { pattern: "MAXTO.*", manufacturer: "Maxtor" },
          { pattern: "PIONEER.*", manufacturer: "Pioneer" },
          { pattern: "PHILIPS.*", manufacturer: "Philips" },
          { pattern: "QUANTUM.*", manufacturer: "Quantum Technology" },
          { pattern: "FIREBALL.*", manufacturer: "Quantum Technology" },
          { pattern: "^VBOX.*", manufacturer: "VirtualBox" },
          { pattern: "CORSAIR.*", manufacturer: "Corsair Components" },
          { pattern: "CRUCIAL.*", manufacturer: "Crucial" },
          { pattern: "ECM.*", manufacturer: "ECM" },
          { pattern: "INTEL.*", manufacturer: "INTEL" },
          { pattern: "EVO.*", manufacturer: "Samsung" },
          { pattern: "APPLE.*", manufacturer: "Apple" }
        ];
        let result = "";
        if (model) {
          model = model.toUpperCase();
          diskManufacturers.forEach((manufacturer) => {
            const re = RegExp(manufacturer.pattern);
            if (re.test(model)) {
              result = manufacturer.manufacturer;
            }
          });
        }
        return result;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          const commitResult = (res) => {
            for (let i = 0; i < res.length; i++) {
              delete res[i].BSDName;
            }
            if (callback) {
              callback(res);
            }
            resolve(res);
          };
          let result = [];
          let cmd = "";
          if (_linux) {
            let cmdFullSmart = "";
            exec2("export LC_ALL=C; lsblk -ablJO 2>/dev/null; unset LC_ALL", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
              if (!error) {
                try {
                  const out = stdout.toString().trim();
                  let devices = [];
                  try {
                    const outJSON = JSON.parse(out);
                    if (outJSON && {}.hasOwnProperty.call(outJSON, "blockdevices")) {
                      devices = outJSON.blockdevices.filter((item) => {
                        return item.type === "disk" && item.size > 0 && (item.model !== null || item.mountpoint === null && item.label === null && item.fstype === null && item.parttype === null && item.path && item.path.indexOf("/ram") !== 0 && item.path.indexOf("/loop") !== 0 && item["disc-max"] && item["disc-max"] !== 0);
                      });
                    }
                  } catch (e) {
                    try {
                      const out2 = execSync("export LC_ALL=C; lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER,GROUP 2>/dev/null; unset LC_ALL", util.execOptsLinux).toString();
                      let lines = blkStdoutToObject(out2).split("\n");
                      const data = parseBlk(lines);
                      devices = data.filter((item) => {
                        return item.type === "disk" && item.size > 0 && (item.model !== null && item.model !== "" || item.mount === "" && item.label === "" && item.fsType === "");
                      });
                    } catch (e2) {
                      util.noop();
                    }
                  }
                  devices.forEach((device) => {
                    let mediumType = "";
                    const BSDName = "/dev/" + device.name;
                    const logical = device.name;
                    try {
                      mediumType = execSync("cat /sys/block/" + logical + "/queue/rotational 2>/dev/null", util.execOptsLinux).toString().split("\n")[0];
                    } catch (e) {
                      util.noop();
                    }
                    let interfaceType = device.tran ? device.tran.toUpperCase().trim() : "";
                    if (interfaceType === "NVME") {
                      mediumType = "2";
                      interfaceType = "PCIe";
                    }
                    result.push({
                      device: BSDName,
                      type: mediumType === "0" ? "SSD" : mediumType === "1" ? "HD" : mediumType === "2" ? "NVMe" : device.model && device.model.indexOf("SSD") > -1 ? "SSD" : device.model && device.model.indexOf("NVM") > -1 ? "NVMe" : "HD",
                      name: device.model || "",
                      vendor: getVendorFromModel(device.model) || (device.vendor ? device.vendor.trim() : ""),
                      size: device.size || 0,
                      bytesPerSector: null,
                      totalCylinders: null,
                      totalHeads: null,
                      totalSectors: null,
                      totalTracks: null,
                      tracksPerCylinder: null,
                      sectorsPerTrack: null,
                      firmwareRevision: device.rev ? device.rev.trim() : "",
                      serialNum: device.serial ? device.serial.trim() : "",
                      interfaceType,
                      smartStatus: "unknown",
                      temperature: null,
                      BSDName
                    });
                    cmd += `printf "
${BSDName}|"; smartctl -H ${BSDName} | grep overall;`;
                    cmdFullSmart += `${cmdFullSmart ? 'printf ",";' : ""}smartctl -a -j ${BSDName};`;
                  });
                } catch (e) {
                  util.noop();
                }
              }
              if (cmdFullSmart) {
                exec2(cmdFullSmart, { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
                  try {
                    const data = JSON.parse(`[${stdout2}]`);
                    data.forEach((disk) => {
                      const diskBSDName = disk.smartctl.argv[disk.smartctl.argv.length - 1];
                      for (let i = 0; i < result.length; i++) {
                        if (result[i].BSDName === diskBSDName) {
                          result[i].smartStatus = disk.smart_status.passed ? "Ok" : disk.smart_status.passed === false ? "Predicted Failure" : "unknown";
                          if (disk.temperature && disk.temperature.current) {
                            result[i].temperature = disk.temperature.current;
                          }
                          result[i].smartData = disk;
                        }
                      }
                    });
                    commitResult(result);
                  } catch (e) {
                    if (cmd) {
                      cmd = cmd + 'printf "\n"';
                      exec2(cmd, { maxBuffer: 1024 * 1024 }, function(error3, stdout3) {
                        let lines = stdout3.toString().split("\n");
                        lines.forEach((line) => {
                          if (line) {
                            let parts = line.split("|");
                            if (parts.length === 2) {
                              let BSDName = parts[0];
                              parts[1] = parts[1].trim();
                              let parts2 = parts[1].split(":");
                              if (parts2.length === 2) {
                                parts2[1] = parts2[1].trim();
                                let status = parts2[1].toLowerCase();
                                for (let i = 0; i < result.length; i++) {
                                  if (result[i].BSDName === BSDName) {
                                    result[i].smartStatus = status === "passed" ? "Ok" : status === "failed!" ? "Predicted Failure" : "unknown";
                                  }
                                }
                              }
                            }
                          }
                        });
                        commitResult(result);
                      });
                    } else {
                      commitResult(result);
                    }
                  }
                });
              } else {
                commitResult(result);
              }
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_sunos) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_darwin) {
            exec2("system_profiler SPSerialATADataType SPNVMeDataType SPUSBDataType", { maxBuffer: 1024 * 1024 }, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                let linesSATA = [];
                let linesNVMe = [];
                let linesUSB = [];
                let dataType = "SATA";
                lines.forEach((line) => {
                  if (line === "NVMExpress:") {
                    dataType = "NVMe";
                  } else if (line === "USB:") {
                    dataType = "USB";
                  } else if (line === "SATA/SATA Express:") {
                    dataType = "SATA";
                  } else if (dataType === "SATA") {
                    linesSATA.push(line);
                  } else if (dataType === "NVMe") {
                    linesNVMe.push(line);
                  } else if (dataType === "USB") {
                    linesUSB.push(line);
                  }
                });
                try {
                  let devices = linesSATA.join("\n").split(" Physical Interconnect: ");
                  devices.shift();
                  devices.forEach(function(device) {
                    device = "InterfaceType: " + device;
                    let lines2 = device.split("\n");
                    const mediumType = util.getValue(lines2, "Medium Type", ":", true).trim();
                    const sizeStr = util.getValue(lines2, "capacity", ":", true).trim();
                    const BSDName = util.getValue(lines2, "BSD Name", ":", true).trim();
                    if (sizeStr) {
                      let sizeValue = 0;
                      if (sizeStr.indexOf("(") >= 0) {
                        sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""));
                      }
                      if (!sizeValue) {
                        sizeValue = parseInt(sizeStr);
                      }
                      if (sizeValue) {
                        const smartStatusString = util.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                        result.push({
                          device: BSDName,
                          type: mediumType.startsWith("Solid") ? "SSD" : "HD",
                          name: util.getValue(lines2, "Model", ":", true).trim(),
                          vendor: getVendorFromModel(util.getValue(lines2, "Model", ":", true).trim()) || util.getValue(lines2, "Manufacturer", ":", true),
                          size: sizeValue,
                          bytesPerSector: null,
                          totalCylinders: null,
                          totalHeads: null,
                          totalSectors: null,
                          totalTracks: null,
                          tracksPerCylinder: null,
                          sectorsPerTrack: null,
                          firmwareRevision: util.getValue(lines2, "Revision", ":", true).trim(),
                          serialNum: util.getValue(lines2, "Serial Number", ":", true).trim(),
                          interfaceType: util.getValue(lines2, "InterfaceType", ":", true).trim(),
                          smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                          temperature: null,
                          BSDName
                        });
                        cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                      }
                    }
                  });
                } catch (e) {
                  util.noop();
                }
                try {
                  let devices = linesNVMe.join("\n").split("\n\n          Capacity:");
                  devices.shift();
                  devices.forEach(function(device) {
                    device = "!Capacity: " + device;
                    let lines2 = device.split("\n");
                    const linkWidth = util.getValue(lines2, "link width", ":", true).trim();
                    const sizeStr = util.getValue(lines2, "!capacity", ":", true).trim();
                    const BSDName = util.getValue(lines2, "BSD Name", ":", true).trim();
                    if (sizeStr) {
                      let sizeValue = 0;
                      if (sizeStr.indexOf("(") >= 0) {
                        sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""));
                      }
                      if (!sizeValue) {
                        sizeValue = parseInt(sizeStr);
                      }
                      if (sizeValue) {
                        const smartStatusString = util.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                        result.push({
                          device: BSDName,
                          type: "NVMe",
                          name: util.getValue(lines2, "Model", ":", true).trim(),
                          vendor: getVendorFromModel(util.getValue(lines2, "Model", ":", true).trim()),
                          size: sizeValue,
                          bytesPerSector: null,
                          totalCylinders: null,
                          totalHeads: null,
                          totalSectors: null,
                          totalTracks: null,
                          tracksPerCylinder: null,
                          sectorsPerTrack: null,
                          firmwareRevision: util.getValue(lines2, "Revision", ":", true).trim(),
                          serialNum: util.getValue(lines2, "Serial Number", ":", true).trim(),
                          interfaceType: ("PCIe " + linkWidth).trim(),
                          smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                          temperature: null,
                          BSDName
                        });
                        cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                      }
                    }
                  });
                } catch (e) {
                  util.noop();
                }
                try {
                  let devices = linesUSB.join("\n").replaceAll("Media:\n ", "Model:").split("\n\n          Product ID:");
                  devices.shift();
                  devices.forEach(function(device) {
                    let lines2 = device.split("\n");
                    const sizeStr = util.getValue(lines2, "Capacity", ":", true).trim();
                    const BSDName = util.getValue(lines2, "BSD Name", ":", true).trim();
                    if (sizeStr) {
                      let sizeValue = 0;
                      if (sizeStr.indexOf("(") >= 0) {
                        sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""));
                      }
                      if (!sizeValue) {
                        sizeValue = parseInt(sizeStr);
                      }
                      if (sizeValue) {
                        const smartStatusString = util.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                        result.push({
                          device: BSDName,
                          type: "USB",
                          name: util.getValue(lines2, "Model", ":", true).trim().replaceAll(":", ""),
                          vendor: getVendorFromModel(util.getValue(lines2, "Model", ":", true).trim()),
                          size: sizeValue,
                          bytesPerSector: null,
                          totalCylinders: null,
                          totalHeads: null,
                          totalSectors: null,
                          totalTracks: null,
                          tracksPerCylinder: null,
                          sectorsPerTrack: null,
                          firmwareRevision: util.getValue(lines2, "Revision", ":", true).trim(),
                          serialNum: util.getValue(lines2, "Serial Number", ":", true).trim(),
                          interfaceType: "USB",
                          smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                          temperature: null,
                          BSDName
                        });
                        cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                      }
                    }
                  });
                } catch (e) {
                  util.noop();
                }
                if (cmd) {
                  cmd = cmd + 'printf "\n"';
                  exec2(cmd, { maxBuffer: 1024 * 1024 }, function(error2, stdout2) {
                    let lines2 = stdout2.toString().split("\n");
                    lines2.forEach((line) => {
                      if (line) {
                        let parts = line.split("|");
                        if (parts.length === 2) {
                          let BSDName = parts[0];
                          parts[1] = parts[1].trim();
                          let parts2 = parts[1].split(":");
                          if (parts2.length === 2) {
                            parts2[1] = parts2[1].trim();
                            let status = parts2[1].toLowerCase();
                            for (let i = 0; i < result.length; i++) {
                              if (result[i].BSDName === BSDName) {
                                result[i].smartStatus = status === "not supported" ? "not supported" : status === "verified" ? "Ok" : status === "failing" ? "Predicted Failure" : "unknown";
                              }
                            }
                          }
                        }
                      }
                    });
                    for (let i = 0; i < result.length; i++) {
                      delete result[i].BSDName;
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } else {
                  for (let i = 0; i < result.length; i++) {
                    delete result[i].BSDName;
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              }
            });
          }
          if (_windows) {
            try {
              const workload = [];
              workload.push(util.powerShell("Get-CimInstance Win32_DiskDrive | select Caption,Size,Status,PNPDeviceId,DeviceId,BytesPerSector,TotalCylinders,TotalHeads,TotalSectors,TotalTracks,TracksPerCylinder,SectorsPerTrack,FirmwareRevision,SerialNumber,InterfaceType | fl"));
              workload.push(util.powerShell("Get-PhysicalDisk | select BusType,MediaType,FriendlyName,Model,SerialNumber,Size | fl"));
              if (util.smartMonToolsInstalled()) {
                try {
                  const smartDev = JSON.parse(execSync("smartctl --scan -j").toString());
                  if (smartDev && smartDev.devices && smartDev.devices.length > 0) {
                    smartDev.devices.forEach((dev) => {
                      workload.push(execPromiseSave(`smartctl -j -a ${dev.name}`, util.execOptsWin));
                    });
                  }
                } catch (e) {
                  util.noop();
                }
              }
              util.promiseAll(
                workload
              ).then((data) => {
                let devices = data.results[0].toString().split(/\n\s*\n/);
                devices.forEach(function(device) {
                  let lines = device.split("\r\n");
                  const size = util.getValue(lines, "Size", ":").trim();
                  const status = util.getValue(lines, "Status", ":").trim().toLowerCase();
                  if (size) {
                    result.push({
                      device: util.getValue(lines, "DeviceId", ":"),
                      // changed from PNPDeviceId to DeviceID (be be able to match devices)
                      type: device.indexOf("SSD") > -1 ? "SSD" : "HD",
                      // just a starting point ... better: MSFT_PhysicalDisk - Media Type ... see below
                      name: util.getValue(lines, "Caption", ":"),
                      vendor: getVendorFromModel(util.getValue(lines, "Caption", ":", true).trim()),
                      size: parseInt(size),
                      bytesPerSector: parseInt(util.getValue(lines, "BytesPerSector", ":")),
                      totalCylinders: parseInt(util.getValue(lines, "TotalCylinders", ":")),
                      totalHeads: parseInt(util.getValue(lines, "TotalHeads", ":")),
                      totalSectors: parseInt(util.getValue(lines, "TotalSectors", ":")),
                      totalTracks: parseInt(util.getValue(lines, "TotalTracks", ":")),
                      tracksPerCylinder: parseInt(util.getValue(lines, "TracksPerCylinder", ":")),
                      sectorsPerTrack: parseInt(util.getValue(lines, "SectorsPerTrack", ":")),
                      firmwareRevision: util.getValue(lines, "FirmwareRevision", ":").trim(),
                      serialNum: util.getValue(lines, "SerialNumber", ":").trim(),
                      interfaceType: util.getValue(lines, "InterfaceType", ":").trim(),
                      smartStatus: status === "ok" ? "Ok" : status === "degraded" ? "Degraded" : status === "pred fail" ? "Predicted Failure" : "Unknown",
                      temperature: null
                    });
                  }
                });
                devices = data.results[1].split(/\n\s*\n/);
                devices.forEach(function(device) {
                  let lines = device.split("\r\n");
                  const serialNum = util.getValue(lines, "SerialNumber", ":").trim();
                  const name = util.getValue(lines, "FriendlyName", ":").trim().replace("Msft ", "Microsoft");
                  const size = util.getValue(lines, "Size", ":").trim();
                  const model = util.getValue(lines, "Model", ":").trim();
                  const interfaceType = util.getValue(lines, "BusType", ":").trim();
                  let mediaType = util.getValue(lines, "MediaType", ":").trim();
                  if (mediaType === "3" || mediaType === "HDD") {
                    mediaType = "HD";
                  }
                  if (mediaType === "4") {
                    mediaType = "SSD";
                  }
                  if (mediaType === "5") {
                    mediaType = "SCM";
                  }
                  if (mediaType === "Unspecified" && (model.toLowerCase().indexOf("virtual") > -1 || model.toLowerCase().indexOf("vbox") > -1)) {
                    mediaType = "Virtual";
                  }
                  if (size) {
                    let i = util.findObjectByKey(result, "serialNum", serialNum);
                    if (i === -1 || serialNum === "") {
                      i = util.findObjectByKey(result, "name", name);
                    }
                    if (i != -1) {
                      result[i].type = mediaType;
                      result[i].interfaceType = interfaceType;
                    }
                  }
                });
                data.results.shift();
                data.results.shift();
                if (data.results.length) {
                  data.results.forEach((smartStr) => {
                    try {
                      const smartData = JSON.parse(smartStr);
                      if (smartData.serial_number) {
                        const serialNum = smartData.serial_number;
                        let i = util.findObjectByKey(result, "serialNum", serialNum);
                        if (i != -1) {
                          result[i].smartStatus = smartData.smart_status && smartData.smart_status.passed ? "Ok" : smartData.smart_status && smartData.smart_status.passed === false ? "Predicted Failure" : "unknown";
                          if (smartData.temperature && smartData.temperature.current) {
                            result[i].temperature = smartData.temperature.current;
                          }
                          result[i].smartData = smartData;
                        }
                      }
                    } catch (e) {
                      util.noop();
                    }
                  });
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.diskLayout = diskLayout;
  }
});

// node_modules/systeminformation/lib/network.js
var require_network = __commonJS({
  "node_modules/systeminformation/lib/network.js"(exports) {
    "use strict";
    var os2 = require("os");
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var fs = require("fs");
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _network = {};
    var _default_iface = "";
    var _ifaces = {};
    var _dhcpNics = [];
    var _networkInterfaces = [];
    var _mac = {};
    var pathToIp;
    function getDefaultNetworkInterface() {
      let ifacename = "";
      let ifacenameFirst = "";
      try {
        let ifaces = os2.networkInterfaces();
        let scopeid = 9999;
        for (let dev in ifaces) {
          if ({}.hasOwnProperty.call(ifaces, dev)) {
            ifaces[dev].forEach(function(details) {
              if (details && details.internal === false) {
                ifacenameFirst = ifacenameFirst || dev;
                if (details.scopeid && details.scopeid < scopeid) {
                  ifacename = dev;
                  scopeid = details.scopeid;
                }
              }
            });
          }
        }
        ifacename = ifacename || ifacenameFirst || "";
        if (_windows) {
          let defaultIp = "";
          const cmd = "netstat -r";
          const result = execSync(cmd, util.execOptsWin);
          const lines = result.toString().split(os2.EOL);
          lines.forEach((line) => {
            line = line.replace(/\s+/g, " ").trim();
            if (line.indexOf("0.0.0.0 0.0.0.0") > -1 && !/[a-zA-Z]/.test(line)) {
              const parts = line.split(" ");
              if (parts.length >= 5) {
                defaultIp = parts[parts.length - 2];
              }
            }
          });
          if (defaultIp) {
            for (let dev in ifaces) {
              if ({}.hasOwnProperty.call(ifaces, dev)) {
                ifaces[dev].forEach(function(details) {
                  if (details && details.address && details.address === defaultIp) {
                    ifacename = dev;
                  }
                });
              }
            }
          }
        }
        if (_linux) {
          let cmd = "ip route 2> /dev/null | grep default";
          let result = execSync(cmd, util.execOptsLinux);
          let parts = result.toString().split("\n")[0].split(/\s+/);
          if (parts[0] === "none" && parts[5]) {
            ifacename = parts[5];
          } else if (parts[4]) {
            ifacename = parts[4];
          }
          if (ifacename.indexOf(":") > -1) {
            ifacename = ifacename.split(":")[1].trim();
          }
        }
        if (_darwin || _freebsd || _openbsd || _netbsd || _sunos) {
          let cmd = "";
          if (_linux) {
            cmd = "ip route 2> /dev/null | grep default | awk '{print $5}'";
          }
          if (_darwin) {
            cmd = "route -n get default 2>/dev/null | grep interface: | awk '{print $2}'";
          }
          if (_freebsd || _openbsd || _netbsd || _sunos) {
            cmd = "route get 0.0.0.0 | grep interface:";
          }
          let result = execSync(cmd);
          ifacename = result.toString().split("\n")[0];
          if (ifacename.indexOf(":") > -1) {
            ifacename = ifacename.split(":")[1].trim();
          }
        }
      } catch (e) {
        util.noop();
      }
      if (ifacename) {
        _default_iface = ifacename;
      }
      return _default_iface;
    }
    exports.getDefaultNetworkInterface = getDefaultNetworkInterface;
    function getMacAddresses() {
      let iface = "";
      let mac = "";
      let result = {};
      if (_linux || _freebsd || _openbsd || _netbsd) {
        if (typeof pathToIp === "undefined") {
          try {
            const lines = execSync("which ip", util.execOptsLinux).toString().split("\n");
            if (lines.length && lines[0].indexOf(":") === -1 && lines[0].indexOf("/") === 0) {
              pathToIp = lines[0];
            } else {
              pathToIp = "";
            }
          } catch (e) {
            pathToIp = "";
          }
        }
        try {
          const cmd = "export LC_ALL=C; " + (pathToIp ? pathToIp + " link show up" : "/sbin/ifconfig") + "; unset LC_ALL";
          let res = execSync(cmd, util.execOptsLinux);
          const lines = res.toString().split("\n");
          for (let i = 0; i < lines.length; i++) {
            if (lines[i] && lines[i][0] !== " ") {
              if (pathToIp) {
                let nextline = lines[i + 1].trim().split(" ");
                if (nextline[0] === "link/ether") {
                  iface = lines[i].split(" ")[1];
                  iface = iface.slice(0, iface.length - 1);
                  mac = nextline[1];
                }
              } else {
                iface = lines[i].split(" ")[0];
                mac = lines[i].split("HWaddr ")[1];
              }
              if (iface && mac) {
                result[iface] = mac.trim();
                iface = "";
                mac = "";
              }
            }
          }
        } catch (e) {
          util.noop();
        }
      }
      if (_darwin) {
        try {
          const cmd = "/sbin/ifconfig";
          let res = execSync(cmd);
          const lines = res.toString().split("\n");
          for (let i = 0; i < lines.length; i++) {
            if (lines[i] && lines[i][0] !== "	" && lines[i].indexOf(":") > 0) {
              iface = lines[i].split(":")[0];
            } else if (lines[i].indexOf("	ether ") === 0) {
              mac = lines[i].split("	ether ")[1];
              if (iface && mac) {
                result[iface] = mac.trim();
                iface = "";
                mac = "";
              }
            }
          }
        } catch (e) {
          util.noop();
        }
      }
      return result;
    }
    function networkInterfaceDefault(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = getDefaultNetworkInterface();
          if (callback) {
            callback(result);
          }
          resolve(result);
        });
      });
    }
    exports.networkInterfaceDefault = networkInterfaceDefault;
    function parseLinesWindowsNics(sections, nconfigsections) {
      let nics = [];
      for (let i in sections) {
        if ({}.hasOwnProperty.call(sections, i)) {
          if (sections[i].trim() !== "") {
            let lines = sections[i].trim().split("\r\n");
            let linesNicConfig = nconfigsections && nconfigsections[i] ? nconfigsections[i].trim().split("\r\n") : [];
            let netEnabled = util.getValue(lines, "NetEnabled", ":");
            let adapterType = util.getValue(lines, "AdapterTypeID", ":") === "9" ? "wireless" : "wired";
            let ifacename = util.getValue(lines, "Name", ":").replace(/\]/g, ")").replace(/\[/g, "(");
            let iface = util.getValue(lines, "NetConnectionID", ":").replace(/\]/g, ")").replace(/\[/g, "(");
            if (ifacename.toLowerCase().indexOf("wi-fi") >= 0 || ifacename.toLowerCase().indexOf("wireless") >= 0) {
              adapterType = "wireless";
            }
            if (netEnabled !== "") {
              const speed = parseInt(util.getValue(lines, "speed", ":").trim(), 10) / 1e6;
              nics.push({
                mac: util.getValue(lines, "MACAddress", ":").toLowerCase(),
                dhcp: util.getValue(linesNicConfig, "dhcpEnabled", ":").toLowerCase() === "true",
                name: ifacename,
                iface,
                netEnabled: netEnabled === "TRUE",
                speed: isNaN(speed) ? null : speed,
                operstate: util.getValue(lines, "NetConnectionStatus", ":") === "2" ? "up" : "down",
                type: adapterType
              });
            }
          }
        }
      }
      return nics;
    }
    function getWindowsNics() {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let cmd = "Get-CimInstance Win32_NetworkAdapter | fl *; echo '#-#-#-#';";
          cmd += "Get-CimInstance Win32_NetworkAdapterConfiguration | fl DHCPEnabled";
          try {
            util.powerShell(cmd).then((data) => {
              data = data.split("#-#-#-#");
              const nsections = (data[0] || "").split(/\n\s*\n/);
              const nconfigsections = (data[1] || "").split(/\n\s*\n/);
              resolve(parseLinesWindowsNics(nsections, nconfigsections));
            });
          } catch (e) {
            resolve([]);
          }
        });
      });
    }
    function getWindowsDNSsuffixes() {
      let iface = {};
      let dnsSuffixes = {
        primaryDNS: "",
        exitCode: 0,
        ifaces: []
      };
      try {
        const ipconfig = execSync("ipconfig /all", util.execOptsWin);
        const ipconfigArray = ipconfig.split("\r\n\r\n");
        ipconfigArray.forEach((element, index) => {
          if (index == 1) {
            const longPrimaryDNS = element.split("\r\n").filter((element2) => {
              return element2.toUpperCase().includes("DNS");
            });
            const primaryDNS = longPrimaryDNS[0].substring(longPrimaryDNS[0].lastIndexOf(":") + 1);
            dnsSuffixes.primaryDNS = primaryDNS.trim();
            if (!dnsSuffixes.primaryDNS) {
              dnsSuffixes.primaryDNS = "Not defined";
            }
          }
          if (index > 1) {
            if (index % 2 == 0) {
              const name = element.substring(element.lastIndexOf(" ") + 1).replace(":", "");
              iface.name = name;
            } else {
              const connectionSpecificDNS = element.split("\r\n").filter((element2) => {
                return element2.toUpperCase().includes("DNS");
              });
              const dnsSuffix = connectionSpecificDNS[0].substring(connectionSpecificDNS[0].lastIndexOf(":") + 1);
              iface.dnsSuffix = dnsSuffix.trim();
              dnsSuffixes.ifaces.push(iface);
              iface = {};
            }
          }
        });
        return dnsSuffixes;
      } catch (error) {
        return {
          primaryDNS: "",
          exitCode: 0,
          ifaces: []
        };
      }
    }
    function getWindowsIfaceDNSsuffix(ifaces, ifacename) {
      let dnsSuffix = "";
      const interfaceName = ifacename + ".";
      try {
        const connectionDnsSuffix = ifaces.filter((iface) => {
          return interfaceName.includes(iface.name + ".");
        }).map((iface) => iface.dnsSuffix);
        if (connectionDnsSuffix[0]) {
          dnsSuffix = connectionDnsSuffix[0];
        }
        if (!dnsSuffix) {
          dnsSuffix = "";
        }
        return dnsSuffix;
      } catch (error) {
        return "Unknown";
      }
    }
    function getWindowsWiredProfilesInformation() {
      try {
        const result = execSync("netsh lan show profiles", util.execOptsWin);
        const profileList = result.split("\r\nProfile on interface");
        return profileList;
      } catch (error) {
        if (error.status === 1 && error.stdout.includes("AutoConfig")) {
          return "Disabled";
        }
        return [];
      }
    }
    function getWindowsWirelessIfaceSSID(interfaceName) {
      try {
        const result = execSync(`netsh wlan show  interface name="${interfaceName}" | findstr "SSID"`, util.execOptsWin);
        const SSID = result.split("\r\n").shift();
        const parseSSID = SSID.split(":").pop();
        return parseSSID;
      } catch (error) {
        return "Unknown";
      }
    }
    function getWindowsIEEE8021x(connectionType, iface, ifaces) {
      let i8021x = {
        state: "Unknown",
        protocol: "Unknown"
      };
      if (ifaces === "Disabled") {
        i8021x.state = "Disabled";
        i8021x.protocol = "Not defined";
        return i8021x;
      }
      if (connectionType == "wired" && ifaces.length > 0) {
        try {
          const iface8021xInfo = ifaces.find((element) => {
            return element.includes(iface + "\r\n");
          });
          const arrayIface8021xInfo = iface8021xInfo.split("\r\n");
          const state8021x = arrayIface8021xInfo.find((element) => {
            return element.includes("802.1x");
          });
          if (state8021x.includes("Disabled")) {
            i8021x.state = "Disabled";
            i8021x.protocol = "Not defined";
          } else if (state8021x.includes("Enabled")) {
            const protocol8021x = arrayIface8021xInfo.find((element) => {
              return element.includes("EAP");
            });
            i8021x.protocol = protocol8021x.split(":").pop();
            i8021x.state = "Enabled";
          }
        } catch (error) {
          return i8021x;
        }
      } else if (connectionType == "wireless") {
        let i8021xState = "";
        let i8021xProtocol = "";
        try {
          const SSID = getWindowsWirelessIfaceSSID(iface);
          if (SSID !== "Unknown") {
            i8021xState = execSync(`netsh wlan show profiles "${SSID}" | findstr "802.1X"`, util.execOptsWin);
            i8021xProtocol = execSync(`netsh wlan show profiles "${SSID}" | findstr "EAP"`, util.execOptsWin);
          }
          if (i8021xState.includes(":") && i8021xProtocol.includes(":")) {
            i8021x.state = i8021xState.split(":").pop();
            i8021x.protocol = i8021xProtocol.split(":").pop();
          }
        } catch (error) {
          if (error.status === 1 && error.stdout.includes("AutoConfig")) {
            i8021x.state = "Disabled";
            i8021x.protocol = "Not defined";
          }
          return i8021x;
        }
      }
      return i8021x;
    }
    function splitSectionsNics(lines) {
      const result = [];
      let section = [];
      lines.forEach(function(line) {
        if (!line.startsWith("	") && !line.startsWith(" ")) {
          if (section.length) {
            result.push(section);
            section = [];
          }
        }
        section.push(line);
      });
      if (section.length) {
        result.push(section);
      }
      return result;
    }
    function parseLinesDarwinNics(sections) {
      let nics = [];
      sections.forEach((section) => {
        let nic = {
          iface: "",
          mtu: null,
          mac: "",
          ip6: "",
          ip4: "",
          speed: null,
          type: "",
          operstate: "",
          duplex: "",
          internal: false
        };
        const first = section[0];
        nic.iface = first.split(":")[0].trim();
        let parts = first.split("> mtu");
        nic.mtu = parts.length > 1 ? parseInt(parts[1], 10) : null;
        if (isNaN(nic.mtu)) {
          nic.mtu = null;
        }
        nic.internal = parts[0].toLowerCase().indexOf("loopback") > -1;
        section.forEach((line) => {
          if (line.trim().startsWith("ether ")) {
            nic.mac = line.split("ether ")[1].toLowerCase().trim();
          }
          if (line.trim().startsWith("inet6 ") && !nic.ip6) {
            nic.ip6 = line.split("inet6 ")[1].toLowerCase().split("%")[0].split(" ")[0];
          }
          if (line.trim().startsWith("inet ") && !nic.ip4) {
            nic.ip4 = line.split("inet ")[1].toLowerCase().split(" ")[0];
          }
        });
        let speed = util.getValue(section, "link rate");
        nic.speed = speed ? parseFloat(speed) : null;
        if (nic.speed === null) {
          speed = util.getValue(section, "uplink rate");
          nic.speed = speed ? parseFloat(speed) : null;
          if (nic.speed !== null && speed.toLowerCase().indexOf("gbps") >= 0) {
            nic.speed = nic.speed * 1e3;
          }
        } else {
          if (speed.toLowerCase().indexOf("gbps") >= 0) {
            nic.speed = nic.speed * 1e3;
          }
        }
        nic.type = util.getValue(section, "type").toLowerCase().indexOf("wi-fi") > -1 ? "wireless" : "wired";
        const operstate = util.getValue(section, "status").toLowerCase();
        nic.operstate = operstate === "active" ? "up" : operstate === "inactive" ? "down" : "unknown";
        nic.duplex = util.getValue(section, "media").toLowerCase().indexOf("half-duplex") > -1 ? "half" : "full";
        if (nic.ip6 || nic.ip4 || nic.mac) {
          nics.push(nic);
        }
      });
      return nics;
    }
    function getDarwinNics() {
      const cmd = "/sbin/ifconfig -v";
      try {
        const lines = execSync(cmd, { maxBuffer: 1024 * 2e4 }).toString().split("\n");
        const nsections = splitSectionsNics(lines);
        return parseLinesDarwinNics(nsections);
      } catch (e) {
        return [];
      }
    }
    function getLinuxIfaceConnectionName(interfaceName) {
      const cmd = `nmcli device status 2>/dev/null | grep ${interfaceName}`;
      try {
        const result = execSync(cmd, util.execOptsLinux).toString();
        const resultFormat = result.replace(/\s+/g, " ").trim();
        const connectionNameLines = resultFormat.split(" ").slice(3);
        const connectionName = connectionNameLines.join(" ");
        return connectionName != "--" ? connectionName : "";
      } catch (e) {
        return "";
      }
    }
    function checkLinuxDCHPInterfaces(file) {
      let result = [];
      try {
        let cmd = `cat ${file} 2> /dev/null | grep 'iface\\|source'`;
        const lines = execSync(cmd, util.execOptsLinux).toString().split("\n");
        lines.forEach((line) => {
          const parts = line.replace(/\s+/g, " ").trim().split(" ");
          if (parts.length >= 4) {
            if (line.toLowerCase().indexOf(" inet ") >= 0 && line.toLowerCase().indexOf("dhcp") >= 0) {
              result.push(parts[1]);
            }
          }
          if (line.toLowerCase().includes("source")) {
            let file2 = line.split(" ")[1];
            result = result.concat(checkLinuxDCHPInterfaces(file2));
          }
        });
      } catch (e) {
        util.noop();
      }
      return result;
    }
    function getLinuxDHCPNics() {
      let cmd = "ip a 2> /dev/null";
      let result = [];
      try {
        const lines = execSync(cmd, util.execOptsLinux).toString().split("\n");
        const nsections = splitSectionsNics(lines);
        result = parseLinuxDHCPNics(nsections);
      } catch (e) {
        util.noop();
      }
      try {
        result = checkLinuxDCHPInterfaces("/etc/network/interfaces");
      } catch (e) {
        util.noop();
      }
      return result;
    }
    function parseLinuxDHCPNics(sections) {
      const result = [];
      if (sections && sections.length) {
        sections.forEach((lines) => {
          if (lines && lines.length) {
            const parts = lines[0].split(":");
            if (parts.length > 2) {
              for (let line of lines) {
                if (line.indexOf(" inet ") >= 0 && line.indexOf(" dynamic ") >= 0) {
                  const parts2 = line.split(" ");
                  const nic = parts2[parts2.length - 1].trim();
                  result.push(nic);
                  break;
                }
              }
            }
          }
        });
      }
      return result;
    }
    function getLinuxIfaceDHCPstatus(iface, connectionName, DHCPNics) {
      let result = false;
      if (connectionName) {
        const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep ipv4.method;`;
        try {
          const lines = execSync(cmd, util.execOptsLinux).toString();
          const resultFormat = lines.replace(/\s+/g, " ").trim();
          let dhcStatus = resultFormat.split(" ").slice(1).toString();
          switch (dhcStatus) {
            case "auto":
              result = true;
              break;
            default:
              result = false;
              break;
          }
          return result;
        } catch (e) {
          return DHCPNics.indexOf(iface) >= 0;
        }
      } else {
        return DHCPNics.indexOf(iface) >= 0;
      }
    }
    function getDarwinIfaceDHCPstatus(iface) {
      let result = false;
      const cmd = `ipconfig getpacket "${iface}" 2>/dev/null | grep lease_time;`;
      try {
        const lines = execSync(cmd).toString().split("\n");
        if (lines.length && lines[0].startsWith("lease_time")) {
          result = true;
        }
      } catch (e) {
        util.noop();
      }
      return result;
    }
    function getLinuxIfaceDNSsuffix(connectionName) {
      if (connectionName) {
        const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep ipv4.dns-search;`;
        try {
          const result = execSync(cmd, util.execOptsLinux).toString();
          const resultFormat = result.replace(/\s+/g, " ").trim();
          const dnsSuffix = resultFormat.split(" ").slice(1).toString();
          return dnsSuffix == "--" ? "Not defined" : dnsSuffix;
        } catch (e) {
          return "Unknown";
        }
      } else {
        return "Unknown";
      }
    }
    function getLinuxIfaceIEEE8021xAuth(connectionName) {
      if (connectionName) {
        const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep 802-1x.eap;`;
        try {
          const result = execSync(cmd, util.execOptsLinux).toString();
          const resultFormat = result.replace(/\s+/g, " ").trim();
          const authenticationProtocol = resultFormat.split(" ").slice(1).toString();
          return authenticationProtocol == "--" ? "" : authenticationProtocol;
        } catch (e) {
          return "Not defined";
        }
      } else {
        return "Not defined";
      }
    }
    function getLinuxIfaceIEEE8021xState(authenticationProtocol) {
      if (authenticationProtocol) {
        if (authenticationProtocol == "Not defined") {
          return "Disabled";
        }
        return "Enabled";
      } else {
        return "Unknown";
      }
    }
    function testVirtualNic(iface, ifaceName, mac) {
      const virtualMacs = ["00:00:00:00:00:00", "00:03:FF", "00:05:69", "00:0C:29", "00:0F:4B", "00:13:07", "00:13:BE", "00:15:5d", "00:16:3E", "00:1C:42", "00:21:F6", "00:24:0B", "00:50:56", "00:A0:B1", "00:E0:C8", "08:00:27", "0A:00:27", "18:92:2C", "16:DF:49", "3C:F3:92", "54:52:00", "FC:15:97"];
      if (mac) {
        return virtualMacs.filter((item) => {
          return mac.toUpperCase().toUpperCase().startsWith(item.substring(0, mac.length));
        }).length > 0 || iface.toLowerCase().indexOf(" virtual ") > -1 || ifaceName.toLowerCase().indexOf(" virtual ") > -1 || iface.toLowerCase().indexOf("vethernet ") > -1 || ifaceName.toLowerCase().indexOf("vethernet ") > -1 || iface.toLowerCase().startsWith("veth") || ifaceName.toLowerCase().startsWith("veth") || iface.toLowerCase().startsWith("vboxnet") || ifaceName.toLowerCase().startsWith("vboxnet");
      } else {
        return false;
      }
    }
    function networkInterfaces(callback, rescan, defaultString) {
      if (typeof callback === "string") {
        defaultString = callback;
        rescan = true;
        callback = null;
      }
      if (typeof callback === "boolean") {
        rescan = callback;
        callback = null;
        defaultString = "";
      }
      if (typeof rescan === "undefined") {
        rescan = true;
      }
      defaultString = defaultString || "";
      defaultString = "" + defaultString;
      return new Promise((resolve) => {
        process.nextTick(() => {
          let ifaces = os2.networkInterfaces();
          let result = [];
          let nics = [];
          let dnsSuffixes = [];
          let nics8021xInfo = [];
          if (_darwin || _freebsd || _openbsd || _netbsd) {
            if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
              result = _networkInterfaces;
              if (callback) {
                callback(result);
              }
              resolve(result);
            } else {
              const defaultInterface = getDefaultNetworkInterface();
              _ifaces = JSON.parse(JSON.stringify(ifaces));
              nics = getDarwinNics();
              nics.forEach((nic) => {
                if ({}.hasOwnProperty.call(ifaces, nic.iface)) {
                  ifaces[nic.iface].forEach(function(details) {
                    if (details.family === "IPv4" || details.family === 4) {
                      nic.ip4subnet = details.netmask;
                    }
                    if (details.family === "IPv6" || details.family === 6) {
                      nic.ip6subnet = details.netmask;
                    }
                  });
                }
                let ifaceSanitized = "";
                const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(nic.iface);
                const l = util.mathMin(s.length, 2e3);
                for (let i = 0; i <= l; i++) {
                  if (s[i] !== void 0) {
                    ifaceSanitized = ifaceSanitized + s[i];
                  }
                }
                result.push({
                  iface: nic.iface,
                  ifaceName: nic.iface,
                  default: nic.iface === defaultInterface,
                  ip4: nic.ip4,
                  ip4subnet: nic.ip4subnet || "",
                  ip6: nic.ip6,
                  ip6subnet: nic.ip6subnet || "",
                  mac: nic.mac,
                  internal: nic.internal,
                  virtual: nic.internal ? false : testVirtualNic(nic.iface, nic.iface, nic.mac),
                  operstate: nic.operstate,
                  type: nic.type,
                  duplex: nic.duplex,
                  mtu: nic.mtu,
                  speed: nic.speed,
                  dhcp: getDarwinIfaceDHCPstatus(ifaceSanitized),
                  dnsSuffix: "",
                  ieee8021xAuth: "",
                  ieee8021xState: "",
                  carrierChanges: 0
                });
              });
              _networkInterfaces = result;
              if (defaultString.toLowerCase().indexOf("default") >= 0) {
                result = result.filter((item) => item.default);
                if (result.length > 0) {
                  result = result[0];
                } else {
                  result = [];
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_linux) {
            if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
              result = _networkInterfaces;
              if (callback) {
                callback(result);
              }
              resolve(result);
            } else {
              _ifaces = JSON.parse(JSON.stringify(ifaces));
              _dhcpNics = getLinuxDHCPNics();
              const defaultInterface = getDefaultNetworkInterface();
              for (let dev in ifaces) {
                let ip4 = "";
                let ip4subnet = "";
                let ip6 = "";
                let ip6subnet = "";
                let mac = "";
                let duplex = "";
                let mtu = "";
                let speed = null;
                let carrierChanges = 0;
                let dhcp = false;
                let dnsSuffix = "";
                let ieee8021xAuth = "";
                let ieee8021xState = "";
                let type = "";
                if ({}.hasOwnProperty.call(ifaces, dev)) {
                  let ifaceName = dev;
                  ifaces[dev].forEach(function(details) {
                    if (details.family === "IPv4" || details.family === 4) {
                      ip4 = details.address;
                      ip4subnet = details.netmask;
                    }
                    if (details.family === "IPv6" || details.family === 6) {
                      if (!ip6 || ip6.match(/^fe80::/i)) {
                        ip6 = details.address;
                        ip6subnet = details.netmask;
                      }
                    }
                    mac = details.mac;
                    const nodeMainVersion = parseInt(process.versions.node.split("."), 10);
                    if (mac.indexOf("00:00:0") > -1 && (_linux || _darwin) && !details.internal && nodeMainVersion >= 8 && nodeMainVersion <= 11) {
                      if (Object.keys(_mac).length === 0) {
                        _mac = getMacAddresses();
                      }
                      mac = _mac[dev] || "";
                    }
                  });
                  let iface = dev.split(":")[0].trim().toLowerCase();
                  let ifaceSanitized = "";
                  const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(iface);
                  const l = util.mathMin(s.length, 2e3);
                  for (let i = 0; i <= l; i++) {
                    if (s[i] !== void 0) {
                      ifaceSanitized = ifaceSanitized + s[i];
                    }
                  }
                  const cmd = `echo -n "addr_assign_type: "; cat /sys/class/net/${ifaceSanitized}/addr_assign_type 2>/dev/null; echo;
            echo -n "address: "; cat /sys/class/net/${ifaceSanitized}/address 2>/dev/null; echo;
            echo -n "addr_len: "; cat /sys/class/net/${ifaceSanitized}/addr_len 2>/dev/null; echo;
            echo -n "broadcast: "; cat /sys/class/net/${ifaceSanitized}/broadcast 2>/dev/null; echo;
            echo -n "carrier: "; cat /sys/class/net/${ifaceSanitized}/carrier 2>/dev/null; echo;
            echo -n "carrier_changes: "; cat /sys/class/net/${ifaceSanitized}/carrier_changes 2>/dev/null; echo;
            echo -n "dev_id: "; cat /sys/class/net/${ifaceSanitized}/dev_id 2>/dev/null; echo;
            echo -n "dev_port: "; cat /sys/class/net/${ifaceSanitized}/dev_port 2>/dev/null; echo;
            echo -n "dormant: "; cat /sys/class/net/${ifaceSanitized}/dormant 2>/dev/null; echo;
            echo -n "duplex: "; cat /sys/class/net/${ifaceSanitized}/duplex 2>/dev/null; echo;
            echo -n "flags: "; cat /sys/class/net/${ifaceSanitized}/flags 2>/dev/null; echo;
            echo -n "gro_flush_timeout: "; cat /sys/class/net/${ifaceSanitized}/gro_flush_timeout 2>/dev/null; echo;
            echo -n "ifalias: "; cat /sys/class/net/${ifaceSanitized}/ifalias 2>/dev/null; echo;
            echo -n "ifindex: "; cat /sys/class/net/${ifaceSanitized}/ifindex 2>/dev/null; echo;
            echo -n "iflink: "; cat /sys/class/net/${ifaceSanitized}/iflink 2>/dev/null; echo;
            echo -n "link_mode: "; cat /sys/class/net/${ifaceSanitized}/link_mode 2>/dev/null; echo;
            echo -n "mtu: "; cat /sys/class/net/${ifaceSanitized}/mtu 2>/dev/null; echo;
            echo -n "netdev_group: "; cat /sys/class/net/${ifaceSanitized}/netdev_group 2>/dev/null; echo;
            echo -n "operstate: "; cat /sys/class/net/${ifaceSanitized}/operstate 2>/dev/null; echo;
            echo -n "proto_down: "; cat /sys/class/net/${ifaceSanitized}/proto_down 2>/dev/null; echo;
            echo -n "speed: "; cat /sys/class/net/${ifaceSanitized}/speed 2>/dev/null; echo;
            echo -n "tx_queue_len: "; cat /sys/class/net/${ifaceSanitized}/tx_queue_len 2>/dev/null; echo;
            echo -n "type: "; cat /sys/class/net/${ifaceSanitized}/type 2>/dev/null; echo;
            echo -n "wireless: "; cat /proc/net/wireless 2>/dev/null | grep ${ifaceSanitized}; echo;
            echo -n "wirelessspeed: "; iw dev ${ifaceSanitized} link 2>&1 | grep bitrate; echo;`;
                  let lines = [];
                  try {
                    lines = execSync(cmd, util.execOptsLinux).toString().split("\n");
                    const connectionName = getLinuxIfaceConnectionName(ifaceSanitized);
                    dhcp = getLinuxIfaceDHCPstatus(ifaceSanitized, connectionName, _dhcpNics);
                    dnsSuffix = getLinuxIfaceDNSsuffix(connectionName);
                    ieee8021xAuth = getLinuxIfaceIEEE8021xAuth(connectionName);
                    ieee8021xState = getLinuxIfaceIEEE8021xState(ieee8021xAuth);
                  } catch (e) {
                    util.noop();
                  }
                  duplex = util.getValue(lines, "duplex");
                  duplex = duplex.startsWith("cat") ? "" : duplex;
                  mtu = parseInt(util.getValue(lines, "mtu"), 10);
                  let myspeed = parseInt(util.getValue(lines, "speed"), 10);
                  speed = isNaN(myspeed) ? null : myspeed;
                  let wirelessspeed = util.getValue(lines, "wirelessspeed").split("tx bitrate: ");
                  if (speed === null && wirelessspeed.length === 2) {
                    myspeed = parseFloat(wirelessspeed[1]);
                    speed = isNaN(myspeed) ? null : myspeed;
                  }
                  carrierChanges = parseInt(util.getValue(lines, "carrier_changes"), 10);
                  const operstate = util.getValue(lines, "operstate");
                  type = operstate === "up" ? util.getValue(lines, "wireless").trim() ? "wireless" : "wired" : "unknown";
                  if (ifaceSanitized === "lo" || ifaceSanitized.startsWith("bond")) {
                    type = "virtual";
                  }
                  let internal = ifaces[dev] && ifaces[dev][0] ? ifaces[dev][0].internal : false;
                  if (dev.toLowerCase().indexOf("loopback") > -1 || ifaceName.toLowerCase().indexOf("loopback") > -1) {
                    internal = true;
                  }
                  const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);
                  result.push({
                    iface: ifaceSanitized,
                    ifaceName,
                    default: iface === defaultInterface,
                    ip4,
                    ip4subnet,
                    ip6,
                    ip6subnet,
                    mac,
                    internal,
                    virtual,
                    operstate,
                    type,
                    duplex,
                    mtu,
                    speed,
                    dhcp,
                    dnsSuffix,
                    ieee8021xAuth,
                    ieee8021xState,
                    carrierChanges
                  });
                }
              }
              _networkInterfaces = result;
              if (defaultString.toLowerCase().indexOf("default") >= 0) {
                result = result.filter((item) => item.default);
                if (result.length > 0) {
                  result = result[0];
                } else {
                  result = [];
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_windows) {
            if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
              result = _networkInterfaces;
              if (callback) {
                callback(result);
              }
              resolve(result);
            } else {
              _ifaces = JSON.parse(JSON.stringify(ifaces));
              const defaultInterface = getDefaultNetworkInterface();
              getWindowsNics().then(function(nics2) {
                nics2.forEach((nic) => {
                  let found = false;
                  Object.keys(ifaces).forEach((key) => {
                    if (!found) {
                      ifaces[key].forEach((value) => {
                        if (Object.keys(value).indexOf("mac") >= 0) {
                          found = value["mac"] === nic.mac;
                        }
                      });
                    }
                  });
                  if (!found) {
                    ifaces[nic.name] = [{ mac: nic.mac }];
                  }
                });
                nics8021xInfo = getWindowsWiredProfilesInformation();
                dnsSuffixes = getWindowsDNSsuffixes();
                for (let dev in ifaces) {
                  let ifaceSanitized = "";
                  const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(dev);
                  const l = util.mathMin(s.length, 2e3);
                  for (let i = 0; i <= l; i++) {
                    if (s[i] !== void 0) {
                      ifaceSanitized = ifaceSanitized + s[i];
                    }
                  }
                  let iface = dev;
                  let ip4 = "";
                  let ip4subnet = "";
                  let ip6 = "";
                  let ip6subnet = "";
                  let mac = "";
                  let duplex = "";
                  let mtu = "";
                  let speed = null;
                  let carrierChanges = 0;
                  let operstate = "down";
                  let dhcp = false;
                  let dnsSuffix = "";
                  let ieee8021xAuth = "";
                  let ieee8021xState = "";
                  let type = "";
                  if ({}.hasOwnProperty.call(ifaces, dev)) {
                    let ifaceName = dev;
                    ifaces[dev].forEach(function(details) {
                      if (details.family === "IPv4" || details.family === 4) {
                        ip4 = details.address;
                        ip4subnet = details.netmask;
                      }
                      if (details.family === "IPv6" || details.family === 6) {
                        if (!ip6 || ip6.match(/^fe80::/i)) {
                          ip6 = details.address;
                          ip6subnet = details.netmask;
                        }
                      }
                      mac = details.mac;
                      const nodeMainVersion = parseInt(process.versions.node.split("."), 10);
                      if (mac.indexOf("00:00:0") > -1 && (_linux || _darwin) && !details.internal && nodeMainVersion >= 8 && nodeMainVersion <= 11) {
                        if (Object.keys(_mac).length === 0) {
                          _mac = getMacAddresses();
                        }
                        mac = _mac[dev] || "";
                      }
                    });
                    dnsSuffix = getWindowsIfaceDNSsuffix(dnsSuffixes.ifaces, ifaceSanitized);
                    let foundFirst = false;
                    nics2.forEach((detail) => {
                      if (detail.mac === mac && !foundFirst) {
                        iface = detail.iface || iface;
                        ifaceName = detail.name;
                        dhcp = detail.dhcp;
                        operstate = detail.operstate;
                        speed = operstate === "up" ? detail.speed : 0;
                        type = detail.type;
                        foundFirst = true;
                      }
                    });
                    if (dev.toLowerCase().indexOf("wlan") >= 0 || ifaceName.toLowerCase().indexOf("wlan") >= 0 || ifaceName.toLowerCase().indexOf("802.11n") >= 0 || ifaceName.toLowerCase().indexOf("wireless") >= 0 || ifaceName.toLowerCase().indexOf("wi-fi") >= 0 || ifaceName.toLowerCase().indexOf("wifi") >= 0) {
                      type = "wireless";
                    }
                    const IEEE8021x = getWindowsIEEE8021x(type, ifaceSanitized, nics8021xInfo);
                    ieee8021xAuth = IEEE8021x.protocol;
                    ieee8021xState = IEEE8021x.state;
                    let internal = ifaces[dev] && ifaces[dev][0] ? ifaces[dev][0].internal : false;
                    if (dev.toLowerCase().indexOf("loopback") > -1 || ifaceName.toLowerCase().indexOf("loopback") > -1) {
                      internal = true;
                    }
                    const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);
                    result.push({
                      iface,
                      ifaceName,
                      default: iface === defaultInterface,
                      ip4,
                      ip4subnet,
                      ip6,
                      ip6subnet,
                      mac,
                      internal,
                      virtual,
                      operstate,
                      type,
                      duplex,
                      mtu,
                      speed,
                      dhcp,
                      dnsSuffix,
                      ieee8021xAuth,
                      ieee8021xState,
                      carrierChanges
                    });
                  }
                }
                _networkInterfaces = result;
                if (defaultString.toLowerCase().indexOf("default") >= 0) {
                  result = result.filter((item) => item.default);
                  if (result.length > 0) {
                    result = result[0];
                  } else {
                    result = [];
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            }
          }
        });
      });
    }
    exports.networkInterfaces = networkInterfaces;
    function calcNetworkSpeed(iface, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors) {
      let result = {
        iface,
        operstate,
        rx_bytes,
        rx_dropped,
        rx_errors,
        tx_bytes,
        tx_dropped,
        tx_errors,
        rx_sec: null,
        tx_sec: null,
        ms: 0
      };
      if (_network[iface] && _network[iface].ms) {
        result.ms = Date.now() - _network[iface].ms;
        result.rx_sec = rx_bytes - _network[iface].rx_bytes >= 0 ? (rx_bytes - _network[iface].rx_bytes) / (result.ms / 1e3) : 0;
        result.tx_sec = tx_bytes - _network[iface].tx_bytes >= 0 ? (tx_bytes - _network[iface].tx_bytes) / (result.ms / 1e3) : 0;
        _network[iface].rx_bytes = rx_bytes;
        _network[iface].tx_bytes = tx_bytes;
        _network[iface].rx_sec = result.rx_sec;
        _network[iface].tx_sec = result.tx_sec;
        _network[iface].ms = Date.now();
        _network[iface].last_ms = result.ms;
        _network[iface].operstate = operstate;
      } else {
        if (!_network[iface]) {
          _network[iface] = {};
        }
        _network[iface].rx_bytes = rx_bytes;
        _network[iface].tx_bytes = tx_bytes;
        _network[iface].rx_sec = null;
        _network[iface].tx_sec = null;
        _network[iface].ms = Date.now();
        _network[iface].last_ms = 0;
        _network[iface].operstate = operstate;
      }
      return result;
    }
    function networkStats(ifaces, callback) {
      let ifacesArray = [];
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (util.isFunction(ifaces) && !callback) {
            callback = ifaces;
            ifacesArray = [getDefaultNetworkInterface()];
          } else {
            if (typeof ifaces !== "string" && ifaces !== void 0) {
              if (callback) {
                callback([]);
              }
              return resolve([]);
            }
            ifaces = ifaces || getDefaultNetworkInterface();
            ifaces.__proto__.toLowerCase = util.stringToLower;
            ifaces.__proto__.replace = util.stringReplace;
            ifaces.__proto__.trim = util.stringTrim;
            ifaces = ifaces.trim().toLowerCase().replace(/,+/g, "|");
            ifacesArray = ifaces.split("|");
          }
          const result = [];
          const workload = [];
          if (ifacesArray.length && ifacesArray[0].trim() === "*") {
            ifacesArray = [];
            networkInterfaces(false).then((allIFaces) => {
              for (let iface of allIFaces) {
                ifacesArray.push(iface.iface);
              }
              networkStats(ifacesArray.join(",")).then((result2) => {
                if (callback) {
                  callback(result2);
                }
                resolve(result2);
              });
            });
          } else {
            for (let iface of ifacesArray) {
              workload.push(networkStatsSingle(iface.trim()));
            }
            if (workload.length) {
              Promise.all(
                workload
              ).then((data) => {
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    function networkStatsSingle(iface) {
      function parseLinesWindowsPerfData(sections) {
        let perfData = [];
        for (let i in sections) {
          if ({}.hasOwnProperty.call(sections, i)) {
            if (sections[i].trim() !== "") {
              let lines = sections[i].trim().split("\r\n");
              perfData.push({
                name: util.getValue(lines, "Name", ":").replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase(),
                rx_bytes: parseInt(util.getValue(lines, "BytesReceivedPersec", ":"), 10),
                rx_errors: parseInt(util.getValue(lines, "PacketsReceivedErrors", ":"), 10),
                rx_dropped: parseInt(util.getValue(lines, "PacketsReceivedDiscarded", ":"), 10),
                tx_bytes: parseInt(util.getValue(lines, "BytesSentPersec", ":"), 10),
                tx_errors: parseInt(util.getValue(lines, "PacketsOutboundErrors", ":"), 10),
                tx_dropped: parseInt(util.getValue(lines, "PacketsOutboundDiscarded", ":"), 10)
              });
            }
          }
        }
        return perfData;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          let ifaceSanitized = "";
          const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(iface);
          const l = util.mathMin(s.length, 2e3);
          for (let i = 0; i <= l; i++) {
            if (s[i] !== void 0) {
              ifaceSanitized = ifaceSanitized + s[i];
            }
          }
          let result = {
            iface: ifaceSanitized,
            operstate: "unknown",
            rx_bytes: 0,
            rx_dropped: 0,
            rx_errors: 0,
            tx_bytes: 0,
            tx_dropped: 0,
            tx_errors: 0,
            rx_sec: null,
            tx_sec: null,
            ms: 0
          };
          let operstate = "unknown";
          let rx_bytes = 0;
          let tx_bytes = 0;
          let rx_dropped = 0;
          let rx_errors = 0;
          let tx_dropped = 0;
          let tx_errors = 0;
          let cmd, lines, stats;
          if (!_network[ifaceSanitized] || _network[ifaceSanitized] && !_network[ifaceSanitized].ms || _network[ifaceSanitized] && _network[ifaceSanitized].ms && Date.now() - _network[ifaceSanitized].ms >= 500) {
            if (_linux) {
              if (fs.existsSync("/sys/class/net/" + ifaceSanitized)) {
                cmd = "cat /sys/class/net/" + ifaceSanitized + "/operstate; cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_bytes; cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_bytes; cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_dropped; cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_errors; cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_dropped; cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_errors; ";
                exec2(cmd, function(error, stdout) {
                  if (!error) {
                    lines = stdout.toString().split("\n");
                    operstate = lines[0].trim();
                    rx_bytes = parseInt(lines[1], 10);
                    tx_bytes = parseInt(lines[2], 10);
                    rx_dropped = parseInt(lines[3], 10);
                    rx_errors = parseInt(lines[4], 10);
                    tx_dropped = parseInt(lines[5], 10);
                    tx_errors = parseInt(lines[6], 10);
                    result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                  }
                  resolve(result);
                });
              } else {
                resolve(result);
              }
            }
            if (_freebsd || _openbsd || _netbsd) {
              cmd = "netstat -ibndI " + ifaceSanitized;
              exec2(cmd, function(error, stdout) {
                if (!error) {
                  lines = stdout.toString().split("\n");
                  for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].replace(/ +/g, " ").split(" ");
                    if (line && line[0] && line[7] && line[10]) {
                      rx_bytes = rx_bytes + parseInt(line[7]);
                      if (line[6].trim() !== "-") {
                        rx_dropped = rx_dropped + parseInt(line[6]);
                      }
                      if (line[5].trim() !== "-") {
                        rx_errors = rx_errors + parseInt(line[5]);
                      }
                      tx_bytes = tx_bytes + parseInt(line[10]);
                      if (line[12].trim() !== "-") {
                        tx_dropped = tx_dropped + parseInt(line[12]);
                      }
                      if (line[9].trim() !== "-") {
                        tx_errors = tx_errors + parseInt(line[9]);
                      }
                      operstate = "up";
                    }
                  }
                  result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                }
                resolve(result);
              });
            }
            if (_darwin) {
              cmd = "ifconfig " + ifaceSanitized + ' | grep "status"';
              exec2(cmd, function(error, stdout) {
                result.operstate = (stdout.toString().split(":")[1] || "").trim();
                result.operstate = (result.operstate || "").toLowerCase();
                result.operstate = result.operstate === "active" ? "up" : result.operstate === "inactive" ? "down" : "unknown";
                cmd = "netstat -bdI " + ifaceSanitized;
                exec2(cmd, function(error2, stdout2) {
                  if (!error2) {
                    lines = stdout2.toString().split("\n");
                    if (lines.length > 1 && lines[1].trim() !== "") {
                      stats = lines[1].replace(/ +/g, " ").split(" ");
                      const offset = stats.length > 11 ? 1 : 0;
                      rx_bytes = parseInt(stats[offset + 5]);
                      rx_dropped = parseInt(stats[offset + 10]);
                      rx_errors = parseInt(stats[offset + 4]);
                      tx_bytes = parseInt(stats[offset + 8]);
                      tx_dropped = parseInt(stats[offset + 10]);
                      tx_errors = parseInt(stats[offset + 7]);
                      result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, result.operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                    }
                  }
                  resolve(result);
                });
              });
            }
            if (_windows) {
              let perfData = [];
              let ifaceName = ifaceSanitized;
              util.powerShell("Get-CimInstance Win32_PerfRawData_Tcpip_NetworkInterface | select Name,BytesReceivedPersec,PacketsReceivedErrors,PacketsReceivedDiscarded,BytesSentPersec,PacketsOutboundErrors,PacketsOutboundDiscarded | fl").then((stdout, error) => {
                if (!error) {
                  const psections = stdout.toString().split(/\n\s*\n/);
                  perfData = parseLinesWindowsPerfData(psections);
                }
                networkInterfaces(false).then((interfaces) => {
                  rx_bytes = 0;
                  tx_bytes = 0;
                  perfData.forEach((detail) => {
                    interfaces.forEach((det) => {
                      if ((det.iface.toLowerCase() === ifaceSanitized.toLowerCase() || det.mac.toLowerCase() === ifaceSanitized.toLowerCase() || det.ip4.toLowerCase() === ifaceSanitized.toLowerCase() || det.ip6.toLowerCase() === ifaceSanitized.toLowerCase() || det.ifaceName.replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase() === ifaceSanitized.replace(/[()[\] ]+/g, "").replace("#", "_").toLowerCase()) && det.ifaceName.replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase() === detail.name) {
                        ifaceName = det.iface;
                        rx_bytes = detail.rx_bytes;
                        rx_dropped = detail.rx_dropped;
                        rx_errors = detail.rx_errors;
                        tx_bytes = detail.tx_bytes;
                        tx_dropped = detail.tx_dropped;
                        tx_errors = detail.tx_errors;
                        operstate = det.operstate;
                      }
                    });
                  });
                  if (rx_bytes && tx_bytes) {
                    result = calcNetworkSpeed(ifaceName, parseInt(rx_bytes), parseInt(tx_bytes), operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                  }
                  resolve(result);
                });
              });
            }
          } else {
            result.rx_bytes = _network[ifaceSanitized].rx_bytes;
            result.tx_bytes = _network[ifaceSanitized].tx_bytes;
            result.rx_sec = _network[ifaceSanitized].rx_sec;
            result.tx_sec = _network[ifaceSanitized].tx_sec;
            result.ms = _network[ifaceSanitized].last_ms;
            result.operstate = _network[ifaceSanitized].operstate;
            resolve(result);
          }
        });
      });
    }
    exports.networkStats = networkStats;
    function getProcessName(processes, pid) {
      let cmd = "";
      processes.forEach((line) => {
        const parts = line.split(" ");
        const id = parseInt(parts[0], 10) || -1;
        if (id === pid) {
          parts.shift();
          cmd = parts.join(" ").split(":")[0];
        }
      });
      cmd = cmd.split(" -")[0];
      const cmdParts = cmd.split("/");
      return cmdParts[cmdParts.length - 1];
    }
    function networkConnections(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = [];
          if (_linux || _freebsd || _openbsd || _netbsd) {
            let cmd = 'export LC_ALL=C; netstat -tunap | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"; unset LC_ALL';
            if (_freebsd || _openbsd || _netbsd) {
              cmd = 'export LC_ALL=C; netstat -na | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"; unset LC_ALL';
            }
            exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
              let lines = stdout.toString().split("\n");
              if (!error && (lines.length > 1 || lines[0] != "")) {
                lines.forEach(function(line) {
                  line = line.replace(/ +/g, " ").split(" ");
                  if (line.length >= 7) {
                    let localip = line[3];
                    let localport = "";
                    let localaddress = line[3].split(":");
                    if (localaddress.length > 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(":");
                    }
                    let peerip = line[4];
                    let peerport = "";
                    let peeraddress = line[4].split(":");
                    if (peeraddress.length > 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(":");
                    }
                    let connstate = line[5];
                    let proc = line[6].split("/");
                    if (connstate) {
                      result.push({
                        protocol: line[0],
                        localAddress: localip,
                        localPort: localport,
                        peerAddress: peerip,
                        peerPort: peerport,
                        state: connstate,
                        pid: proc[0] && proc[0] !== "-" ? parseInt(proc[0], 10) : null,
                        process: proc[1] ? proc[1].split(" ")[0].split(":")[0] : ""
                      });
                    }
                  }
                });
                if (callback) {
                  callback(result);
                }
                resolve(result);
              } else {
                cmd = 'ss -tunap | grep "ESTAB\\|SYN-SENT\\|SYN-RECV\\|FIN-WAIT1\\|FIN-WAIT2\\|TIME-WAIT\\|CLOSE\\|CLOSE-WAIT\\|LAST-ACK\\|LISTEN\\|CLOSING"';
                exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                  if (!error2) {
                    let lines2 = stdout2.toString().split("\n");
                    lines2.forEach(function(line) {
                      line = line.replace(/ +/g, " ").split(" ");
                      if (line.length >= 6) {
                        let localip = line[4];
                        let localport = "";
                        let localaddress = line[4].split(":");
                        if (localaddress.length > 1) {
                          localport = localaddress[localaddress.length - 1];
                          localaddress.pop();
                          localip = localaddress.join(":");
                        }
                        let peerip = line[5];
                        let peerport = "";
                        let peeraddress = line[5].split(":");
                        if (peeraddress.length > 1) {
                          peerport = peeraddress[peeraddress.length - 1];
                          peeraddress.pop();
                          peerip = peeraddress.join(":");
                        }
                        let connstate = line[1];
                        if (connstate === "ESTAB") {
                          connstate = "ESTABLISHED";
                        }
                        if (connstate === "TIME-WAIT") {
                          connstate = "TIME_WAIT";
                        }
                        let pid = null;
                        let process2 = "";
                        if (line.length >= 7 && line[6].indexOf("users:") > -1) {
                          let proc = line[6].replace('users:(("', "").replace(/"/g, "").split(",");
                          if (proc.length > 2) {
                            process2 = proc[0].split(" ")[0].split(":")[0];
                            pid = parseInt(proc[1], 10);
                          }
                        }
                        if (connstate) {
                          result.push({
                            protocol: line[0],
                            localAddress: localip,
                            localPort: localport,
                            peerAddress: peerip,
                            peerPort: peerport,
                            state: connstate,
                            pid,
                            process: process2
                          });
                        }
                      }
                    });
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              }
            });
          }
          if (_darwin) {
            let cmd = 'netstat -natvln | grep "tcp4\\|tcp6\\|udp4\\|udp6"';
            const states = "ESTABLISHED|SYN_SENT|SYN_RECV|FIN_WAIT1|FIN_WAIT2|TIME_WAIT|CLOSE|CLOSE_WAIT|LAST_ACK|LISTEN|CLOSING|UNKNOWN";
            exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
              if (!error) {
                exec2("ps -axo pid,command", { maxBuffer: 1024 * 2e4 }, function(err2, stdout2) {
                  let processes = stdout2.toString().split("\n");
                  processes = processes.map((line) => {
                    return line.trim().replace(/ +/g, " ");
                  });
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    line = line.replace(/ +/g, " ").split(" ");
                    if (line.length >= 8) {
                      let localip = line[3];
                      let localport = "";
                      let localaddress = line[3].split(".");
                      if (localaddress.length > 1) {
                        localport = localaddress[localaddress.length - 1];
                        localaddress.pop();
                        localip = localaddress.join(".");
                      }
                      let peerip = line[4];
                      let peerport = "";
                      let peeraddress = line[4].split(".");
                      if (peeraddress.length > 1) {
                        peerport = peeraddress[peeraddress.length - 1];
                        peeraddress.pop();
                        peerip = peeraddress.join(".");
                      }
                      const hasState = states.indexOf(line[5]) >= 0;
                      let connstate = hasState ? line[5] : "UNKNOWN";
                      let pid = parseInt(line[8 + (hasState ? 0 : -1)], 10);
                      if (connstate) {
                        result.push({
                          protocol: line[0],
                          localAddress: localip,
                          localPort: localport,
                          peerAddress: peerip,
                          peerPort: peerport,
                          state: connstate,
                          pid,
                          process: getProcessName(processes, pid)
                        });
                      }
                    }
                  });
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              }
            });
          }
          if (_windows) {
            let cmd = "netstat -nao";
            try {
              exec2(cmd, util.execOptsWin, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\r\n");
                  lines.forEach(function(line) {
                    line = line.trim().replace(/ +/g, " ").split(" ");
                    if (line.length >= 4) {
                      let localip = line[1];
                      let localport = "";
                      let localaddress = line[1].split(":");
                      if (localaddress.length > 1) {
                        localport = localaddress[localaddress.length - 1];
                        localaddress.pop();
                        localip = localaddress.join(":");
                      }
                      localip = localip.replace(/\[/g, "").replace(/\]/g, "");
                      let peerip = line[2];
                      let peerport = "";
                      let peeraddress = line[2].split(":");
                      if (peeraddress.length > 1) {
                        peerport = peeraddress[peeraddress.length - 1];
                        peeraddress.pop();
                        peerip = peeraddress.join(":");
                      }
                      peerip = peerip.replace(/\[/g, "").replace(/\]/g, "");
                      let pid = util.toInt(line[4]);
                      let connstate = line[3];
                      if (connstate === "HERGESTELLT") {
                        connstate = "ESTABLISHED";
                      }
                      if (connstate.startsWith("ABH")) {
                        connstate = "LISTEN";
                      }
                      if (connstate === "SCHLIESSEN_WARTEN") {
                        connstate = "CLOSE_WAIT";
                      }
                      if (connstate === "WARTEND") {
                        connstate = "TIME_WAIT";
                      }
                      if (connstate === "SYN_GESENDET") {
                        connstate = "SYN_SENT";
                      }
                      if (connstate === "LISTENING") {
                        connstate = "LISTEN";
                      }
                      if (connstate === "SYN_RECEIVED") {
                        connstate = "SYN_RECV";
                      }
                      if (connstate === "FIN_WAIT_1") {
                        connstate = "FIN_WAIT1";
                      }
                      if (connstate === "FIN_WAIT_2") {
                        connstate = "FIN_WAIT2";
                      }
                      if (line[0].toLowerCase() !== "udp" && connstate) {
                        result.push({
                          protocol: line[0].toLowerCase(),
                          localAddress: localip,
                          localPort: localport,
                          peerAddress: peerip,
                          peerPort: peerport,
                          state: connstate,
                          pid,
                          process: ""
                        });
                      } else if (line[0].toLowerCase() === "udp") {
                        result.push({
                          protocol: line[0].toLowerCase(),
                          localAddress: localip,
                          localPort: localport,
                          peerAddress: peerip,
                          peerPort: peerport,
                          state: "",
                          pid: parseInt(line[3], 10),
                          process: ""
                        });
                      }
                    }
                  });
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.networkConnections = networkConnections;
    function networkGatewayDefault(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = "";
          if (_linux || _freebsd || _openbsd || _netbsd) {
            let cmd = "ip route get 1";
            try {
              exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  const line = lines && lines[0] ? lines[0] : "";
                  let parts = line.split(" via ");
                  if (parts && parts[1]) {
                    parts = parts[1].split(" ");
                    result = parts[0];
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_darwin) {
            let cmd = "route -n get default";
            try {
              exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
                if (!error) {
                  const lines = stdout.toString().split("\n").map((line) => line.trim());
                  result = util.getValue(lines, "gateway");
                }
                if (!result) {
                  cmd = "netstat -rn | awk '/default/ {print $2}'";
                  exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                    const lines = stdout2.toString().split("\n").map((line) => line.trim());
                    result = lines.find((line) => /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(line));
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
          if (_windows) {
            try {
              exec2("netstat -r", util.execOptsWin, function(error, stdout) {
                const lines = stdout.toString().split(os2.EOL);
                lines.forEach((line) => {
                  line = line.replace(/\s+/g, " ").trim();
                  if (line.indexOf("0.0.0.0 0.0.0.0") > -1 && !/[a-zA-Z]/.test(line)) {
                    const parts = line.split(" ");
                    if (parts.length >= 5 && parts[parts.length - 3].indexOf(".") > -1) {
                      result = parts[parts.length - 3];
                    }
                  }
                });
                if (!result) {
                  util.powerShell("Get-CimInstance -ClassName Win32_IP4RouteTable | Where-Object { $_.Destination -eq '0.0.0.0' -and $_.Mask -eq '0.0.0.0' }").then((data) => {
                    let lines2 = data.toString().split("\r\n");
                    if (lines2.length > 1 && !result) {
                      result = util.getValue(lines2, "NextHop");
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    }
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.networkGatewayDefault = networkGatewayDefault;
  }
});

// node_modules/systeminformation/lib/wifi.js
var require_wifi = __commonJS({
  "node_modules/systeminformation/lib/wifi.js"(exports) {
    "use strict";
    var os2 = require("os");
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    function wifiDBFromQuality(quality) {
      const qual = parseFloat(quality);
      if (qual < 0) {
        return 0;
      }
      if (qual >= 100) {
        return -50;
      }
      return qual / 2 - 100;
    }
    function wifiQualityFromDB(db) {
      const result = 2 * (parseFloat(db) + 100);
      return result <= 100 ? result : 100;
    }
    var _wifi_frequencies = {
      1: 2412,
      2: 2417,
      3: 2422,
      4: 2427,
      5: 2432,
      6: 2437,
      7: 2442,
      8: 2447,
      9: 2452,
      10: 2457,
      11: 2462,
      12: 2467,
      13: 2472,
      14: 2484,
      32: 5160,
      34: 5170,
      36: 5180,
      38: 5190,
      40: 5200,
      42: 5210,
      44: 5220,
      46: 5230,
      48: 5240,
      50: 5250,
      52: 5260,
      54: 5270,
      56: 5280,
      58: 5290,
      60: 5300,
      62: 5310,
      64: 5320,
      68: 5340,
      96: 5480,
      100: 5500,
      102: 5510,
      104: 5520,
      106: 5530,
      108: 5540,
      110: 5550,
      112: 5560,
      114: 5570,
      116: 5580,
      118: 5590,
      120: 5600,
      122: 5610,
      124: 5620,
      126: 5630,
      128: 5640,
      132: 5660,
      134: 5670,
      136: 5680,
      138: 5690,
      140: 5700,
      142: 5710,
      144: 5720,
      149: 5745,
      151: 5755,
      153: 5765,
      155: 5775,
      157: 5785,
      159: 5795,
      161: 5805,
      165: 5825,
      169: 5845,
      173: 5865,
      183: 4915,
      184: 4920,
      185: 4925,
      187: 4935,
      188: 4940,
      189: 4945,
      192: 4960,
      196: 4980
    };
    function wifiFrequencyFromChannel(channel) {
      return {}.hasOwnProperty.call(_wifi_frequencies, channel) ? _wifi_frequencies[channel] : null;
    }
    function wifiChannelFromFrequencs(frequency) {
      let channel = 0;
      for (let key in _wifi_frequencies) {
        if ({}.hasOwnProperty.call(_wifi_frequencies, key)) {
          if (_wifi_frequencies[key] === frequency) {
            channel = util.toInt(key);
          }
        }
      }
      return channel;
    }
    function ifaceListLinux() {
      const result = [];
      const cmd = "iw dev 2>/dev/null";
      try {
        const all = execSync(cmd, util.execOptsLinux).toString().split("\n").map((line) => line.trim()).join("\n");
        const parts = all.split("\nInterface ");
        parts.shift();
        parts.forEach((ifaceDetails) => {
          const lines = ifaceDetails.split("\n");
          const iface = lines[0];
          const id = util.toInt(util.getValue(lines, "ifindex", " "));
          const mac = util.getValue(lines, "addr", " ");
          const channel = util.toInt(util.getValue(lines, "channel", " "));
          result.push({
            id,
            iface,
            mac,
            channel
          });
        });
        return result;
      } catch (e) {
        try {
          const all = execSync("nmcli -t -f general,wifi-properties,wired-properties,interface-flags,capabilities,nsp device show 2>/dev/null", util.execOptsLinux).toString();
          const parts = all.split("\n\n");
          let i = 1;
          parts.forEach((ifaceDetails) => {
            const lines = ifaceDetails.split("\n");
            const iface = util.getValue(lines, "GENERAL.DEVICE");
            const type = util.getValue(lines, "GENERAL.TYPE");
            const id = i++;
            const mac = util.getValue(lines, "GENERAL.HWADDR");
            const channel = "";
            if (type.toLowerCase() === "wifi") {
              result.push({
                id,
                iface,
                mac,
                channel
              });
            }
          });
          return result;
        } catch (e2) {
          return [];
        }
      }
    }
    function nmiDeviceLinux(iface) {
      const cmd = `nmcli -t -f general,wifi-properties,capabilities,ip4,ip6 device show ${iface} 2>/dev/null`;
      try {
        const lines = execSync(cmd, util.execOptsLinux).toString().split("\n");
        const ssid = util.getValue(lines, "GENERAL.CONNECTION");
        return {
          iface,
          type: util.getValue(lines, "GENERAL.TYPE"),
          vendor: util.getValue(lines, "GENERAL.VENDOR"),
          product: util.getValue(lines, "GENERAL.PRODUCT"),
          mac: util.getValue(lines, "GENERAL.HWADDR").toLowerCase(),
          ssid: ssid !== "--" ? ssid : null
        };
      } catch (e) {
        return {};
      }
    }
    function nmiConnectionLinux(ssid) {
      const cmd = `nmcli -t --show-secrets connection show ${ssid} 2>/dev/null`;
      try {
        const lines = execSync(cmd, util.execOptsLinux).toString().split("\n");
        const bssid = util.getValue(lines, "802-11-wireless.seen-bssids").toLowerCase();
        return {
          ssid: ssid !== "--" ? ssid : null,
          uuid: util.getValue(lines, "connection.uuid"),
          type: util.getValue(lines, "connection.type"),
          autoconnect: util.getValue(lines, "connection.autoconnect") === "yes",
          security: util.getValue(lines, "802-11-wireless-security.key-mgmt"),
          bssid: bssid !== "--" ? bssid : null
        };
      } catch (e) {
        return {};
      }
    }
    function wpaConnectionLinux(iface) {
      if (!iface) {
        return {};
      }
      const cmd = `wpa_cli -i ${iface} status 2>&1`;
      try {
        const lines = execSync(cmd, util.execOptsLinux).toString().split("\n");
        const freq = util.toInt(util.getValue(lines, "freq", "="));
        return {
          ssid: util.getValue(lines, "ssid", "="),
          uuid: util.getValue(lines, "uuid", "="),
          security: util.getValue(lines, "key_mgmt", "="),
          freq,
          channel: wifiChannelFromFrequencs(freq),
          bssid: util.getValue(lines, "bssid", "=").toLowerCase()
        };
      } catch (e) {
        return {};
      }
    }
    function getWifiNetworkListNmi() {
      const result = [];
      const cmd = "nmcli -t -m multiline --fields active,ssid,bssid,mode,chan,freq,signal,security,wpa-flags,rsn-flags device wifi list 2>/dev/null";
      try {
        const stdout = execSync(cmd, util.execOptsLinux);
        const parts = stdout.toString().split("ACTIVE:");
        parts.shift();
        parts.forEach((part) => {
          part = "ACTIVE:" + part;
          const lines = part.split(os2.EOL);
          const channel = util.getValue(lines, "CHAN");
          const frequency = util.getValue(lines, "FREQ").toLowerCase().replace("mhz", "").trim();
          const security = util.getValue(lines, "SECURITY").replace("(", "").replace(")", "");
          const wpaFlags = util.getValue(lines, "WPA-FLAGS").replace("(", "").replace(")", "");
          const rsnFlags = util.getValue(lines, "RSN-FLAGS").replace("(", "").replace(")", "");
          const quality = util.getValue(lines, "SIGNAL");
          result.push({
            ssid: util.getValue(lines, "SSID"),
            bssid: util.getValue(lines, "BSSID").toLowerCase(),
            mode: util.getValue(lines, "MODE"),
            channel: channel ? parseInt(channel, 10) : null,
            frequency: frequency ? parseInt(frequency, 10) : null,
            signalLevel: wifiDBFromQuality(quality),
            quality: quality ? parseInt(quality, 10) : null,
            security: security && security !== "none" ? security.split(" ") : [],
            wpaFlags: wpaFlags && wpaFlags !== "none" ? wpaFlags.split(" ") : [],
            rsnFlags: rsnFlags && rsnFlags !== "none" ? rsnFlags.split(" ") : []
          });
        });
        return result;
      } catch (e) {
        return [];
      }
    }
    function getWifiNetworkListIw(iface) {
      const result = [];
      try {
        let iwlistParts = execSync(`export LC_ALL=C; iwlist ${iface} scan 2>&1; unset LC_ALL`, util.execOptsLinux).toString().split("        Cell ");
        if (iwlistParts[0].indexOf("resource busy") >= 0) {
          return -1;
        }
        if (iwlistParts.length > 1) {
          iwlistParts.shift();
          iwlistParts.forEach((element) => {
            const lines = element.split("\n");
            const channel = util.getValue(lines, "channel", ":", true);
            const address = lines && lines.length && lines[0].indexOf("Address:") >= 0 ? lines[0].split("Address:")[1].trim().toLowerCase() : "";
            const mode = util.getValue(lines, "mode", ":", true);
            const frequency = util.getValue(lines, "frequency", ":", true);
            const qualityString = util.getValue(lines, "Quality", "=", true);
            const dbParts = qualityString.toLowerCase().split("signal level=");
            const db = dbParts.length > 1 ? util.toInt(dbParts[1]) : 0;
            const quality = db ? wifiQualityFromDB(db) : 0;
            const ssid = util.getValue(lines, "essid", ":", true);
            const isWpa = element.indexOf(" WPA ") >= 0;
            const isWpa2 = element.indexOf("WPA2 ") >= 0;
            const security = [];
            if (isWpa) {
              security.push("WPA");
            }
            if (isWpa2) {
              security.push("WPA2");
            }
            const wpaFlags = [];
            let wpaFlag = "";
            lines.forEach(function(line) {
              const l = line.trim().toLowerCase();
              if (l.indexOf("group cipher") >= 0) {
                if (wpaFlag) {
                  wpaFlags.push(wpaFlag);
                }
                const parts = l.split(":");
                if (parts.length > 1) {
                  wpaFlag = parts[1].trim().toUpperCase();
                }
              }
              if (l.indexOf("pairwise cipher") >= 0) {
                const parts = l.split(":");
                if (parts.length > 1) {
                  if (parts[1].indexOf("tkip")) {
                    wpaFlag = wpaFlag ? "TKIP/" + wpaFlag : "TKIP";
                  } else if (parts[1].indexOf("ccmp")) {
                    wpaFlag = wpaFlag ? "CCMP/" + wpaFlag : "CCMP";
                  } else if (parts[1].indexOf("proprietary")) {
                    wpaFlag = wpaFlag ? "PROP/" + wpaFlag : "PROP";
                  }
                }
              }
              if (l.indexOf("authentication suites") >= 0) {
                const parts = l.split(":");
                if (parts.length > 1) {
                  if (parts[1].indexOf("802.1x")) {
                    wpaFlag = wpaFlag ? "802.1x/" + wpaFlag : "802.1x";
                  } else if (parts[1].indexOf("psk")) {
                    wpaFlag = wpaFlag ? "PSK/" + wpaFlag : "PSK";
                  }
                }
              }
            });
            if (wpaFlag) {
              wpaFlags.push(wpaFlag);
            }
            result.push({
              ssid,
              bssid: address,
              mode,
              channel: channel ? util.toInt(channel) : null,
              frequency: frequency ? util.toInt(frequency.replace(".", "")) : null,
              signalLevel: db,
              quality,
              security,
              wpaFlags,
              rsnFlags: []
            });
          });
        }
        return result;
      } catch (e) {
        return -1;
      }
    }
    function parseWifiDarwin(wifiObj) {
      const result = [];
      if (wifiObj) {
        wifiObj.forEach(function(wifiItem) {
          const signalLevel = wifiItem.RSSI;
          let security = [];
          let wpaFlags = [];
          let ssid = wifiItem.SSID_STR || "";
          if (wifiItem.WPA_IE) {
            security.push("WPA");
            if (wifiItem.WPA_IE.IE_KEY_WPA_UCIPHERS) {
              wifiItem.WPA_IE.IE_KEY_WPA_UCIPHERS.forEach(function(ciphers) {
                if (ciphers === 0 && wpaFlags.indexOf("unknown/TKIP") === -1) {
                  wpaFlags.push("unknown/TKIP");
                }
                if (ciphers === 2 && wpaFlags.indexOf("PSK/TKIP") === -1) {
                  wpaFlags.push("PSK/TKIP");
                }
                if (ciphers === 4 && wpaFlags.indexOf("PSK/AES") === -1) {
                  wpaFlags.push("PSK/AES");
                }
              });
            }
          }
          if (wifiItem.RSN_IE) {
            security.push("WPA2");
            if (wifiItem.RSN_IE.IE_KEY_RSN_UCIPHERS) {
              wifiItem.RSN_IE.IE_KEY_RSN_UCIPHERS.forEach(function(ciphers) {
                if (ciphers === 0 && wpaFlags.indexOf("unknown/TKIP") === -1) {
                  wpaFlags.push("unknown/TKIP");
                }
                if (ciphers === 2 && wpaFlags.indexOf("TKIP/TKIP") === -1) {
                  wpaFlags.push("TKIP/TKIP");
                }
                if (ciphers === 4 && wpaFlags.indexOf("PSK/AES") === -1) {
                  wpaFlags.push("PSK/AES");
                }
              });
            }
          }
          if (wifiItem.SSID && ssid === "") {
            try {
              ssid = Buffer.from(wifiItem.SSID, "base64").toString("utf8");
            } catch (err) {
              util.noop();
            }
          }
          result.push({
            ssid,
            bssid: wifiItem.BSSID || "",
            mode: "",
            channel: wifiItem.CHANNEL,
            frequency: wifiFrequencyFromChannel(wifiItem.CHANNEL),
            signalLevel: signalLevel ? parseInt(signalLevel, 10) : null,
            quality: wifiQualityFromDB(signalLevel),
            security,
            wpaFlags,
            rsnFlags: []
          });
        });
      }
      return result;
    }
    function wifiNetworks(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = [];
          if (_linux) {
            result = getWifiNetworkListNmi();
            if (result.length === 0) {
              try {
                const iwconfigParts = execSync("export LC_ALL=C; iwconfig 2>/dev/null; unset LC_ALL", util.execOptsLinux).toString().split("\n\n");
                let iface = "";
                iwconfigParts.forEach((element) => {
                  if (element.indexOf("no wireless") === -1 && element.trim() !== "") {
                    iface = element.split(" ")[0];
                  }
                });
                if (iface) {
                  let ifaceSanitized = "";
                  const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(iface, true);
                  const l = util.mathMin(s.length, 2e3);
                  for (let i = 0; i <= l; i++) {
                    if (s[i] !== void 0) {
                      ifaceSanitized = ifaceSanitized + s[i];
                    }
                  }
                  const res = getWifiNetworkListIw(ifaceSanitized);
                  if (res === -1) {
                    setTimeout(function(iface2) {
                      const res2 = getWifiNetworkListIw(iface2);
                      if (res2 != -1) {
                        result = res2;
                      }
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    }, 4e3);
                  } else {
                    result = res;
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              } catch (e) {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          } else if (_darwin) {
            let cmd = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s -x";
            exec2(cmd, { maxBuffer: 1024 * 4e4 }, function(error, stdout) {
              const output = stdout.toString();
              result = parseWifiDarwin(util.plistParser(output));
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } else if (_windows) {
            let cmd = "netsh wlan show networks mode=Bssid";
            util.powerShell(cmd).then((stdout) => {
              const ssidParts = stdout.toString("utf8").split(os2.EOL + os2.EOL + "SSID ");
              ssidParts.shift();
              ssidParts.forEach((ssidPart) => {
                const ssidLines = ssidPart.split(os2.EOL);
                if (ssidLines && ssidLines.length >= 8 && ssidLines[0].indexOf(":") >= 0) {
                  const bssidsParts = ssidPart.split(" BSSID");
                  bssidsParts.shift();
                  bssidsParts.forEach((bssidPart) => {
                    const bssidLines = bssidPart.split(os2.EOL);
                    const bssidLine = bssidLines[0].split(":");
                    bssidLine.shift();
                    const bssid = bssidLine.join(":").trim().toLowerCase();
                    const channel = bssidLines[3].split(":").pop().trim();
                    const quality = bssidLines[1].split(":").pop().trim();
                    result.push({
                      ssid: ssidLines[0].split(":").pop().trim(),
                      bssid,
                      mode: "",
                      channel: channel ? parseInt(channel, 10) : null,
                      frequency: wifiFrequencyFromChannel(channel),
                      signalLevel: wifiDBFromQuality(quality),
                      quality: quality ? parseInt(quality, 10) : null,
                      security: [ssidLines[2].split(":").pop().trim()],
                      wpaFlags: [ssidLines[3].split(":").pop().trim()],
                      rsnFlags: []
                    });
                  });
                }
              });
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.wifiNetworks = wifiNetworks;
    function getVendor(model) {
      model = model.toLowerCase();
      let result = "";
      if (model.indexOf("intel") >= 0) {
        result = "Intel";
      } else if (model.indexOf("realtek") >= 0) {
        result = "Realtek";
      } else if (model.indexOf("qualcom") >= 0) {
        result = "Qualcom";
      } else if (model.indexOf("broadcom") >= 0) {
        result = "Broadcom";
      } else if (model.indexOf("cavium") >= 0) {
        result = "Cavium";
      } else if (model.indexOf("cisco") >= 0) {
        result = "Cisco";
      } else if (model.indexOf("marvel") >= 0) {
        result = "Marvel";
      } else if (model.indexOf("zyxel") >= 0) {
        result = "Zyxel";
      } else if (model.indexOf("melanox") >= 0) {
        result = "Melanox";
      } else if (model.indexOf("d-link") >= 0) {
        result = "D-Link";
      } else if (model.indexOf("tp-link") >= 0) {
        result = "TP-Link";
      } else if (model.indexOf("asus") >= 0) {
        result = "Asus";
      } else if (model.indexOf("linksys") >= 0) {
        result = "Linksys";
      }
      return result;
    }
    function formatBssid(s) {
      s = s.replace(/</g, "").replace(/>/g, "").match(/.{1,2}/g) || [];
      return s.join(":");
    }
    function wifiConnections(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          const result = [];
          if (_linux) {
            const ifaces = ifaceListLinux();
            const networkList = getWifiNetworkListNmi();
            ifaces.forEach((ifaceDetail) => {
              let ifaceSanitized = "";
              const s = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(ifaceDetail.iface, true);
              const ll = util.mathMin(s.length, 2e3);
              for (let i = 0; i <= ll; i++) {
                if (s[i] !== void 0) {
                  ifaceSanitized = ifaceSanitized + s[i];
                }
              }
              const nmiDetails = nmiDeviceLinux(ifaceSanitized);
              const wpaDetails = wpaConnectionLinux(ifaceSanitized);
              const ssid = nmiDetails.ssid || wpaDetails.ssid;
              const network = networkList.filter((nw) => nw.ssid === ssid);
              let ssidSanitized = "";
              const t = util.isPrototypePolluted() ? "---" : util.sanitizeShellString(ssid, true);
              const l = util.mathMin(t.length, 2e3);
              for (let i = 0; i <= l; i++) {
                if (t[i] !== void 0) {
                  ssidSanitized = ssidSanitized + t[i];
                }
              }
              const nmiConnection = nmiConnectionLinux(ssidSanitized);
              const channel = network && network.length && network[0].channel ? network[0].channel : wpaDetails.channel ? wpaDetails.channel : null;
              const bssid = network && network.length && network[0].bssid ? network[0].bssid : wpaDetails.bssid ? wpaDetails.bssid : null;
              const signalLevel = network && network.length && network[0].signalLevel ? network[0].signalLevel : null;
              if (ssid && bssid) {
                result.push({
                  id: ifaceDetail.id,
                  iface: ifaceDetail.iface,
                  model: nmiDetails.product,
                  ssid,
                  bssid: network && network.length && network[0].bssid ? network[0].bssid : wpaDetails.bssid ? wpaDetails.bssid : null,
                  channel,
                  frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                  type: nmiConnection.type ? nmiConnection.type : "802.11",
                  security: nmiConnection.security ? nmiConnection.security : wpaDetails.security ? wpaDetails.security : null,
                  signalLevel,
                  quality: wifiQualityFromDB(signalLevel),
                  txRate: null
                });
              }
            });
            if (callback) {
              callback(result);
            }
            resolve(result);
          } else if (_darwin) {
            let cmd = "system_profiler SPNetworkDataType";
            exec2(cmd, function(error, stdout) {
              const parts1 = stdout.toString().split("\n\n    Wi-Fi:\n\n");
              if (parts1.length > 1) {
                const lines = parts1[1].split("\n\n")[0].split("\n");
                const iface = util.getValue(lines, "BSD Device Name", ":", true);
                const model = util.getValue(lines, "hardware", ":", true);
                cmd = '/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I 2>/dev/null; echo "######" ; ioreg -n AppleBCMWLANSkywalkInterface -r 2>/dev/null';
                exec2(cmd, function(error2, stdout2) {
                  const parts = stdout2.toString().split("######");
                  const lines2 = parts[0].split("\n");
                  let lines3 = [];
                  if (parts[1].indexOf("  | {") > 0 && parts[1].indexOf("  | }") > parts[1].indexOf("  | {")) {
                    lines3 = parts[1].split("  | {")[1].split("  | }")[0].replace(/ \| /g, "").replace(/"/g, "").split("\n");
                  }
                  if (lines2.length > 10) {
                    const ssid = util.getValue(lines2, "ssid", ":", true);
                    const bssid = util.getValue(lines2, "bssid", ":", true) || formatBssid(util.getValue(lines3, "IO80211BSSID", "=", true));
                    const security = util.getValue(lines2, "link auth", ":", true);
                    const txRate = util.getValue(lines2, "lastTxRate", ":", true);
                    const channel = util.getValue(lines2, "channel", ":", true).split(",")[0];
                    const type = "802.11";
                    const rssi = util.toInt(util.getValue(lines2, "agrCtlRSSI", ":", true));
                    const signalLevel = rssi;
                    if (ssid || bssid) {
                      result.push({
                        id: "Wi-Fi",
                        iface,
                        model,
                        ssid,
                        bssid,
                        channel: util.toInt(channel),
                        frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                        type,
                        security,
                        signalLevel,
                        quality: wifiQualityFromDB(signalLevel),
                        txRate
                      });
                    }
                  }
                  if (lines3.length > 10) {
                    const ssid = util.getValue(lines3, "IO80211SSID", "=", true);
                    const bssid = formatBssid(util.getValue(lines3, "IO80211BSSID", "=", true));
                    const security = "";
                    const txRate = -1;
                    const signalLevel = -1;
                    const quality = -1;
                    const channel = util.getValue(lines3, "IO80211Channel", "=", true);
                    const type = "802.11";
                    if ((ssid || bssid) && !result.length) {
                      result.push({
                        id: "Wi-Fi",
                        iface,
                        model,
                        ssid,
                        bssid,
                        channel: util.toInt(channel),
                        frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                        type,
                        security,
                        signalLevel,
                        quality,
                        txRate
                      });
                    }
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          } else if (_windows) {
            let cmd = "netsh wlan show interfaces";
            util.powerShell(cmd).then(function(stdout) {
              const allLines = stdout.toString().split("\r\n");
              for (let i = 0; i < allLines.length; i++) {
                allLines[i] = allLines[i].trim();
              }
              const parts = allLines.join("\r\n").split(":\r\n\r\n");
              parts.shift();
              parts.forEach((part) => {
                const lines = part.split("\r\n");
                if (lines.length >= 5) {
                  const iface = lines[0].indexOf(":") >= 0 ? lines[0].split(":")[1].trim() : "";
                  const model = lines[1].indexOf(":") >= 0 ? lines[1].split(":")[1].trim() : "";
                  const id = lines[2].indexOf(":") >= 0 ? lines[2].split(":")[1].trim() : "";
                  const ssid = util.getValue(lines, "SSID", ":", true);
                  const bssid = util.getValue(lines, "BSSID", ":", true);
                  const quality = util.getValue(lines, "Signal", ":", true);
                  const signalLevel = wifiDBFromQuality(quality);
                  const type = util.getValue(lines, "Radio type", ":", true) || util.getValue(lines, "Type de radio", ":", true) || util.getValue(lines, "Funktyp", ":", true) || null;
                  const security = util.getValue(lines, "authentication", ":", true) || util.getValue(lines, "Authentification", ":", true) || util.getValue(lines, "Authentifizierung", ":", true) || null;
                  const channel = util.getValue(lines, "Channel", ":", true) || util.getValue(lines, "Canal", ":", true) || util.getValue(lines, "Kanal", ":", true) || null;
                  const txRate = util.getValue(lines, "Transmit rate (mbps)", ":", true) || util.getValue(lines, "Transmission (mbit/s)", ":", true) || util.getValue(lines, "Empfangsrate (MBit/s)", ":", true) || null;
                  if (model && id && ssid && bssid) {
                    result.push({
                      id,
                      iface,
                      model,
                      ssid,
                      bssid,
                      channel: util.toInt(channel),
                      frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                      type,
                      security,
                      signalLevel,
                      quality: quality ? parseInt(quality, 10) : null,
                      txRate: util.toInt(txRate) || null
                    });
                  }
                }
              });
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.wifiConnections = wifiConnections;
    function wifiInterfaces(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          const result = [];
          if (_linux) {
            const ifaces = ifaceListLinux();
            ifaces.forEach((ifaceDetail) => {
              const nmiDetails = nmiDeviceLinux(ifaceDetail.iface);
              result.push({
                id: ifaceDetail.id,
                iface: ifaceDetail.iface,
                model: nmiDetails.product ? nmiDetails.product : null,
                vendor: nmiDetails.vendor ? nmiDetails.vendor : null,
                mac: ifaceDetail.mac
              });
            });
            if (callback) {
              callback(result);
            }
            resolve(result);
          } else if (_darwin) {
            let cmd = "system_profiler SPNetworkDataType";
            exec2(cmd, function(error, stdout) {
              const parts1 = stdout.toString().split("\n\n    Wi-Fi:\n\n");
              if (parts1.length > 1) {
                const lines = parts1[1].split("\n\n")[0].split("\n");
                const iface = util.getValue(lines, "BSD Device Name", ":", true);
                const mac = util.getValue(lines, "MAC Address", ":", true);
                const model = util.getValue(lines, "hardware", ":", true);
                result.push({
                  id: "Wi-Fi",
                  iface,
                  model,
                  vendor: "",
                  mac
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } else if (_windows) {
            let cmd = "netsh wlan show interfaces";
            util.powerShell(cmd).then(function(stdout) {
              const allLines = stdout.toString().split("\r\n");
              for (let i = 0; i < allLines.length; i++) {
                allLines[i] = allLines[i].trim();
              }
              const parts = allLines.join("\r\n").split(":\r\n\r\n");
              parts.shift();
              parts.forEach((part) => {
                const lines = part.split("\r\n");
                if (lines.length >= 5) {
                  const iface = lines[0].indexOf(":") >= 0 ? lines[0].split(":")[1].trim() : "";
                  const model = lines[1].indexOf(":") >= 0 ? lines[1].split(":")[1].trim() : "";
                  const id = lines[2].indexOf(":") >= 0 ? lines[2].split(":")[1].trim() : "";
                  const macParts = lines[3].indexOf(":") >= 0 ? lines[3].split(":") : [];
                  macParts.shift();
                  const mac = macParts.join(":").trim();
                  const vendor = getVendor(model);
                  if (iface && model && id && mac) {
                    result.push({
                      id,
                      iface,
                      model,
                      vendor,
                      mac
                    });
                  }
                }
              });
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.wifiInterfaces = wifiInterfaces;
  }
});

// node_modules/systeminformation/lib/processes.js
var require_processes = __commonJS({
  "node_modules/systeminformation/lib/processes.js"(exports) {
    "use strict";
    var os2 = require("os");
    var fs = require("fs");
    var path = require("path");
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _processes_cpu = {
      all: 0,
      all_utime: 0,
      all_stime: 0,
      list: {},
      ms: 0,
      result: {}
    };
    var _services_cpu = {
      all: 0,
      all_utime: 0,
      all_stime: 0,
      list: {},
      ms: 0,
      result: {}
    };
    var _process_cpu = {
      all: 0,
      all_utime: 0,
      all_stime: 0,
      list: {},
      ms: 0,
      result: {}
    };
    var _winStatusValues = {
      "0": "unknown",
      "1": "other",
      "2": "ready",
      "3": "running",
      "4": "blocked",
      "5": "suspended blocked",
      "6": "suspended ready",
      "7": "terminated",
      "8": "stopped",
      "9": "growing"
    };
    function parseTimeUnix(time) {
      let result = time;
      let parts = time.replace(/ +/g, " ").split(" ");
      if (parts.length === 5) {
        result = parts[4] + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(parts[1].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + parts[2]).slice(-2) + " " + parts[3];
      }
      return result;
    }
    function parseElapsedTime(etime) {
      let current = new Date();
      current = new Date(current.getTime() - current.getTimezoneOffset() * 6e4);
      const elapsed = etime.split("-");
      const timeIndex = elapsed.length - 1;
      const days = timeIndex > 0 ? parseInt(elapsed[timeIndex - 1]) : 0;
      const timeStr = elapsed[timeIndex].split(":");
      const hours = timeStr.length === 3 ? parseInt(timeStr[0] || 0) : 0;
      const mins = parseInt(timeStr[timeStr.length === 3 ? 1 : 0] || 0);
      const secs = parseInt(timeStr[timeStr.length === 3 ? 2 : 1] || 0);
      const ms = (((days * 24 + hours) * 60 + mins) * 60 + secs) * 1e3;
      let res = new Date(current.getTime());
      let result = res.toISOString().substring(0, 10) + " " + res.toISOString().substring(11, 19);
      try {
        res = new Date(current.getTime() - ms);
        result = res.toISOString().substring(0, 10) + " " + res.toISOString().substring(11, 19);
      } catch (e) {
        util.noop();
      }
      return result;
    }
    function services(srv, callback) {
      if (util.isFunction(srv) && !callback) {
        callback = srv;
        srv = "";
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (typeof srv !== "string") {
            if (callback) {
              callback([]);
            }
            return resolve([]);
          }
          if (srv) {
            let srvString = "";
            srvString.__proto__.toLowerCase = util.stringToLower;
            srvString.__proto__.replace = util.stringReplace;
            srvString.__proto__.trim = util.stringTrim;
            const s = util.sanitizeShellString(srv);
            const l = util.mathMin(s.length, 2e3);
            for (let i = 0; i <= l; i++) {
              if (s[i] !== void 0) {
                srvString = srvString + s[i];
              }
            }
            srvString = srvString.trim().toLowerCase().replace(/, /g, "|").replace(/,+/g, "|");
            if (srvString === "") {
              srvString = "*";
            }
            if (util.isPrototypePolluted() && srvString !== "*") {
              srvString = "------";
            }
            let srvs = srvString.split("|");
            let result = [];
            let dataSrv = [];
            if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
              if ((_linux || _freebsd || _openbsd || _netbsd) && srvString === "*") {
                try {
                  const tmpsrv = execSync("systemctl --all --type=service --no-legend 2> /dev/null", util.execOptsLinux).toString().split("\n");
                  srvs = [];
                  for (const s2 of tmpsrv) {
                    const name = s2.split(".service")[0];
                    if (name && s2.indexOf(" not-found ") === -1) {
                      srvs.push(name.trim());
                    }
                  }
                  srvString = srvs.join("|");
                } catch (d) {
                  try {
                    srvString = "";
                    const tmpsrv = execSync("service --status-all 2> /dev/null", util.execOptsLinux).toString().split("\n");
                    for (const s2 of tmpsrv) {
                      const parts = s2.split("]");
                      if (parts.length === 2) {
                        srvString += (srvString !== "" ? "|" : "") + parts[1].trim();
                      }
                    }
                    srvs = srvString.split("|");
                  } catch (e) {
                    try {
                      const srvStr = execSync("ls /etc/init.d/ -m 2> /dev/null", util.execOptsLinux).toString().split("\n").join("");
                      srvString = "";
                      if (srvStr) {
                        const tmpsrv = srvStr.split(",");
                        for (const s2 of tmpsrv) {
                          const name = s2.trim();
                          if (name) {
                            srvString += (srvString !== "" ? "|" : "") + name;
                          }
                        }
                        srvs = srvString.split("|");
                      }
                    } catch (f) {
                      srvString = "";
                      srvs = [];
                    }
                  }
                }
              }
              if (_darwin && srvString === "*") {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
              let args = _darwin ? ["-caxo", "pcpu,pmem,pid,command"] : ["-axo", "pcpu,pmem,pid,command"];
              if (srvString !== "" && srvs.length > 0) {
                util.execSafe("ps", args).then((stdout) => {
                  if (stdout) {
                    let lines = stdout.replace(/ +/g, " ").replace(/,+/g, ".").split("\n");
                    srvs.forEach(function(srv2) {
                      let ps;
                      if (_darwin) {
                        ps = lines.filter(function(e) {
                          return e.toLowerCase().indexOf(srv2) !== -1;
                        });
                      } else {
                        ps = lines.filter(function(e) {
                          return e.toLowerCase().indexOf(" " + srv2.toLowerCase() + ":") !== -1 || e.toLowerCase().indexOf("/" + srv2.toLowerCase()) !== -1;
                        });
                      }
                      const pids = [];
                      for (const p of ps) {
                        const pid = p.trim().split(" ")[2];
                        if (pid) {
                          pids.push(parseInt(pid, 10));
                        }
                      }
                      result.push({
                        name: srv2,
                        running: ps.length > 0,
                        startmode: "",
                        pids,
                        cpu: parseFloat(ps.reduce(function(pv, cv) {
                          return pv + parseFloat(cv.trim().split(" ")[0]);
                        }, 0).toFixed(2)),
                        mem: parseFloat(ps.reduce(function(pv, cv) {
                          return pv + parseFloat(cv.trim().split(" ")[1]);
                        }, 0).toFixed(2))
                      });
                    });
                    if (_linux) {
                      let cmd = 'cat /proc/stat | grep "cpu "';
                      for (let i in result) {
                        for (let j in result[i].pids) {
                          cmd += ";cat /proc/" + result[i].pids[j] + "/stat";
                        }
                      }
                      exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout2) {
                        let curr_processes = stdout2.toString().split("\n");
                        let all = parseProcStat(curr_processes.shift());
                        let list_new = {};
                        let resultProcess = {};
                        curr_processes.forEach((element) => {
                          resultProcess = calcProcStatLinux(element, all, _services_cpu);
                          if (resultProcess.pid) {
                            let listPos = -1;
                            for (let i in result) {
                              for (let j in result[i].pids) {
                                if (parseInt(result[i].pids[j]) === parseInt(resultProcess.pid)) {
                                  listPos = i;
                                }
                              }
                            }
                            if (listPos >= 0) {
                              result[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;
                            }
                            list_new[resultProcess.pid] = {
                              cpuu: resultProcess.cpuu,
                              cpus: resultProcess.cpus,
                              utime: resultProcess.utime,
                              stime: resultProcess.stime,
                              cutime: resultProcess.cutime,
                              cstime: resultProcess.cstime
                            };
                          }
                        });
                        _services_cpu.all = all;
                        _services_cpu.list = Object.assign({}, list_new);
                        _services_cpu.ms = Date.now() - _services_cpu.ms;
                        _services_cpu.result = Object.assign({}, result);
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      });
                    } else {
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    }
                  } else {
                    args = ["-o", "comm"];
                    util.execSafe("ps", args).then((stdout2) => {
                      if (stdout2) {
                        let lines = stdout2.replace(/ +/g, " ").replace(/,+/g, ".").split("\n");
                        srvs.forEach(function(srv2) {
                          let ps = lines.filter(function(e) {
                            return e.indexOf(srv2) !== -1;
                          });
                          result.push({
                            name: srv2,
                            running: ps.length > 0,
                            startmode: "",
                            cpu: 0,
                            mem: 0
                          });
                        });
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      } else {
                        srvs.forEach(function(srv2) {
                          result.push({
                            name: srv2,
                            running: false,
                            startmode: "",
                            cpu: 0,
                            mem: 0
                          });
                        });
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      }
                    });
                  }
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            }
            if (_windows) {
              try {
                let wincommand = "Get-CimInstance Win32_Service";
                if (srvs[0] !== "*") {
                  wincommand += ' -Filter "';
                  srvs.forEach((srv2) => {
                    wincommand += `Name='${srv2}' or `;
                  });
                  wincommand = `${wincommand.slice(0, -4)}"`;
                }
                wincommand += " | select Name,Caption,Started,StartMode,ProcessId | fl";
                util.powerShell(wincommand).then((stdout, error) => {
                  if (!error) {
                    let serviceSections = stdout.split(/\n\s*\n/);
                    serviceSections.forEach((element) => {
                      if (element.trim() !== "") {
                        let lines = element.trim().split("\r\n");
                        let srvName = util.getValue(lines, "Name", ":", true).toLowerCase();
                        let srvCaption = util.getValue(lines, "Caption", ":", true).toLowerCase();
                        let started = util.getValue(lines, "Started", ":", true);
                        let startMode = util.getValue(lines, "StartMode", ":", true);
                        let pid = util.getValue(lines, "ProcessId", ":", true);
                        if (srvString === "*" || srvs.indexOf(srvName) >= 0 || srvs.indexOf(srvCaption) >= 0) {
                          result.push({
                            name: srvName,
                            running: started.toLowerCase() === "true",
                            startmode: startMode,
                            pids: [pid],
                            cpu: 0,
                            mem: 0
                          });
                          dataSrv.push(srvName);
                          dataSrv.push(srvCaption);
                        }
                      }
                    });
                    if (srvString !== "*") {
                      let srvsMissing = srvs.filter(function(e) {
                        return dataSrv.indexOf(e) === -1;
                      });
                      srvsMissing.forEach(function(srvName) {
                        result.push({
                          name: srvName,
                          running: false,
                          startmode: "",
                          pids: [],
                          cpu: 0,
                          mem: 0
                        });
                      });
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  } else {
                    srvs.forEach(function(srvName) {
                      result.push({
                        name: srvName,
                        running: false,
                        startmode: "",
                        cpu: 0,
                        mem: 0
                      });
                    });
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                });
              } catch (e) {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            }
          } else {
            if (callback) {
              callback([]);
            }
            resolve([]);
          }
        });
      });
    }
    exports.services = services;
    function parseProcStat(line) {
      let parts = line.replace(/ +/g, " ").split(" ");
      let user = parts.length >= 2 ? parseInt(parts[1]) : 0;
      let nice = parts.length >= 3 ? parseInt(parts[2]) : 0;
      let system = parts.length >= 4 ? parseInt(parts[3]) : 0;
      let idle = parts.length >= 5 ? parseInt(parts[4]) : 0;
      let iowait = parts.length >= 6 ? parseInt(parts[5]) : 0;
      let irq = parts.length >= 7 ? parseInt(parts[6]) : 0;
      let softirq = parts.length >= 8 ? parseInt(parts[7]) : 0;
      let steal = parts.length >= 9 ? parseInt(parts[8]) : 0;
      let guest = parts.length >= 10 ? parseInt(parts[9]) : 0;
      let guest_nice = parts.length >= 11 ? parseInt(parts[10]) : 0;
      return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;
    }
    function calcProcStatLinux(line, all, _cpu_old) {
      let statparts = line.replace(/ +/g, " ").split(")");
      if (statparts.length >= 2) {
        let parts = statparts[1].split(" ");
        if (parts.length >= 16) {
          let pid = parseInt(statparts[0].split(" ")[0]);
          let utime = parseInt(parts[12]);
          let stime = parseInt(parts[13]);
          let cutime = parseInt(parts[14]);
          let cstime = parseInt(parts[15]);
          let cpuu = 0;
          let cpus = 0;
          if (_cpu_old.all > 0 && _cpu_old.list[pid]) {
            cpuu = (utime + cutime - _cpu_old.list[pid].utime - _cpu_old.list[pid].cutime) / (all - _cpu_old.all) * 100;
            cpus = (stime + cstime - _cpu_old.list[pid].stime - _cpu_old.list[pid].cstime) / (all - _cpu_old.all) * 100;
          } else {
            cpuu = (utime + cutime) / all * 100;
            cpus = (stime + cstime) / all * 100;
          }
          return {
            pid,
            utime,
            stime,
            cutime,
            cstime,
            cpuu,
            cpus
          };
        } else {
          return {
            pid: 0,
            utime: 0,
            stime: 0,
            cutime: 0,
            cstime: 0,
            cpuu: 0,
            cpus: 0
          };
        }
      } else {
        return {
          pid: 0,
          utime: 0,
          stime: 0,
          cutime: 0,
          cstime: 0,
          cpuu: 0,
          cpus: 0
        };
      }
    }
    function calcProcStatWin(procStat, all, _cpu_old) {
      let cpuu = 0;
      let cpus = 0;
      if (_cpu_old.all > 0 && _cpu_old.list[procStat.pid]) {
        cpuu = (procStat.utime - _cpu_old.list[procStat.pid].utime) / (all - _cpu_old.all) * 100;
        cpus = (procStat.stime - _cpu_old.list[procStat.pid].stime) / (all - _cpu_old.all) * 100;
      } else {
        cpuu = procStat.utime / all * 100;
        cpus = procStat.stime / all * 100;
      }
      return {
        pid: procStat.pid,
        utime: procStat.utime,
        stime: procStat.stime,
        cpuu: cpuu > 0 ? cpuu : 0,
        cpus: cpus > 0 ? cpus : 0
      };
    }
    function processes(callback) {
      let parsedhead = [];
      function getName(command) {
        command = command || "";
        let result = command.split(" ")[0];
        if (result.substr(-1) === ":") {
          result = result.substr(0, result.length - 1);
        }
        if (result.substr(0, 1) !== "[") {
          let parts = result.split("/");
          if (isNaN(parseInt(parts[parts.length - 1]))) {
            result = parts[parts.length - 1];
          } else {
            result = parts[0];
          }
        }
        return result;
      }
      function parseLine(line) {
        let offset = 0;
        let offset2 = 0;
        function checkColumn(i) {
          offset = offset2;
          if (parsedhead[i]) {
            offset2 = line.substring(parsedhead[i].to + offset, 1e4).indexOf(" ");
          } else {
            offset2 = 1e4;
          }
        }
        checkColumn(0);
        const pid = parseInt(line.substring(parsedhead[0].from + offset, parsedhead[0].to + offset2));
        checkColumn(1);
        const ppid = parseInt(line.substring(parsedhead[1].from + offset, parsedhead[1].to + offset2));
        checkColumn(2);
        const cpu = parseFloat(line.substring(parsedhead[2].from + offset, parsedhead[2].to + offset2).replace(/,/g, "."));
        checkColumn(3);
        const mem = parseFloat(line.substring(parsedhead[3].from + offset, parsedhead[3].to + offset2).replace(/,/g, "."));
        checkColumn(4);
        const priority = parseInt(line.substring(parsedhead[4].from + offset, parsedhead[4].to + offset2));
        checkColumn(5);
        const vsz = parseInt(line.substring(parsedhead[5].from + offset, parsedhead[5].to + offset2));
        checkColumn(6);
        const rss = parseInt(line.substring(parsedhead[6].from + offset, parsedhead[6].to + offset2));
        checkColumn(7);
        const nice = parseInt(line.substring(parsedhead[7].from + offset, parsedhead[7].to + offset2)) || 0;
        checkColumn(8);
        const started = !_sunos ? parseElapsedTime(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim()) : parseTimeUnix(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim());
        checkColumn(9);
        let state = line.substring(parsedhead[9].from + offset, parsedhead[9].to + offset2).trim();
        state = state[0] === "R" ? "running" : state[0] === "S" ? "sleeping" : state[0] === "T" ? "stopped" : state[0] === "W" ? "paging" : state[0] === "X" ? "dead" : state[0] === "Z" ? "zombie" : state[0] === "D" || state[0] === "U" ? "blocked" : "unknown";
        checkColumn(10);
        let tty = line.substring(parsedhead[10].from + offset, parsedhead[10].to + offset2).trim();
        if (tty === "?" || tty === "??") {
          tty = "";
        }
        checkColumn(11);
        const user = line.substring(parsedhead[11].from + offset, parsedhead[11].to + offset2).trim();
        checkColumn(12);
        let cmdPath = "";
        let command = "";
        let params = "";
        let fullcommand = line.substring(parsedhead[12].from + offset, parsedhead[12].to + offset2).trim();
        if (fullcommand.substr(fullcommand.length - 1) === "]") {
          fullcommand = fullcommand.slice(0, -1);
        }
        if (fullcommand.substr(0, 1) === "[") {
          command = fullcommand.substring(1);
        } else {
          const p1 = fullcommand.indexOf("(");
          const p2 = fullcommand.indexOf(")");
          const p3 = fullcommand.indexOf("/");
          const p4 = fullcommand.indexOf(":");
          if (p1 < p2 && p1 < p3 && p3 < p2) {
            command = fullcommand.split(" ")[0];
            command = command.replace(/:/g, "");
          } else {
            if (p4 > 0 && (p3 === -1 || p3 > 3)) {
              command = fullcommand.split(" ")[0];
              command = command.replace(/:/g, "");
            } else {
              let firstParamPos = fullcommand.indexOf(" -");
              let firstParamPathPos = fullcommand.indexOf(" /");
              firstParamPos = firstParamPos >= 0 ? firstParamPos : 1e4;
              firstParamPathPos = firstParamPathPos >= 0 ? firstParamPathPos : 1e4;
              const firstPos = Math.min(firstParamPos, firstParamPathPos);
              let tmpCommand = fullcommand.substr(0, firstPos);
              const tmpParams = fullcommand.substr(firstPos);
              const lastSlashPos = tmpCommand.lastIndexOf("/");
              if (lastSlashPos >= 0) {
                cmdPath = tmpCommand.substr(0, lastSlashPos);
                tmpCommand = tmpCommand.substr(lastSlashPos + 1);
              }
              if (firstPos === 1e4 && tmpCommand.indexOf(" ") > -1) {
                const parts = tmpCommand.split(" ");
                if (fs.existsSync(path.join(cmdPath, parts[0]))) {
                  command = parts.shift();
                  params = (parts.join(" ") + " " + tmpParams).trim();
                } else {
                  command = tmpCommand.trim();
                  params = tmpParams.trim();
                }
              } else {
                command = tmpCommand.trim();
                params = tmpParams.trim();
              }
            }
          }
        }
        return {
          pid,
          parentPid: ppid,
          name: _linux ? getName(command) : command,
          cpu,
          cpuu: 0,
          cpus: 0,
          mem,
          priority,
          memVsz: vsz,
          memRss: rss,
          nice,
          started,
          state,
          tty,
          user,
          command,
          params,
          path: cmdPath
        };
      }
      function parseProcesses(lines) {
        let result = [];
        if (lines.length > 1) {
          let head = lines[0];
          parsedhead = util.parseHead(head, 8);
          lines.shift();
          lines.forEach(function(line) {
            if (line.trim() !== "") {
              result.push(parseLine(line));
            }
          });
        }
        return result;
      }
      function parseProcesses2(lines) {
        function formatDateTime(time) {
          const month = ("0" + (time.getMonth() + 1).toString()).slice(-2);
          const year = time.getFullYear().toString();
          const day = ("0" + time.getDate().toString()).slice(-2);
          const hours = ("0" + time.getHours().toString()).slice(-2);
          const mins = ("0" + time.getMinutes().toString()).slice(-2);
          const secs = ("0" + time.getSeconds().toString()).slice(-2);
          return year + "-" + month + "-" + day + " " + hours + ":" + mins + ":" + secs;
        }
        function parseElapsed(etime) {
          let started = "";
          if (etime.indexOf("d") >= 0) {
            const elapsed_parts = etime.split("d");
            started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 24 + elapsed_parts[1] * 1) * 60 * 60 * 1e3));
          } else if (etime.indexOf("h") >= 0) {
            const elapsed_parts = etime.split("h");
            started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 60 + elapsed_parts[1] * 1) * 60 * 1e3));
          } else if (etime.indexOf(":") >= 0) {
            const elapsed_parts = etime.split(":");
            started = formatDateTime(new Date(Date.now() - (elapsed_parts.length > 1 ? (elapsed_parts[0] * 60 + elapsed_parts[1]) * 1e3 : elapsed_parts[0] * 1e3)));
          }
          return started;
        }
        let result = [];
        lines.forEach(function(line) {
          if (line.trim() !== "") {
            line = line.trim().replace(/ +/g, " ").replace(/,+/g, ".");
            const parts = line.split(" ");
            const command = parts.slice(9).join(" ");
            const pmem = parseFloat((1 * parseInt(parts[3]) * 1024 / os2.totalmem()).toFixed(1));
            const started = parseElapsed(parts[5]);
            result.push({
              pid: parseInt(parts[0]),
              parentPid: parseInt(parts[1]),
              name: getName(command),
              cpu: 0,
              cpuu: 0,
              cpus: 0,
              mem: pmem,
              priority: 0,
              memVsz: parseInt(parts[2]),
              memRss: parseInt(parts[3]),
              nice: parseInt(parts[4]),
              started,
              state: parts[6] === "R" ? "running" : parts[6] === "S" ? "sleeping" : parts[6] === "T" ? "stopped" : parts[6] === "W" ? "paging" : parts[6] === "X" ? "dead" : parts[6] === "Z" ? "zombie" : parts[6] === "D" || parts[6] === "U" ? "blocked" : "unknown",
              tty: parts[7],
              user: parts[8],
              command
            });
          }
        });
        return result;
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            all: 0,
            running: 0,
            blocked: 0,
            sleeping: 0,
            unknown: 0,
            list: []
          };
          let cmd = "";
          if (_processes_cpu.ms && Date.now() - _processes_cpu.ms >= 500 || _processes_cpu.ms === 0) {
            if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {
              if (_linux) {
                cmd = "export LC_ALL=C; ps -axo pid:11,ppid:11,pcpu:6,pmem:6,pri:5,vsz:11,rss:11,ni:5,etime:30,state:5,tty:15,user:20,command; unset LC_ALL";
              }
              if (_freebsd || _openbsd || _netbsd) {
                cmd = "export LC_ALL=C; ps -axo pid,ppid,pcpu,pmem,pri,vsz,rss,ni,etime,state,tty,user,command; unset LC_ALL";
              }
              if (_darwin) {
                cmd = "ps -axo pid,ppid,pcpu,pmem,pri,vsz=temp_title_1,rss=temp_title_2,nice,etime=temp_title_3,state,tty,user,command -r";
              }
              if (_sunos) {
                cmd = "ps -Ao pid,ppid,pcpu,pmem,pri,vsz,rss,nice,stime,s,tty,user,comm";
              }
              exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout) {
                if (!error && stdout.toString().trim()) {
                  result.list = parseProcesses(stdout.toString().split("\n")).slice();
                  result.all = result.list.length;
                  result.running = result.list.filter(function(e) {
                    return e.state === "running";
                  }).length;
                  result.blocked = result.list.filter(function(e) {
                    return e.state === "blocked";
                  }).length;
                  result.sleeping = result.list.filter(function(e) {
                    return e.state === "sleeping";
                  }).length;
                  if (_linux) {
                    cmd = 'cat /proc/stat | grep "cpu "';
                    result.list.forEach((element) => {
                      cmd += ";cat /proc/" + element.pid + "/stat";
                    });
                    exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                      let curr_processes = stdout2.toString().split("\n");
                      let all = parseProcStat(curr_processes.shift());
                      let list_new = {};
                      let resultProcess = {};
                      curr_processes.forEach((element) => {
                        resultProcess = calcProcStatLinux(element, all, _processes_cpu);
                        if (resultProcess.pid) {
                          let listPos = result.list.map(function(e) {
                            return e.pid;
                          }).indexOf(resultProcess.pid);
                          if (listPos >= 0) {
                            result.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;
                            result.list[listPos].cpuu = resultProcess.cpuu;
                            result.list[listPos].cpus = resultProcess.cpus;
                          }
                          list_new[resultProcess.pid] = {
                            cpuu: resultProcess.cpuu,
                            cpus: resultProcess.cpus,
                            utime: resultProcess.utime,
                            stime: resultProcess.stime,
                            cutime: resultProcess.cutime,
                            cstime: resultProcess.cstime
                          };
                        }
                      });
                      _processes_cpu.all = all;
                      _processes_cpu.list = Object.assign({}, list_new);
                      _processes_cpu.ms = Date.now() - _processes_cpu.ms;
                      _processes_cpu.result = Object.assign({}, result);
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    });
                  } else {
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                } else {
                  cmd = "ps -o pid,ppid,vsz,rss,nice,etime,stat,tty,user,comm";
                  if (_sunos) {
                    cmd = "ps -o pid,ppid,vsz,rss,nice,etime,s,tty,user,comm";
                  }
                  exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error2, stdout2) {
                    if (!error2) {
                      let lines = stdout2.toString().split("\n");
                      lines.shift();
                      result.list = parseProcesses2(lines).slice();
                      result.all = result.list.length;
                      result.running = result.list.filter(function(e) {
                        return e.state === "running";
                      }).length;
                      result.blocked = result.list.filter(function(e) {
                        return e.state === "blocked";
                      }).length;
                      result.sleeping = result.list.filter(function(e) {
                        return e.state === "sleeping";
                      }).length;
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    } else {
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    }
                  });
                }
              });
            } else if (_windows) {
              try {
                util.powerShell('Get-CimInstance Win32_Process | select-Object ProcessId,ParentProcessId,ExecutionState,Caption,CommandLine,ExecutablePath,UserModeTime,KernelModeTime,WorkingSetSize,Priority,PageFileUsage, @{n="CreationDate";e={$_.CreationDate.ToString("yyyy-MM-dd HH:mm:ss")}} | fl').then((stdout, error) => {
                  if (!error) {
                    let processSections = stdout.split(/\n\s*\n/);
                    let procs = [];
                    let procStats = [];
                    let list_new = {};
                    let allcpuu = 0;
                    let allcpus = 0;
                    processSections.forEach((element) => {
                      if (element.trim() !== "") {
                        let lines = element.trim().split("\r\n");
                        let pid = parseInt(util.getValue(lines, "ProcessId", ":", true), 10);
                        let parentPid = parseInt(util.getValue(lines, "ParentProcessId", ":", true), 10);
                        let statusValue = util.getValue(lines, "ExecutionState", ":");
                        let name = util.getValue(lines, "Caption", ":", true);
                        let commandLine = util.getValue(lines, "CommandLine", ":", true);
                        let additionalCommand = false;
                        lines.forEach((line) => {
                          if (additionalCommand && line.toLowerCase().startsWith(" ")) {
                            commandLine += " " + line.trim();
                          } else {
                            additionalCommand = false;
                          }
                          if (line.toLowerCase().startsWith("commandline")) {
                            additionalCommand = true;
                          }
                        });
                        let commandPath = util.getValue(lines, "ExecutablePath", ":", true);
                        let utime = parseInt(util.getValue(lines, "UserModeTime", ":", true), 10);
                        let stime = parseInt(util.getValue(lines, "KernelModeTime", ":", true), 10);
                        let memw = parseInt(util.getValue(lines, "WorkingSetSize", ":", true), 10);
                        allcpuu = allcpuu + utime;
                        allcpus = allcpus + stime;
                        result.all++;
                        if (!statusValue) {
                          result.unknown++;
                        }
                        if (statusValue === "3") {
                          result.running++;
                        }
                        if (statusValue === "4" || statusValue === "5") {
                          result.blocked++;
                        }
                        procStats.push({
                          pid,
                          utime,
                          stime,
                          cpu: 0,
                          cpuu: 0,
                          cpus: 0
                        });
                        procs.push({
                          pid,
                          parentPid,
                          name,
                          cpu: 0,
                          cpuu: 0,
                          cpus: 0,
                          mem: memw / os2.totalmem() * 100,
                          priority: parseInt(util.getValue(lines, "Priority", ":", true), 10),
                          memVsz: parseInt(util.getValue(lines, "PageFileUsage", ":", true), 10),
                          memRss: Math.floor(parseInt(util.getValue(lines, "WorkingSetSize", ":", true), 10) / 1024),
                          nice: 0,
                          started: util.getValue(lines, "CreationDate", ":", true),
                          state: !statusValue ? _winStatusValues[0] : _winStatusValues[statusValue],
                          tty: "",
                          user: "",
                          command: commandLine || name,
                          path: commandPath,
                          params: ""
                        });
                      }
                    });
                    result.sleeping = result.all - result.running - result.blocked - result.unknown;
                    result.list = procs;
                    procStats.forEach((element) => {
                      let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _processes_cpu);
                      let listPos = result.list.map(function(e) {
                        return e.pid;
                      }).indexOf(resultProcess.pid);
                      if (listPos >= 0) {
                        result.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;
                        result.list[listPos].cpuu = resultProcess.cpuu;
                        result.list[listPos].cpus = resultProcess.cpus;
                      }
                      list_new[resultProcess.pid] = {
                        cpuu: resultProcess.cpuu,
                        cpus: resultProcess.cpus,
                        utime: resultProcess.utime,
                        stime: resultProcess.stime
                      };
                    });
                    _processes_cpu.all = allcpuu + allcpus;
                    _processes_cpu.all_utime = allcpuu;
                    _processes_cpu.all_stime = allcpus;
                    _processes_cpu.list = Object.assign({}, list_new);
                    _processes_cpu.ms = Date.now() - _processes_cpu.ms;
                    _processes_cpu.result = Object.assign({}, result);
                  }
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              } catch (e) {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          } else {
            if (callback) {
              callback(_processes_cpu.result);
            }
            resolve(_processes_cpu.result);
          }
        });
      });
    }
    exports.processes = processes;
    function processLoad(proc, callback) {
      if (util.isFunction(proc) && !callback) {
        callback = proc;
        proc = "";
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          proc = proc || "";
          if (typeof proc !== "string") {
            if (callback) {
              callback([]);
            }
            return resolve([]);
          }
          let processesString = "";
          processesString.__proto__.toLowerCase = util.stringToLower;
          processesString.__proto__.replace = util.stringReplace;
          processesString.__proto__.trim = util.stringTrim;
          const s = util.sanitizeShellString(proc);
          const l = util.mathMin(s.length, 2e3);
          for (let i = 0; i <= l; i++) {
            if (s[i] !== void 0) {
              processesString = processesString + s[i];
            }
          }
          processesString = processesString.trim().toLowerCase().replace(/, /g, "|").replace(/,+/g, "|");
          if (processesString === "") {
            processesString = "*";
          }
          if (util.isPrototypePolluted() && processesString !== "*") {
            processesString = "------";
          }
          let processes2 = processesString.split("|");
          let result = [];
          const procSanitized = util.isPrototypePolluted() ? "" : util.sanitizeShellString(proc) || "*";
          if (procSanitized && processes2.length && processes2[0] !== "------") {
            if (_windows) {
              try {
                util.powerShell("Get-CimInstance Win32_Process | select ProcessId,Caption,UserModeTime,KernelModeTime,WorkingSetSize | fl").then((stdout, error) => {
                  if (!error) {
                    let processSections = stdout.split(/\n\s*\n/);
                    let procStats = [];
                    let list_new = {};
                    let allcpuu = 0;
                    let allcpus = 0;
                    processSections.forEach((element) => {
                      if (element.trim() !== "") {
                        let lines = element.trim().split("\r\n");
                        let pid = parseInt(util.getValue(lines, "ProcessId", ":", true), 10);
                        let name = util.getValue(lines, "Caption", ":", true);
                        let utime = parseInt(util.getValue(lines, "UserModeTime", ":", true), 10);
                        let stime = parseInt(util.getValue(lines, "KernelModeTime", ":", true), 10);
                        let mem = parseInt(util.getValue(lines, "WorkingSetSize", ":", true), 10);
                        allcpuu = allcpuu + utime;
                        allcpus = allcpus + stime;
                        procStats.push({
                          pid,
                          name,
                          utime,
                          stime,
                          cpu: 0,
                          cpuu: 0,
                          cpus: 0,
                          mem
                        });
                        let pname = "";
                        let inList = false;
                        processes2.forEach(function(proc2) {
                          if (name.toLowerCase().indexOf(proc2.toLowerCase()) >= 0 && !inList) {
                            inList = true;
                            pname = proc2;
                          }
                        });
                        if (processesString === "*" || inList) {
                          let processFound = false;
                          result.forEach(function(item) {
                            if (item.proc.toLowerCase() === pname.toLowerCase()) {
                              item.pids.push(pid);
                              item.mem += mem / os2.totalmem() * 100;
                              processFound = true;
                            }
                          });
                          if (!processFound) {
                            result.push({
                              proc: pname,
                              pid,
                              pids: [pid],
                              cpu: 0,
                              mem: mem / os2.totalmem() * 100
                            });
                          }
                        }
                      }
                    });
                    if (processesString !== "*") {
                      let processesMissing = processes2.filter(function(name) {
                        return procStats.filter(function(item) {
                          return item.name.toLowerCase().indexOf(name) >= 0;
                        }).length === 0;
                      });
                      processesMissing.forEach(function(procName) {
                        result.push({
                          proc: procName,
                          pid: null,
                          pids: [],
                          cpu: 0,
                          mem: 0
                        });
                      });
                    }
                    procStats.forEach((element) => {
                      let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _process_cpu);
                      let listPos = -1;
                      for (let j = 0; j < result.length; j++) {
                        if (result[j].pid === resultProcess.pid || result[j].pids.indexOf(resultProcess.pid) >= 0) {
                          listPos = j;
                        }
                      }
                      if (listPos >= 0) {
                        result[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;
                      }
                      list_new[resultProcess.pid] = {
                        cpuu: resultProcess.cpuu,
                        cpus: resultProcess.cpus,
                        utime: resultProcess.utime,
                        stime: resultProcess.stime
                      };
                    });
                    _process_cpu.all = allcpuu + allcpus;
                    _process_cpu.all_utime = allcpuu;
                    _process_cpu.all_stime = allcpus;
                    _process_cpu.list = Object.assign({}, list_new);
                    _process_cpu.ms = Date.now() - _process_cpu.ms;
                    _process_cpu.result = JSON.parse(JSON.stringify(result));
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                });
              } catch (e) {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            }
            if (_darwin || _linux || _freebsd || _openbsd || _netbsd) {
              const params = ["-axo", "pid,ppid,pcpu,pmem,comm"];
              util.execSafe("ps", params).then((stdout) => {
                if (stdout) {
                  let procStats = [];
                  let lines = stdout.toString().split("\n").filter(function(line) {
                    if (processesString === "*") {
                      return true;
                    }
                    if (line.toLowerCase().indexOf("grep") !== -1) {
                      return false;
                    }
                    let found = false;
                    processes2.forEach(function(item) {
                      found = found || line.toLowerCase().indexOf(item.toLowerCase()) >= 0;
                    });
                    return found;
                  });
                  lines.shift();
                  lines.forEach(function(line) {
                    let data = line.trim().replace(/ +/g, " ").split(" ");
                    if (data.length > 4) {
                      const linuxName = data[4].indexOf("/") >= 0 ? data[4].substring(0, data[4].indexOf("/")) : data[4];
                      const name = _linux ? linuxName : data[4].substring(data[4].lastIndexOf("/") + 1);
                      procStats.push({
                        name,
                        pid: parseInt(data[0]) || 0,
                        ppid: parseInt(data[1]) || 0,
                        cpu: parseFloat(data[2].replace(",", ".")),
                        mem: parseFloat(data[3].replace(",", "."))
                      });
                    }
                  });
                  procStats.forEach(function(item) {
                    let listPos = -1;
                    let inList = false;
                    let name = item.name;
                    for (let j = 0; j < result.length; j++) {
                      if (item.name.toLowerCase().indexOf(result[j].proc.toLowerCase()) >= 0) {
                        listPos = j;
                      }
                    }
                    processes2.forEach(function(proc2) {
                      if (item.name.toLowerCase().indexOf(proc2.toLowerCase()) >= 0 && !inList) {
                        inList = true;
                        name = proc2;
                      }
                    });
                    if (processesString === "*" || inList) {
                      if (listPos < 0) {
                        if (name) {
                          result.push({
                            proc: name,
                            pid: item.pid,
                            pids: [item.pid],
                            cpu: item.cpu,
                            mem: item.mem
                          });
                        }
                      } else {
                        if (item.ppid < 10) {
                          result[listPos].pid = item.pid;
                        }
                        result[listPos].pids.push(item.pid);
                        result[listPos].cpu += item.cpu;
                        result[listPos].mem += item.mem;
                      }
                    }
                  });
                  if (processesString !== "*") {
                    let processesMissing = processes2.filter(function(name) {
                      return procStats.filter(function(item) {
                        return item.name.toLowerCase().indexOf(name) >= 0;
                      }).length === 0;
                    });
                    processesMissing.forEach(function(procName) {
                      result.push({
                        proc: procName,
                        pid: null,
                        pids: [],
                        cpu: 0,
                        mem: 0
                      });
                    });
                  }
                  if (_linux) {
                    result.forEach(function(item) {
                      item.cpu = 0;
                    });
                    let cmd = 'cat /proc/stat | grep "cpu "';
                    for (let i in result) {
                      for (let j in result[i].pids) {
                        cmd += ";cat /proc/" + result[i].pids[j] + "/stat";
                      }
                    }
                    exec2(cmd, { maxBuffer: 1024 * 2e4 }, function(error, stdout2) {
                      let curr_processes = stdout2.toString().split("\n");
                      let all = parseProcStat(curr_processes.shift());
                      let list_new = {};
                      let resultProcess = {};
                      curr_processes.forEach((element) => {
                        resultProcess = calcProcStatLinux(element, all, _process_cpu);
                        if (resultProcess.pid) {
                          let resultItemId = -1;
                          for (let i in result) {
                            if (result[i].pids.indexOf(resultProcess.pid) >= 0) {
                              resultItemId = i;
                            }
                          }
                          if (resultItemId >= 0) {
                            result[resultItemId].cpu += resultProcess.cpuu + resultProcess.cpus;
                          }
                          list_new[resultProcess.pid] = {
                            cpuu: resultProcess.cpuu,
                            cpus: resultProcess.cpus,
                            utime: resultProcess.utime,
                            stime: resultProcess.stime,
                            cutime: resultProcess.cutime,
                            cstime: resultProcess.cstime
                          };
                        }
                      });
                      result.forEach(function(item) {
                        item.cpu = Math.round(item.cpu * 100) / 100;
                      });
                      _process_cpu.all = all;
                      _process_cpu.list = Object.assign({}, list_new);
                      _process_cpu.ms = Date.now() - _process_cpu.ms;
                      _process_cpu.result = Object.assign({}, result);
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    });
                  } else {
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  }
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              });
            }
          }
        });
      });
    }
    exports.processLoad = processLoad;
  }
});

// node_modules/systeminformation/lib/users.js
var require_users = __commonJS({
  "node_modules/systeminformation/lib/users.js"(exports) {
    "use strict";
    var exec2 = require("child_process").exec;
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function parseUsersLinux(lines, phase) {
      let result = [];
      let result_who = [];
      let result_w = {};
      let w_first = true;
      let w_header = [];
      let w_pos = [];
      let who_line = {};
      let is_whopart = true;
      lines.forEach(function(line) {
        if (line === "---") {
          is_whopart = false;
        } else {
          let l = line.replace(/ +/g, " ").split(" ");
          if (is_whopart) {
            result_who.push({
              user: l[0],
              tty: l[1],
              date: l[2],
              time: l[3],
              ip: l && l.length > 4 ? l[4].replace(/\(/g, "").replace(/\)/g, "") : ""
            });
          } else {
            if (w_first) {
              w_header = l;
              w_header.forEach(function(item) {
                w_pos.push(line.indexOf(item));
              });
              w_first = false;
            } else {
              result_w.user = line.substring(w_pos[0], w_pos[1] - 1).trim();
              result_w.tty = line.substring(w_pos[1], w_pos[2] - 1).trim();
              result_w.ip = line.substring(w_pos[2], w_pos[3] - 1).replace(/\(/g, "").replace(/\)/g, "").trim();
              result_w.command = line.substring(w_pos[7], 1e3).trim();
              who_line = result_who.filter(function(obj) {
                return obj.user.substring(0, 8).trim() === result_w.user && obj.tty === result_w.tty;
              });
              if (who_line.length === 1) {
                result.push({
                  user: who_line[0].user,
                  tty: who_line[0].tty,
                  date: who_line[0].date,
                  time: who_line[0].time,
                  ip: who_line[0].ip,
                  command: result_w.command
                });
              }
            }
          }
        }
      });
      if (result.length === 0 && phase === 2) {
        return result_who;
      } else {
        return result;
      }
    }
    function parseUsersDarwin(lines) {
      let result = [];
      let result_who = [];
      let result_w = {};
      let who_line = {};
      let is_whopart = true;
      lines.forEach(function(line) {
        if (line === "---") {
          is_whopart = false;
        } else {
          let l = line.replace(/ +/g, " ").split(" ");
          if (is_whopart) {
            result_who.push({
              user: l[0],
              tty: l[1],
              date: "" + new Date().getFullYear() + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(l[2].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + l[3]).slice(-2),
              time: l[4]
            });
          } else {
            result_w.user = l[0];
            result_w.tty = l[1];
            result_w.ip = l[2] !== "-" ? l[2] : "";
            result_w.command = l.slice(5, 1e3).join(" ");
            who_line = result_who.filter(function(obj) {
              return obj.user === result_w.user && (obj.tty.substring(3, 1e3) === result_w.tty || obj.tty === result_w.tty);
            });
            if (who_line.length === 1) {
              result.push({
                user: who_line[0].user,
                tty: who_line[0].tty,
                date: who_line[0].date,
                time: who_line[0].time,
                ip: result_w.ip,
                command: result_w.command
              });
            }
          }
        }
      });
      return result;
    }
    function users(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = [];
          if (_linux) {
            exec2('who --ips; echo "---"; w | tail -n +2', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result = parseUsersLinux(lines, 1);
                if (result.length === 0) {
                  exec2('who; echo "---"; w | tail -n +2', function(error2, stdout2) {
                    if (!error2) {
                      lines = stdout2.toString().split("\n");
                      result = parseUsersLinux(lines, 2);
                    }
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec2('who; echo "---"; w -ih', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result = parseUsersDarwin(lines);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            exec2('who; echo "---"; w -h', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result = parseUsersDarwin(lines);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            exec2('who; echo "---"; w -ih', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result = parseUsersDarwin(lines);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_windows) {
            try {
              let cmd = `Get-CimInstance Win32_LogonSession | select LogonId,@{n="StartTime";e={$_.StartTime.ToString("yyyy-MM-dd HH:mm:ss")}} | fl; echo '#-#-#-#';`;
              cmd += "Get-CimInstance Win32_LoggedOnUser | select antecedent,dependent | fl ; echo '#-#-#-#';";
              cmd += `$process = (Get-CimInstance Win32_Process -Filter "name = 'explorer.exe'"); Invoke-CimMethod -InputObject $process[0] -MethodName GetOwner | select user, domain | fl; get-process -name explorer | select-object sessionid | fl; echo '#-#-#-#';`;
              cmd += "query user";
              util.powerShell(cmd).then((data) => {
                if (data) {
                  data = data.split("#-#-#-#");
                  let sessions = parseWinSessions((data[0] || "").split(/\n\s*\n/));
                  let loggedons = parseWinLoggedOn((data[1] || "").split(/\n\s*\n/));
                  let queryUser = parseWinUsersQuery((data[3] || "").split("\r\n"));
                  let users2 = parseWinUsers((data[2] || "").split(/\n\s*\n/), queryUser);
                  for (let id in loggedons) {
                    if ({}.hasOwnProperty.call(loggedons, id)) {
                      loggedons[id].dateTime = {}.hasOwnProperty.call(sessions, id) ? sessions[id] : "";
                    }
                  }
                  users2.forEach((user) => {
                    let dateTime = "";
                    for (let id in loggedons) {
                      if ({}.hasOwnProperty.call(loggedons, id)) {
                        if (loggedons[id].user === user.user && (!dateTime || dateTime < loggedons[id].dateTime)) {
                          dateTime = loggedons[id].dateTime;
                        }
                      }
                    }
                    result.push({
                      user: user.user,
                      tty: user.tty,
                      date: `${dateTime.substring(0, 10)}`,
                      time: `${dateTime.substring(11, 19)}`,
                      ip: "",
                      command: ""
                    });
                  });
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    function parseWinSessions(sessionParts) {
      const sessions = {};
      sessionParts.forEach((session) => {
        const lines = session.split("\r\n");
        const id = util.getValue(lines, "LogonId");
        const starttime = util.getValue(lines, "starttime");
        if (id) {
          sessions[id] = starttime;
        }
      });
      return sessions;
    }
    function fuzzyMatch(name1, name2) {
      name1 = name1.toLowerCase();
      name2 = name2.toLowerCase();
      let eq = 0;
      let len = name1.length;
      if (name2.length > len) {
        len = name2.length;
      }
      for (let i = 0; i < len; i++) {
        const c1 = name1[i] || "";
        const c2 = name2[i] || "";
        if (c1 === c2) {
          eq++;
        }
      }
      return len > 10 ? eq / len > 0.9 : len > 0 ? eq / len > 0.8 : false;
    }
    function parseWinUsers(userParts, userQuery) {
      const users2 = [];
      userParts.forEach((user) => {
        const lines = user.split("\r\n");
        const domain = util.getValue(lines, "domain", ":", true);
        const username = util.getValue(lines, "user", ":", true);
        const sessionid = util.getValue(lines, "sessionid", ":", true);
        if (username) {
          const quser = userQuery.filter((item) => fuzzyMatch(item.user, username));
          users2.push({
            domain,
            user: username,
            tty: quser && quser[0] && quser[0].tty ? quser[0].tty : sessionid
          });
        }
      });
      return users2;
    }
    function parseWinLoggedOn(loggedonParts) {
      const loggedons = {};
      loggedonParts.forEach((loggedon) => {
        const lines = loggedon.split("\r\n");
        const antecendent = util.getValue(lines, "antecedent", ":", true);
        let parts = antecendent.split("=");
        const name = parts.length > 2 ? parts[1].split(",")[0].replace(/"/g, "").trim() : "";
        const domain = parts.length > 2 ? parts[2].replace(/"/g, "").replace(/\)/g, "").trim() : "";
        const dependent = util.getValue(lines, "dependent", ":", true);
        parts = dependent.split("=");
        const id = parts.length > 1 ? parts[1].replace(/"/g, "").replace(/\)/g, "").trim() : "";
        if (id) {
          loggedons[id] = {
            domain,
            user: name
          };
        }
      });
      return loggedons;
    }
    function parseWinUsersQuery(lines) {
      lines = lines.filter((item) => item);
      let result = [];
      const header = lines[0];
      const headerDelimiter = [];
      if (header) {
        const start = header[0] === " " ? 1 : 0;
        headerDelimiter.push(start - 1);
        let nextSpace = 0;
        for (let i = start + 1; i < header.length; i++) {
          if (header[i] === " " && (header[i - 1] === " " || header[i - 1] === ".")) {
            nextSpace = i;
          } else {
            if (nextSpace) {
              headerDelimiter.push(nextSpace);
              nextSpace = 0;
            }
          }
        }
        for (let i = 1; i < lines.length; i++) {
          if (lines[i].trim()) {
            const user = lines[i].substring(headerDelimiter[0] + 1, headerDelimiter[1]).trim() || "";
            const tty = lines[i].substring(headerDelimiter[1] + 1, headerDelimiter[2] - 2).trim() || "";
            result.push({
              user,
              tty
            });
          }
        }
      }
      return result;
    }
    exports.users = users;
  }
});

// node_modules/systeminformation/lib/internet.js
var require_internet = __commonJS({
  "node_modules/systeminformation/lib/internet.js"(exports) {
    "use strict";
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function inetChecksite(url, callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = {
            url,
            ok: false,
            status: 404,
            ms: null
          };
          if (typeof url !== "string") {
            if (callback) {
              callback(result);
            }
            return resolve(result);
          }
          let urlSanitized = "";
          const s = util.sanitizeShellString(url, true);
          const l = util.mathMin(s.length, 2e3);
          for (let i = 0; i <= l; i++) {
            if (s[i] !== void 0) {
              s[i].__proto__.toLowerCase = util.stringToLower;
              const sl = s[i].toLowerCase();
              if (sl && sl[0] && !sl[1] && sl[0].length === 1) {
                urlSanitized = urlSanitized + sl[0];
              }
            }
          }
          result.url = urlSanitized;
          try {
            if (urlSanitized && !util.isPrototypePolluted()) {
              urlSanitized.__proto__.startsWith = util.stringStartWith;
              if (urlSanitized.startsWith("file:") || urlSanitized.startsWith("gopher:") || urlSanitized.startsWith("telnet:") || urlSanitized.startsWith("mailto:") || urlSanitized.startsWith("news:") || urlSanitized.startsWith("nntp:")) {
                if (callback) {
                  callback(result);
                }
                return resolve(result);
              }
              let t = Date.now();
              if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {
                let args = ["-I", "--connect-timeout", "5", "-m", "5"];
                args.push(urlSanitized);
                let cmd = "curl";
                util.execSafe(cmd, args).then((stdout) => {
                  const lines = stdout.split("\n");
                  let statusCode = lines[0] && lines[0].indexOf(" ") >= 0 ? parseInt(lines[0].split(" ")[1], 10) : 404;
                  result.status = statusCode || 404;
                  result.ok = statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304;
                  result.ms = result.ok ? Date.now() - t : null;
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                });
              }
              if (_windows) {
                const http = urlSanitized.startsWith("https:") ? require("https") : require("http");
                try {
                  http.get(urlSanitized, (res) => {
                    const statusCode = res.statusCode;
                    result.status = statusCode || 404;
                    result.ok = statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304;
                    if (statusCode !== 200) {
                      res.resume();
                      result.ms = result.ok ? Date.now() - t : null;
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    } else {
                      res.on("data", () => {
                      });
                      res.on("end", () => {
                        result.ms = result.ok ? Date.now() - t : null;
                        if (callback) {
                          callback(result);
                        }
                        resolve(result);
                      });
                    }
                  }).on("error", () => {
                    if (callback) {
                      callback(result);
                    }
                    resolve(result);
                  });
                } catch (err) {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              }
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          } catch (err) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.inetChecksite = inetChecksite;
    function inetLatency(host, callback) {
      if (util.isFunction(host) && !callback) {
        callback = host;
        host = "";
      }
      host = host || "8.8.8.8";
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (typeof host !== "string") {
            if (callback) {
              callback(null);
            }
            return resolve(null);
          }
          let hostSanitized = "";
          const s = (util.isPrototypePolluted() ? "8.8.8.8" : util.sanitizeShellString(host, true)).trim();
          const l = util.mathMin(s.length, 2e3);
          for (let i = 0; i <= l; i++) {
            if (!(s[i] === void 0)) {
              s[i].__proto__.toLowerCase = util.stringToLower;
              const sl = s[i].toLowerCase();
              if (sl && sl[0] && !sl[1]) {
                hostSanitized = hostSanitized + sl[0];
              }
            }
          }
          hostSanitized.__proto__.startsWith = util.stringStartWith;
          if (hostSanitized.startsWith("file:") || hostSanitized.startsWith("gopher:") || hostSanitized.startsWith("telnet:") || hostSanitized.startsWith("mailto:") || hostSanitized.startsWith("news:") || hostSanitized.startsWith("nntp:")) {
            if (callback) {
              callback(null);
            }
            return resolve(null);
          }
          let params;
          if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
            if (_linux) {
              params = ["-c", "2", "-w", "3", hostSanitized];
            }
            if (_freebsd || _openbsd || _netbsd) {
              params = ["-c", "2", "-t", "3", hostSanitized];
            }
            if (_darwin) {
              params = ["-c2", "-t3", hostSanitized];
            }
            util.execSafe("ping", params).then((stdout) => {
              let result = null;
              if (stdout) {
                const lines = stdout.split("\n").filter((line2) => line2.indexOf("rtt") >= 0 || line2.indexOf("round-trip") >= 0 || line2.indexOf("avg") >= 0).join("\n");
                const line = lines.split("=");
                if (line.length > 1) {
                  const parts = line[1].split("/");
                  if (parts.length > 1) {
                    result = parseFloat(parts[1]);
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            const params2 = ["-s", "-a", hostSanitized, "56", "2"];
            const filt = "avg";
            util.execSafe("ping", params2, { timeout: 3e3 }).then((stdout) => {
              let result = null;
              if (stdout) {
                const lines = stdout.split("\n").filter((line2) => line2.indexOf(filt) >= 0).join("\n");
                const line = lines.split("=");
                if (line.length > 1) {
                  const parts = line[1].split("/");
                  if (parts.length > 1) {
                    result = parseFloat(parts[1].replace(",", "."));
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_windows) {
            let result = null;
            try {
              const params2 = [hostSanitized, "-n", "1"];
              util.execSafe("ping", params2, util.execOptsWin).then((stdout) => {
                if (stdout) {
                  let lines = stdout.split("\r\n");
                  lines.shift();
                  lines.forEach(function(line) {
                    if ((line.toLowerCase().match(/ms/g) || []).length === 3) {
                      let l2 = line.replace(/ +/g, " ").split(" ");
                      if (l2.length > 6) {
                        result = parseFloat(l2[l2.length - 1]);
                      }
                    }
                  });
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              });
            } catch (e) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    exports.inetLatency = inetLatency;
  }
});

// node_modules/systeminformation/lib/dockerSocket.js
var require_dockerSocket = __commonJS({
  "node_modules/systeminformation/lib/dockerSocket.js"(exports, module2) {
    "use strict";
    var net = require("net");
    var isWin = require("os").type() === "Windows_NT";
    var socketPath = isWin ? "//./pipe/docker_engine" : "/var/run/docker.sock";
    var DockerSocket = class {
      getInfo(callback) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/info HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      }
      listImages(all, callback) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/images/json" + (all ? "?all=1" : "") + " HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      }
      inspectImage(id, callback) {
        id = id || "";
        if (id) {
          try {
            let socket = net.createConnection({ path: socketPath });
            let alldata = "";
            let data;
            socket.on("connect", () => {
              socket.write("GET http:/images/" + id + "/json?stream=0 HTTP/1.0\r\n\r\n");
            });
            socket.on("data", (data2) => {
              alldata = alldata + data2.toString();
            });
            socket.on("error", () => {
              socket = false;
              callback({});
            });
            socket.on("end", () => {
              let startbody = alldata.indexOf("\r\n\r\n");
              alldata = alldata.substring(startbody + 4);
              socket = false;
              try {
                data = JSON.parse(alldata);
                callback(data);
              } catch (err) {
                callback({});
              }
            });
          } catch (err) {
            callback({});
          }
        } else {
          callback({});
        }
      }
      listContainers(all, callback) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/containers/json" + (all ? "?all=1" : "") + " HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      }
      getStats(id, callback) {
        id = id || "";
        if (id) {
          try {
            let socket = net.createConnection({ path: socketPath });
            let alldata = "";
            let data;
            socket.on("connect", () => {
              socket.write("GET http:/containers/" + id + "/stats?stream=0 HTTP/1.0\r\n\r\n");
            });
            socket.on("data", (data2) => {
              alldata = alldata + data2.toString();
            });
            socket.on("error", () => {
              socket = false;
              callback({});
            });
            socket.on("end", () => {
              let startbody = alldata.indexOf("\r\n\r\n");
              alldata = alldata.substring(startbody + 4);
              socket = false;
              try {
                data = JSON.parse(alldata);
                callback(data);
              } catch (err) {
                callback({});
              }
            });
          } catch (err) {
            callback({});
          }
        } else {
          callback({});
        }
      }
      getInspect(id, callback) {
        id = id || "";
        if (id) {
          try {
            let socket = net.createConnection({ path: socketPath });
            let alldata = "";
            let data;
            socket.on("connect", () => {
              socket.write("GET http:/containers/" + id + "/json?stream=0 HTTP/1.0\r\n\r\n");
            });
            socket.on("data", (data2) => {
              alldata = alldata + data2.toString();
            });
            socket.on("error", () => {
              socket = false;
              callback({});
            });
            socket.on("end", () => {
              let startbody = alldata.indexOf("\r\n\r\n");
              alldata = alldata.substring(startbody + 4);
              socket = false;
              try {
                data = JSON.parse(alldata);
                callback(data);
              } catch (err) {
                callback({});
              }
            });
          } catch (err) {
            callback({});
          }
        } else {
          callback({});
        }
      }
      getProcesses(id, callback) {
        id = id || "";
        if (id) {
          try {
            let socket = net.createConnection({ path: socketPath });
            let alldata = "";
            let data;
            socket.on("connect", () => {
              socket.write("GET http:/containers/" + id + "/top?ps_args=-opid,ppid,pgid,vsz,time,etime,nice,ruser,user,rgroup,group,stat,rss,args HTTP/1.0\r\n\r\n");
            });
            socket.on("data", (data2) => {
              alldata = alldata + data2.toString();
            });
            socket.on("error", () => {
              socket = false;
              callback({});
            });
            socket.on("end", () => {
              let startbody = alldata.indexOf("\r\n\r\n");
              alldata = alldata.substring(startbody + 4);
              socket = false;
              try {
                data = JSON.parse(alldata);
                callback(data);
              } catch (err) {
                callback({});
              }
            });
          } catch (err) {
            callback({});
          }
        } else {
          callback({});
        }
      }
      listVolumes(callback) {
        try {
          let socket = net.createConnection({ path: socketPath });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/volumes HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      }
    };
    module2.exports = DockerSocket;
  }
});

// node_modules/systeminformation/lib/docker.js
var require_docker = __commonJS({
  "node_modules/systeminformation/lib/docker.js"(exports) {
    "use strict";
    var util = require_util2();
    var DockerSocket = require_dockerSocket();
    var _platform = process.platform;
    var _windows = _platform === "win32";
    var _docker_container_stats = {};
    var _docker_socket;
    var _docker_last_read = 0;
    function dockerInfo(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket();
          }
          const result = {};
          _docker_socket.getInfo((data) => {
            result.id = data.ID;
            result.containers = data.Containers;
            result.containersRunning = data.ContainersRunning;
            result.containersPaused = data.ContainersPaused;
            result.containersStopped = data.ContainersStopped;
            result.images = data.Images;
            result.driver = data.Driver;
            result.memoryLimit = data.MemoryLimit;
            result.swapLimit = data.SwapLimit;
            result.kernelMemory = data.KernelMemory;
            result.cpuCfsPeriod = data.CpuCfsPeriod;
            result.cpuCfsQuota = data.CpuCfsQuota;
            result.cpuShares = data.CPUShares;
            result.cpuSet = data.CPUSet;
            result.ipv4Forwarding = data.IPv4Forwarding;
            result.bridgeNfIptables = data.BridgeNfIptables;
            result.bridgeNfIp6tables = data.BridgeNfIp6tables;
            result.debug = data.Debug;
            result.nfd = data.NFd;
            result.oomKillDisable = data.OomKillDisable;
            result.ngoroutines = data.NGoroutines;
            result.systemTime = data.SystemTime;
            result.loggingDriver = data.LoggingDriver;
            result.cgroupDriver = data.CgroupDriver;
            result.nEventsListener = data.NEventsListener;
            result.kernelVersion = data.KernelVersion;
            result.operatingSystem = data.OperatingSystem;
            result.osType = data.OSType;
            result.architecture = data.Architecture;
            result.ncpu = data.NCPU;
            result.memTotal = data.MemTotal;
            result.dockerRootDir = data.DockerRootDir;
            result.httpProxy = data.HttpProxy;
            result.httpsProxy = data.HttpsProxy;
            result.noProxy = data.NoProxy;
            result.name = data.Name;
            result.labels = data.Labels;
            result.experimentalBuild = data.ExperimentalBuild;
            result.serverVersion = data.ServerVersion;
            result.clusterStore = data.ClusterStore;
            result.clusterAdvertise = data.ClusterAdvertise;
            result.defaultRuntime = data.DefaultRuntime;
            result.liveRestoreEnabled = data.LiveRestoreEnabled;
            result.isolation = data.Isolation;
            result.initBinary = data.InitBinary;
            result.productLicense = data.ProductLicense;
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        });
      });
    }
    exports.dockerInfo = dockerInfo;
    function dockerImages(all, callback) {
      if (util.isFunction(all) && !callback) {
        callback = all;
        all = false;
      }
      if (typeof all === "string" && all === "true") {
        all = true;
      }
      if (typeof all !== "boolean" && all !== void 0) {
        all = false;
      }
      all = all || false;
      let result = [];
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket();
          }
          const workload = [];
          _docker_socket.listImages(all, (data) => {
            let dockerImages2 = {};
            try {
              dockerImages2 = data;
              if (dockerImages2 && Object.prototype.toString.call(dockerImages2) === "[object Array]" && dockerImages2.length > 0) {
                dockerImages2.forEach(function(element) {
                  if (element.Names && Object.prototype.toString.call(element.Names) === "[object Array]" && element.Names.length > 0) {
                    element.Name = element.Names[0].replace(/^\/|\/$/g, "");
                  }
                  workload.push(dockerImagesInspect(element.Id.trim(), element));
                });
                if (workload.length) {
                  Promise.all(
                    workload
                  ).then((data2) => {
                    if (callback) {
                      callback(data2);
                    }
                    resolve(data2);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            } catch (err) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          });
        });
      });
    }
    function dockerImagesInspect(imageID, payload) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          imageID = imageID || "";
          if (typeof imageID !== "string") {
            return resolve();
          }
          const imageIDSanitized = (util.isPrototypePolluted() ? "" : util.sanitizeShellString(imageID, true)).trim();
          if (imageIDSanitized) {
            if (!_docker_socket) {
              _docker_socket = new DockerSocket();
            }
            _docker_socket.inspectImage(imageIDSanitized.trim(), (data) => {
              try {
                resolve({
                  id: payload.Id,
                  container: data.Container,
                  comment: data.Comment,
                  os: data.Os,
                  architecture: data.Architecture,
                  parent: data.Parent,
                  dockerVersion: data.DockerVersion,
                  size: data.Size,
                  sharedSize: payload.SharedSize,
                  virtualSize: data.VirtualSize,
                  author: data.Author,
                  created: data.Created ? Math.round(new Date(data.Created).getTime() / 1e3) : 0,
                  containerConfig: data.ContainerConfig ? data.ContainerConfig : {},
                  graphDriver: data.GraphDriver ? data.GraphDriver : {},
                  repoDigests: data.RepoDigests ? data.RepoDigests : {},
                  repoTags: data.RepoTags ? data.RepoTags : {},
                  config: data.Config ? data.Config : {},
                  rootFS: data.RootFS ? data.RootFS : {}
                });
              } catch (err) {
                resolve();
              }
            });
          } else {
            resolve();
          }
        });
      });
    }
    exports.dockerImages = dockerImages;
    function dockerContainers(all, callback) {
      function inContainers(containers, id) {
        let filtered = containers.filter((obj) => {
          return obj.Id && obj.Id === id;
        });
        return filtered.length > 0;
      }
      if (util.isFunction(all) && !callback) {
        callback = all;
        all = false;
      }
      if (typeof all === "string" && all === "true") {
        all = true;
      }
      if (typeof all !== "boolean" && all !== void 0) {
        all = false;
      }
      all = all || false;
      let result = [];
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket();
          }
          const workload = [];
          _docker_socket.listContainers(all, (data) => {
            let docker_containers = {};
            try {
              docker_containers = data;
              if (docker_containers && Object.prototype.toString.call(docker_containers) === "[object Array]" && docker_containers.length > 0) {
                for (let key in _docker_container_stats) {
                  if ({}.hasOwnProperty.call(_docker_container_stats, key)) {
                    if (!inContainers(docker_containers, key)) {
                      delete _docker_container_stats[key];
                    }
                  }
                }
                docker_containers.forEach(function(element) {
                  if (element.Names && Object.prototype.toString.call(element.Names) === "[object Array]" && element.Names.length > 0) {
                    element.Name = element.Names[0].replace(/^\/|\/$/g, "");
                  }
                  workload.push(dockerContainerInspect(element.Id.trim(), element));
                });
                if (workload.length) {
                  Promise.all(
                    workload
                  ).then((data2) => {
                    if (callback) {
                      callback(data2);
                    }
                    resolve(data2);
                  });
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            } catch (err) {
              for (let key in _docker_container_stats) {
                if ({}.hasOwnProperty.call(_docker_container_stats, key)) {
                  if (!inContainers(docker_containers, key)) {
                    delete _docker_container_stats[key];
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          });
        });
      });
    }
    function dockerContainerInspect(containerID, payload) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          containerID = containerID || "";
          if (typeof containerID !== "string") {
            return resolve();
          }
          const containerIdSanitized = (util.isPrototypePolluted() ? "" : util.sanitizeShellString(containerID, true)).trim();
          if (containerIdSanitized) {
            if (!_docker_socket) {
              _docker_socket = new DockerSocket();
            }
            _docker_socket.getInspect(containerIdSanitized.trim(), (data) => {
              try {
                resolve({
                  id: payload.Id,
                  name: payload.Name,
                  image: payload.Image,
                  imageID: payload.ImageID,
                  command: payload.Command,
                  created: payload.Created,
                  started: data.State && data.State.StartedAt ? Math.round(new Date(data.State.StartedAt).getTime() / 1e3) : 0,
                  finished: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith("0001-01-01") ? Math.round(new Date(data.State.FinishedAt).getTime() / 1e3) : 0,
                  createdAt: data.Created ? data.Created : "",
                  startedAt: data.State && data.State.StartedAt ? data.State.StartedAt : "",
                  finishedAt: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith("0001-01-01") ? data.State.FinishedAt : "",
                  state: payload.State,
                  restartCount: data.RestartCount || 0,
                  platform: data.Platform || "",
                  driver: data.Driver || "",
                  ports: payload.Ports,
                  mounts: payload.Mounts
                  // hostconfig: payload.HostConfig,
                  // network: payload.NetworkSettings
                });
              } catch (err) {
                resolve();
              }
            });
          } else {
            resolve();
          }
        });
      });
    }
    exports.dockerContainers = dockerContainers;
    function docker_calcCPUPercent(cpu_stats, precpu_stats) {
      if (!_windows) {
        let cpuPercent = 0;
        let cpuDelta = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;
        let systemDelta = cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage;
        if (systemDelta > 0 && cpuDelta > 0) {
          if (precpu_stats.online_cpus) {
            cpuPercent = cpuDelta / systemDelta * precpu_stats.online_cpus * 100;
          } else {
            cpuPercent = cpuDelta / systemDelta * cpu_stats.cpu_usage.percpu_usage.length * 100;
          }
        }
        return cpuPercent;
      } else {
        let nanoSecNow = util.nanoSeconds();
        let cpuPercent = 0;
        if (_docker_last_read > 0) {
          let possIntervals = nanoSecNow - _docker_last_read;
          let intervalsUsed = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;
          if (possIntervals > 0) {
            cpuPercent = 100 * intervalsUsed / possIntervals;
          }
        }
        _docker_last_read = nanoSecNow;
        return cpuPercent;
      }
    }
    function docker_calcNetworkIO(networks) {
      let rx;
      let wx;
      for (let key in networks) {
        if (!{}.hasOwnProperty.call(networks, key)) {
          continue;
        }
        let obj = networks[key];
        rx = +obj.rx_bytes;
        wx = +obj.tx_bytes;
      }
      return {
        rx,
        wx
      };
    }
    function docker_calcBlockIO(blkio_stats) {
      let result = {
        r: 0,
        w: 0
      };
      if (blkio_stats && blkio_stats.io_service_bytes_recursive && Object.prototype.toString.call(blkio_stats.io_service_bytes_recursive) === "[object Array]" && blkio_stats.io_service_bytes_recursive.length > 0) {
        blkio_stats.io_service_bytes_recursive.forEach(function(element) {
          if (element.op && element.op.toLowerCase() === "read" && element.value) {
            result.r += element.value;
          }
          if (element.op && element.op.toLowerCase() === "write" && element.value) {
            result.w += element.value;
          }
        });
      }
      return result;
    }
    function dockerContainerStats(containerIDs, callback) {
      let containerArray = [];
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (util.isFunction(containerIDs) && !callback) {
            callback = containerIDs;
            containerArray = ["*"];
          } else {
            containerIDs = containerIDs || "*";
            if (typeof containerIDs !== "string") {
              if (callback) {
                callback([]);
              }
              return resolve([]);
            }
            let containerIDsSanitized = "";
            containerIDsSanitized.__proto__.toLowerCase = util.stringToLower;
            containerIDsSanitized.__proto__.replace = util.stringReplace;
            containerIDsSanitized.__proto__.trim = util.stringTrim;
            containerIDsSanitized = containerIDs;
            containerIDsSanitized = containerIDsSanitized.trim();
            if (containerIDsSanitized !== "*") {
              containerIDsSanitized = "";
              const s = (util.isPrototypePolluted() ? "" : util.sanitizeShellString(containerIDs, true)).trim();
              const l = util.mathMin(s.length, 2e3);
              for (let i = 0; i <= l; i++) {
                if (s[i] !== void 0) {
                  s[i].__proto__.toLowerCase = util.stringToLower;
                  const sl = s[i].toLowerCase();
                  if (sl && sl[0] && !sl[1]) {
                    containerIDsSanitized = containerIDsSanitized + sl[0];
                  }
                }
              }
            }
            containerIDsSanitized = containerIDsSanitized.trim().toLowerCase().replace(/,+/g, "|");
            containerArray = containerIDsSanitized.split("|");
          }
          const result = [];
          const workload = [];
          if (containerArray.length && containerArray[0].trim() === "*") {
            containerArray = [];
            dockerContainers().then((allContainers) => {
              for (let container of allContainers) {
                containerArray.push(container.id.substring(0, 12));
              }
              if (containerArray.length) {
                dockerContainerStats(containerArray.join(",")).then((result2) => {
                  if (callback) {
                    callback(result2);
                  }
                  resolve(result2);
                });
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          } else {
            for (let containerID of containerArray) {
              workload.push(dockerContainerStatsSingle(containerID.trim()));
            }
            if (workload.length) {
              Promise.all(
                workload
              ).then((data) => {
                if (callback) {
                  callback(data);
                }
                resolve(data);
              });
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          }
        });
      });
    }
    function dockerContainerStatsSingle(containerID) {
      containerID = containerID || "";
      let result = {
        id: containerID,
        memUsage: 0,
        memLimit: 0,
        memPercent: 0,
        cpuPercent: 0,
        pids: 0,
        netIO: {
          rx: 0,
          wx: 0
        },
        blockIO: {
          r: 0,
          w: 0
        },
        restartCount: 0,
        cpuStats: {},
        precpuStats: {},
        memoryStats: {},
        networks: {}
      };
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (containerID) {
            if (!_docker_socket) {
              _docker_socket = new DockerSocket();
            }
            _docker_socket.getInspect(containerID, (dataInspect) => {
              try {
                _docker_socket.getStats(containerID, (data) => {
                  try {
                    let stats = data;
                    if (!stats.message) {
                      if (data.id) {
                        result.id = data.id;
                      }
                      result.memUsage = stats.memory_stats && stats.memory_stats.usage ? stats.memory_stats.usage : 0;
                      result.memLimit = stats.memory_stats && stats.memory_stats.limit ? stats.memory_stats.limit : 0;
                      result.memPercent = stats.memory_stats && stats.memory_stats.usage && stats.memory_stats.limit ? stats.memory_stats.usage / stats.memory_stats.limit * 100 : 0;
                      result.cpuPercent = stats.cpu_stats && stats.precpu_stats ? docker_calcCPUPercent(stats.cpu_stats, stats.precpu_stats) : 0;
                      result.pids = stats.pids_stats && stats.pids_stats.current ? stats.pids_stats.current : 0;
                      result.restartCount = dataInspect.RestartCount ? dataInspect.RestartCount : 0;
                      if (stats.networks) {
                        result.netIO = docker_calcNetworkIO(stats.networks);
                      }
                      if (stats.blkio_stats) {
                        result.blockIO = docker_calcBlockIO(stats.blkio_stats);
                      }
                      result.cpuStats = stats.cpu_stats ? stats.cpu_stats : {};
                      result.precpuStats = stats.precpu_stats ? stats.precpu_stats : {};
                      result.memoryStats = stats.memory_stats ? stats.memory_stats : {};
                      result.networks = stats.networks ? stats.networks : {};
                    }
                  } catch (err) {
                    util.noop();
                  }
                  resolve(result);
                });
              } catch (err) {
                util.noop();
              }
            });
          } else {
            resolve(result);
          }
        });
      });
    }
    exports.dockerContainerStats = dockerContainerStats;
    function dockerContainerProcesses(containerID, callback) {
      let result = [];
      return new Promise((resolve) => {
        process.nextTick(() => {
          containerID = containerID || "";
          if (typeof containerID !== "string") {
            return resolve(result);
          }
          const containerIdSanitized = (util.isPrototypePolluted() ? "" : util.sanitizeShellString(containerID, true)).trim();
          if (containerIdSanitized) {
            if (!_docker_socket) {
              _docker_socket = new DockerSocket();
            }
            _docker_socket.getProcesses(containerIdSanitized, (data) => {
              try {
                if (data && data.Titles && data.Processes) {
                  let titles = data.Titles.map(function(value) {
                    return value.toUpperCase();
                  });
                  let pos_pid = titles.indexOf("PID");
                  let pos_ppid = titles.indexOf("PPID");
                  let pos_pgid = titles.indexOf("PGID");
                  let pos_vsz = titles.indexOf("VSZ");
                  let pos_time = titles.indexOf("TIME");
                  let pos_elapsed = titles.indexOf("ELAPSED");
                  let pos_ni = titles.indexOf("NI");
                  let pos_ruser = titles.indexOf("RUSER");
                  let pos_user = titles.indexOf("USER");
                  let pos_rgroup = titles.indexOf("RGROUP");
                  let pos_group = titles.indexOf("GROUP");
                  let pos_stat = titles.indexOf("STAT");
                  let pos_rss = titles.indexOf("RSS");
                  let pos_command = titles.indexOf("COMMAND");
                  data.Processes.forEach((process2) => {
                    result.push({
                      pidHost: pos_pid >= 0 ? process2[pos_pid] : "",
                      ppid: pos_ppid >= 0 ? process2[pos_ppid] : "",
                      pgid: pos_pgid >= 0 ? process2[pos_pgid] : "",
                      user: pos_user >= 0 ? process2[pos_user] : "",
                      ruser: pos_ruser >= 0 ? process2[pos_ruser] : "",
                      group: pos_group >= 0 ? process2[pos_group] : "",
                      rgroup: pos_rgroup >= 0 ? process2[pos_rgroup] : "",
                      stat: pos_stat >= 0 ? process2[pos_stat] : "",
                      time: pos_time >= 0 ? process2[pos_time] : "",
                      elapsed: pos_elapsed >= 0 ? process2[pos_elapsed] : "",
                      nice: pos_ni >= 0 ? process2[pos_ni] : "",
                      rss: pos_rss >= 0 ? process2[pos_rss] : "",
                      vsz: pos_vsz >= 0 ? process2[pos_vsz] : "",
                      command: pos_command >= 0 ? process2[pos_command] : ""
                    });
                  });
                }
              } catch (err) {
                util.noop();
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } else {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.dockerContainerProcesses = dockerContainerProcesses;
    function dockerVolumes(callback) {
      let result = [];
      return new Promise((resolve) => {
        process.nextTick(() => {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket();
          }
          _docker_socket.listVolumes((data) => {
            let dockerVolumes2 = {};
            try {
              dockerVolumes2 = data;
              if (dockerVolumes2 && dockerVolumes2.Volumes && Object.prototype.toString.call(dockerVolumes2.Volumes) === "[object Array]" && dockerVolumes2.Volumes.length > 0) {
                dockerVolumes2.Volumes.forEach(function(element) {
                  result.push({
                    name: element.Name,
                    driver: element.Driver,
                    labels: element.Labels,
                    mountpoint: element.Mountpoint,
                    options: element.Options,
                    scope: element.Scope,
                    created: element.CreatedAt ? Math.round(new Date(element.CreatedAt).getTime() / 1e3) : 0
                  });
                });
                if (callback) {
                  callback(result);
                }
                resolve(result);
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            } catch (err) {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          });
        });
      });
    }
    exports.dockerVolumes = dockerVolumes;
    function dockerAll(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          dockerContainers(true).then((result) => {
            if (result && Object.prototype.toString.call(result) === "[object Array]" && result.length > 0) {
              let l = result.length;
              result.forEach(function(element) {
                dockerContainerStats(element.id).then((res) => {
                  element.memUsage = res[0].memUsage;
                  element.memLimit = res[0].memLimit;
                  element.memPercent = res[0].memPercent;
                  element.cpuPercent = res[0].cpuPercent;
                  element.pids = res[0].pids;
                  element.netIO = res[0].netIO;
                  element.blockIO = res[0].blockIO;
                  element.cpuStats = res[0].cpuStats;
                  element.precpuStats = res[0].precpuStats;
                  element.memoryStats = res[0].memoryStats;
                  element.networks = res[0].networks;
                  dockerContainerProcesses(element.id).then((processes) => {
                    element.processes = processes;
                    l -= 1;
                    if (l === 0) {
                      if (callback) {
                        callback(result);
                      }
                      resolve(result);
                    }
                  });
                });
              });
            } else {
              if (callback) {
                callback(result);
              }
              resolve(result);
            }
          });
        });
      });
    }
    exports.dockerAll = dockerAll;
  }
});

// node_modules/systeminformation/lib/virtualbox.js
var require_virtualbox = __commonJS({
  "node_modules/systeminformation/lib/virtualbox.js"(exports) {
    "use strict";
    var os2 = require("os");
    var exec2 = require("child_process").exec;
    var util = require_util2();
    function vboxInfo(callback) {
      let result = [];
      return new Promise((resolve) => {
        process.nextTick(() => {
          try {
            exec2(util.getVboxmanage() + " list vms --long", function(error, stdout) {
              let parts = (os2.EOL + stdout.toString()).split(os2.EOL + "Name:");
              parts.shift();
              parts.forEach((part) => {
                const lines = ("Name:" + part).split(os2.EOL);
                const state = util.getValue(lines, "State");
                const running = state.startsWith("running");
                const runningSinceString = running ? state.replace("running (since ", "").replace(")", "").trim() : "";
                let runningSince = 0;
                try {
                  if (running) {
                    const sinceDateObj = new Date(runningSinceString);
                    const offset = sinceDateObj.getTimezoneOffset();
                    runningSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1e3) + offset * 60;
                  }
                } catch (e) {
                  util.noop();
                }
                const stoppedSinceString = !running ? state.replace("powered off (since", "").replace(")", "").trim() : "";
                let stoppedSince = 0;
                try {
                  if (!running) {
                    const sinceDateObj = new Date(stoppedSinceString);
                    const offset = sinceDateObj.getTimezoneOffset();
                    stoppedSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1e3) + offset * 60;
                  }
                } catch (e) {
                  util.noop();
                }
                result.push({
                  id: util.getValue(lines, "UUID"),
                  name: util.getValue(lines, "Name"),
                  running,
                  started: runningSinceString,
                  runningSince,
                  stopped: stoppedSinceString,
                  stoppedSince,
                  guestOS: util.getValue(lines, "Guest OS"),
                  hardwareUUID: util.getValue(lines, "Hardware UUID"),
                  memory: parseInt(util.getValue(lines, "Memory size", "     "), 10),
                  vram: parseInt(util.getValue(lines, "VRAM size"), 10),
                  cpus: parseInt(util.getValue(lines, "Number of CPUs"), 10),
                  cpuExepCap: util.getValue(lines, "CPU exec cap"),
                  cpuProfile: util.getValue(lines, "CPUProfile"),
                  chipset: util.getValue(lines, "Chipset"),
                  firmware: util.getValue(lines, "Firmware"),
                  pageFusion: util.getValue(lines, "Page Fusion") === "enabled",
                  configFile: util.getValue(lines, "Config file"),
                  snapshotFolder: util.getValue(lines, "Snapshot folder"),
                  logFolder: util.getValue(lines, "Log folder"),
                  hpet: util.getValue(lines, "HPET") === "enabled",
                  pae: util.getValue(lines, "PAE") === "enabled",
                  longMode: util.getValue(lines, "Long Mode") === "enabled",
                  tripleFaultReset: util.getValue(lines, "Triple Fault Reset") === "enabled",
                  apic: util.getValue(lines, "APIC") === "enabled",
                  x2Apic: util.getValue(lines, "X2APIC") === "enabled",
                  acpi: util.getValue(lines, "ACPI") === "enabled",
                  ioApic: util.getValue(lines, "IOAPIC") === "enabled",
                  biosApicMode: util.getValue(lines, "BIOS APIC mode"),
                  bootMenuMode: util.getValue(lines, "Boot menu mode"),
                  bootDevice1: util.getValue(lines, "Boot Device 1"),
                  bootDevice2: util.getValue(lines, "Boot Device 2"),
                  bootDevice3: util.getValue(lines, "Boot Device 3"),
                  bootDevice4: util.getValue(lines, "Boot Device 4"),
                  timeOffset: util.getValue(lines, "Time offset"),
                  rtc: util.getValue(lines, "RTC")
                });
              });
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          } catch (e) {
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
        });
      });
    }
    exports.vboxInfo = vboxInfo;
  }
});

// node_modules/systeminformation/lib/printer.js
var require_printer = __commonJS({
  "node_modules/systeminformation/lib/printer.js"(exports) {
    "use strict";
    var exec2 = require("child_process").exec;
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var winPrinterStatus = {
      1: "Other",
      2: "Unknown",
      3: "Idle",
      4: "Printing",
      5: "Warmup",
      6: "Stopped Printing",
      7: "Offline"
    };
    function parseLinuxCupsHeader(lines) {
      const result = {};
      if (lines && lines.length) {
        if (lines[0].indexOf(" CUPS v") > 0) {
          const parts = lines[0].split(" CUPS v");
          result.cupsVersion = parts[1];
        }
      }
      return result;
    }
    function parseLinuxCupsPrinter(lines) {
      const result = {};
      const printerId = util.getValue(lines, "PrinterId", " ");
      result.id = printerId ? parseInt(printerId, 10) : null;
      result.name = util.getValue(lines, "Info", " ");
      result.model = lines.length > 0 && lines[0] ? lines[0].split(" ")[0] : "";
      result.uri = util.getValue(lines, "DeviceURI", " ");
      result.uuid = util.getValue(lines, "UUID", " ");
      result.status = util.getValue(lines, "State", " ");
      result.local = util.getValue(lines, "Location", " ").toLowerCase().startsWith("local");
      result.default = null;
      result.shared = util.getValue(lines, "Shared", " ").toLowerCase().startsWith("yes");
      return result;
    }
    function parseLinuxLpstatPrinter(lines, id) {
      const result = {};
      result.id = id;
      result.name = util.getValue(lines, "Description", ":", true);
      result.model = lines.length > 0 && lines[0] ? lines[0].split(" ")[0] : "";
      result.uri = null;
      result.uuid = null;
      result.status = lines.length > 0 && lines[0] ? lines[0].indexOf(" idle") > 0 ? "idle" : lines[0].indexOf(" printing") > 0 ? "printing" : "unknown" : null;
      result.local = util.getValue(lines, "Location", ":", true).toLowerCase().startsWith("local");
      result.default = null;
      result.shared = util.getValue(lines, "Shared", " ").toLowerCase().startsWith("yes");
      return result;
    }
    function parseDarwinPrinters(printerObject, id) {
      const result = {};
      const uriParts = printerObject.uri.split("/");
      result.id = id;
      result.name = printerObject._name;
      result.model = uriParts.length ? uriParts[uriParts.length - 1] : "";
      result.uri = printerObject.uri;
      result.uuid = null;
      result.status = printerObject.status;
      result.local = printerObject.printserver === "local";
      result.default = printerObject.default === "yes";
      result.shared = printerObject.shared === "yes";
      return result;
    }
    function parseWindowsPrinters(lines, id) {
      const result = {};
      const status = parseInt(util.getValue(lines, "PrinterStatus", ":"), 10);
      result.id = id;
      result.name = util.getValue(lines, "name", ":");
      result.model = util.getValue(lines, "DriverName", ":");
      result.uri = null;
      result.uuid = null;
      result.status = winPrinterStatus[status] ? winPrinterStatus[status] : null;
      result.local = util.getValue(lines, "Local", ":").toUpperCase() === "TRUE";
      result.default = util.getValue(lines, "Default", ":").toUpperCase() === "TRUE";
      result.shared = util.getValue(lines, "Shared", ":").toUpperCase() === "TRUE";
      return result;
    }
    function printer(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = [];
          if (_linux || _freebsd || _openbsd || _netbsd) {
            let cmd = "cat /etc/cups/printers.conf 2>/dev/null";
            exec2(cmd, function(error, stdout) {
              if (!error) {
                const parts = stdout.toString().split("<Printer ");
                const printerHeader = parseLinuxCupsHeader(parts[0]);
                for (let i = 1; i < parts.length; i++) {
                  const printers = parseLinuxCupsPrinter(parts[i].split("\n"));
                  if (printers.name) {
                    printers.engine = "CUPS";
                    printers.engineVersion = printerHeader.cupsVersion;
                    result.push(printers);
                  }
                }
              }
              if (result.length === 0) {
                if (_linux) {
                  cmd = "export LC_ALL=C; lpstat -lp 2>/dev/null; unset LC_ALL";
                  exec2(cmd, function(error2, stdout2) {
                    const parts = ("\n" + stdout2.toString()).split("\nprinter ");
                    for (let i = 1; i < parts.length; i++) {
                      const printers = parseLinuxLpstatPrinter(parts[i].split("\n"), i);
                      result.push(printers);
                    }
                  });
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                } else {
                  if (callback) {
                    callback(result);
                  }
                  resolve(result);
                }
              } else {
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
            });
          }
          if (_darwin) {
            let cmd = "system_profiler SPPrintersDataType -json";
            exec2(cmd, function(error, stdout) {
              if (!error) {
                try {
                  const outObj = JSON.parse(stdout.toString());
                  if (outObj.SPPrintersDataType && outObj.SPPrintersDataType.length) {
                    for (let i = 0; i < outObj.SPPrintersDataType.length; i++) {
                      const printer2 = parseDarwinPrinters(outObj.SPPrintersDataType[i], i);
                      result.push(printer2);
                    }
                  }
                } catch (e) {
                  util.noop();
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_windows) {
            util.powerShell("Get-CimInstance Win32_Printer | select PrinterStatus,Name,DriverName,Local,Default,Shared | fl").then((stdout, error) => {
              if (!error) {
                const parts = stdout.toString().split(/\n\s*\n/);
                for (let i = 0; i < parts.length; i++) {
                  const printer2 = parseWindowsPrinters(parts[i].split("\n"), i);
                  if (printer2.name || printer2.model) {
                    result.push(printer2);
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            resolve(null);
          }
        });
      });
    }
    exports.printer = printer;
  }
});

// node_modules/systeminformation/lib/usb.js
var require_usb = __commonJS({
  "node_modules/systeminformation/lib/usb.js"(exports) {
    "use strict";
    var exec2 = require("child_process").exec;
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function getLinuxUsbType(type, name) {
      let result = type;
      const str = (name + " " + type).toLowerCase();
      if (str.indexOf("camera") >= 0) {
        result = "Camera";
      } else if (str.indexOf("hub") >= 0) {
        result = "Hub";
      } else if (str.indexOf("keybrd") >= 0) {
        result = "Keyboard";
      } else if (str.indexOf("keyboard") >= 0) {
        result = "Keyboard";
      } else if (str.indexOf("mouse") >= 0) {
        result = "Mouse";
      } else if (str.indexOf("stora") >= 0) {
        result = "Storage";
      } else if (str.indexOf("microp") >= 0) {
        result = "Microphone";
      } else if (str.indexOf("headset") >= 0) {
        result = "Audio";
      } else if (str.indexOf("audio") >= 0) {
        result = "Audio";
      }
      return result;
    }
    function parseLinuxUsb(usb2) {
      const result = {};
      const lines = usb2.split("\n");
      if (lines && lines.length && lines[0].indexOf("Device") >= 0) {
        const parts = lines[0].split(" ");
        result.bus = parseInt(parts[0], 10);
        if (parts[2]) {
          result.deviceId = parseInt(parts[2], 10);
        } else {
          result.deviceId = null;
        }
      } else {
        result.bus = null;
        result.deviceId = null;
      }
      const idVendor = util.getValue(lines, "idVendor", " ", true).trim();
      let vendorParts = idVendor.split(" ");
      vendorParts.shift();
      const vendor = vendorParts.join(" ");
      const idProduct = util.getValue(lines, "idProduct", " ", true).trim();
      let productParts = idProduct.split(" ");
      productParts.shift();
      const product = productParts.join(" ");
      const interfaceClass = util.getValue(lines, "bInterfaceClass", " ", true).trim();
      let interfaceClassParts = interfaceClass.split(" ");
      interfaceClassParts.shift();
      const usbType = interfaceClassParts.join(" ");
      const iManufacturer = util.getValue(lines, "iManufacturer", " ", true).trim();
      let iManufacturerParts = iManufacturer.split(" ");
      iManufacturerParts.shift();
      const manufacturer = iManufacturerParts.join(" ");
      const iSerial = util.getValue(lines, "iSerial", " ", true).trim();
      let iSerialParts = iSerial.split(" ");
      iSerialParts.shift();
      const serial = iSerialParts.join(" ");
      result.id = (idVendor.startsWith("0x") ? idVendor.split(" ")[0].substr(2, 10) : "") + ":" + (idProduct.startsWith("0x") ? idProduct.split(" ")[0].substr(2, 10) : "");
      result.name = product;
      result.type = getLinuxUsbType(usbType, product);
      result.removable = null;
      result.vendor = vendor;
      result.manufacturer = manufacturer;
      result.maxPower = util.getValue(lines, "MaxPower", " ", true);
      result.serialNumber = serial;
      return result;
    }
    function getDarwinUsbType(name) {
      let result = "";
      if (name.indexOf("camera") >= 0) {
        result = "Camera";
      } else if (name.indexOf("touch bar") >= 0) {
        result = "Touch Bar";
      } else if (name.indexOf("controller") >= 0) {
        result = "Controller";
      } else if (name.indexOf("headset") >= 0) {
        result = "Audio";
      } else if (name.indexOf("keyboard") >= 0) {
        result = "Keyboard";
      } else if (name.indexOf("trackpad") >= 0) {
        result = "Trackpad";
      } else if (name.indexOf("sensor") >= 0) {
        result = "Sensor";
      } else if (name.indexOf("bthusb") >= 0) {
        result = "Bluetooth";
      } else if (name.indexOf("bth") >= 0) {
        result = "Bluetooth";
      } else if (name.indexOf("rfcomm") >= 0) {
        result = "Bluetooth";
      } else if (name.indexOf("usbhub") >= 0) {
        result = "Hub";
      } else if (name.indexOf(" hub") >= 0) {
        result = "Hub";
      } else if (name.indexOf("mouse") >= 0) {
        result = "Mouse";
      } else if (name.indexOf("microp") >= 0) {
        result = "Microphone";
      } else if (name.indexOf("removable") >= 0) {
        result = "Storage";
      }
      return result;
    }
    function parseDarwinUsb(usb2, id) {
      const result = {};
      result.id = id;
      usb2 = usb2.replace(/ \|/g, "");
      usb2 = usb2.trim();
      let lines = usb2.split("\n");
      lines.shift();
      try {
        for (let i = 0; i < lines.length; i++) {
          lines[i] = lines[i].trim();
          lines[i] = lines[i].replace(/=/g, ":");
          if (lines[i] !== "{" && lines[i] !== "}" && lines[i + 1] && lines[i + 1].trim() !== "}") {
            lines[i] = lines[i] + ",";
          }
          lines[i] = lines[i].replace(":Yes,", ':"Yes",');
          lines[i] = lines[i].replace(": Yes,", ': "Yes",');
          lines[i] = lines[i].replace(": Yes", ': "Yes"');
          lines[i] = lines[i].replace(":No,", ':"No",');
          lines[i] = lines[i].replace(": No,", ': "No",');
          lines[i] = lines[i].replace(": No", ': "No"');
          lines[i] = lines[i].replace("((", "").replace("))", "");
          const match = /<(\w+)>/.exec(lines[i]);
          if (match) {
            const number = match[0];
            lines[i] = lines[i].replace(number, `"${number}"`);
          }
        }
        const usbObj = JSON.parse(lines.join("\n"));
        const removableDrive = (usbObj["Built-In"] ? usbObj["Built-In"].toLowerCase() !== "yes" : true) && (usbObj["non-removable"] ? usbObj["non-removable"].toLowerCase() === "no" : true);
        result.bus = null;
        result.deviceId = null;
        result.id = usbObj["USB Address"] || null;
        result.name = usbObj["kUSBProductString"] || usbObj["USB Product Name"] || null;
        result.type = getDarwinUsbType((usbObj["kUSBProductString"] || usbObj["USB Product Name"] || "").toLowerCase() + (removableDrive ? " removable" : ""));
        result.removable = usbObj["non-removable"] ? usbObj["non-removable"].toLowerCase() || false : true;
        result.vendor = usbObj["kUSBVendorString"] || usbObj["USB Vendor Name"] || null;
        result.manufacturer = usbObj["kUSBVendorString"] || usbObj["USB Vendor Name"] || null;
        result.maxPower = null;
        result.serialNumber = usbObj["kUSBSerialNumberString"] || null;
        if (result.name) {
          return result;
        } else {
          return null;
        }
      } catch (e) {
        return null;
      }
    }
    function getWindowsUsbTypeCreation(creationclass, name) {
      let result = "";
      if (name.indexOf("storage") >= 0) {
        result = "Storage";
      } else if (name.indexOf("speicher") >= 0) {
        result = "Storage";
      } else if (creationclass.indexOf("usbhub") >= 0) {
        result = "Hub";
      } else if (creationclass.indexOf("storage") >= 0) {
        result = "Storage";
      } else if (creationclass.indexOf("usbcontroller") >= 0) {
        result = "Controller";
      } else if (creationclass.indexOf("keyboard") >= 0) {
        result = "Keyboard";
      } else if (creationclass.indexOf("pointing") >= 0) {
        result = "Mouse";
      } else if (creationclass.indexOf("microp") >= 0) {
        result = "Microphone";
      } else if (creationclass.indexOf("disk") >= 0) {
        result = "Storage";
      }
      return result;
    }
    function parseWindowsUsb(lines, id) {
      const usbType = getWindowsUsbTypeCreation(util.getValue(lines, "CreationClassName", ":").toLowerCase(), util.getValue(lines, "name", ":").toLowerCase());
      if (usbType) {
        const result = {};
        result.bus = null;
        result.deviceId = util.getValue(lines, "deviceid", ":");
        result.id = id;
        result.name = util.getValue(lines, "name", ":");
        result.type = usbType;
        result.removable = null;
        result.vendor = null;
        result.manufacturer = util.getValue(lines, "Manufacturer", ":");
        result.maxPower = null;
        result.serialNumber = null;
        return result;
      } else {
        return null;
      }
    }
    function usb(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = [];
          if (_linux) {
            const cmd = "export LC_ALL=C; lsusb -v 2>/dev/null; unset LC_ALL";
            exec2(cmd, { maxBuffer: 1024 * 1024 * 128 }, function(error, stdout) {
              if (!error) {
                const parts = ("\n\n" + stdout.toString()).split("\n\nBus ");
                for (let i = 1; i < parts.length; i++) {
                  const usb2 = parseLinuxUsb(parts[i]);
                  result.push(usb2);
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            let cmd = "ioreg -p IOUSB -c AppleUSBRootHubDevice -w0 -l";
            exec2(cmd, { maxBuffer: 1024 * 1024 * 128 }, function(error, stdout) {
              if (!error) {
                const parts = stdout.toString().split(" +-o ");
                for (let i = 1; i < parts.length; i++) {
                  const usb2 = parseDarwinUsb(parts[i]);
                  if (usb2) {
                    result.push(usb2);
                  }
                }
                if (callback) {
                  callback(result);
                }
                resolve(result);
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_windows) {
            util.powerShell('Get-CimInstance CIM_LogicalDevice | where { $_.Description -match "USB"} | select Name,CreationClassName,DeviceId,Manufacturer | fl').then((stdout, error) => {
              if (!error) {
                const parts = stdout.toString().split(/\n\s*\n/);
                for (let i = 0; i < parts.length; i++) {
                  const usb2 = parseWindowsUsb(parts[i].split("\n"), i);
                  if (usb2 && result.filter((x) => x.deviceId === usb2.deviceId).length === 0) {
                    result.push(usb2);
                  }
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos || _freebsd || _openbsd || _netbsd) {
            resolve(null);
          }
        });
      });
    }
    exports.usb = usb;
  }
});

// node_modules/systeminformation/lib/audio.js
var require_audio = __commonJS({
  "node_modules/systeminformation/lib/audio.js"(exports) {
    "use strict";
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util = require_util2();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function parseAudioType(str, input, output) {
      str = str.toLowerCase();
      let result = "";
      if (str.indexOf("input") >= 0) {
        result = "Microphone";
      }
      if (str.indexOf("display audio") >= 0) {
        result = "Speaker";
      }
      if (str.indexOf("speak") >= 0) {
        result = "Speaker";
      }
      if (str.indexOf("laut") >= 0) {
        result = "Speaker";
      }
      if (str.indexOf("loud") >= 0) {
        result = "Speaker";
      }
      if (str.indexOf("head") >= 0) {
        result = "Headset";
      }
      if (str.indexOf("mic") >= 0) {
        result = "Microphone";
      }
      if (str.indexOf("mikr") >= 0) {
        result = "Microphone";
      }
      if (str.indexOf("phone") >= 0) {
        result = "Phone";
      }
      if (str.indexOf("controll") >= 0) {
        result = "Controller";
      }
      if (str.indexOf("line o") >= 0) {
        result = "Line Out";
      }
      if (str.indexOf("digital o") >= 0) {
        result = "Digital Out";
      }
      if (str.indexOf("smart sound technology") >= 0) {
        result = "Digital Signal Processor";
      }
      if (str.indexOf("high definition audio") >= 0) {
        result = "Sound Driver";
      }
      if (!result && output) {
        result = "Speaker";
      } else if (!result && input) {
        result = "Microphone";
      }
      return result;
    }
    function getLinuxAudioPci() {
      let cmd = "lspci -v 2>/dev/null";
      let result = [];
      try {
        const parts = execSync(cmd, util.execOptsLinux).toString().split("\n\n");
        parts.forEach((element) => {
          const lines = element.split("\n");
          if (lines && lines.length && lines[0].toLowerCase().indexOf("audio") >= 0) {
            const audio2 = {};
            audio2.slotId = lines[0].split(" ")[0];
            audio2.driver = util.getValue(lines, "Kernel driver in use", ":", true) || util.getValue(lines, "Kernel modules", ":", true);
            result.push(audio2);
          }
        });
        return result;
      } catch (e) {
        return result;
      }
    }
    function parseLinuxAudioPciMM(lines, audioPCI) {
      const result = {};
      const slotId = util.getValue(lines, "Slot");
      const pciMatch = audioPCI.filter(function(item) {
        return item.slotId === slotId;
      });
      result.id = slotId;
      result.name = util.getValue(lines, "SDevice");
      result.manufacturer = util.getValue(lines, "SVendor");
      result.revision = util.getValue(lines, "Rev");
      result.driver = pciMatch && pciMatch.length === 1 && pciMatch[0].driver ? pciMatch[0].driver : "";
      result.default = null;
      result.channel = "PCIe";
      result.type = parseAudioType(result.name, null, null);
      result.in = null;
      result.out = null;
      result.status = "online";
      return result;
    }
    function parseDarwinChannel(str) {
      let result = "";
      if (str.indexOf("builtin") >= 0) {
        result = "Built-In";
      }
      if (str.indexOf("extern") >= 0) {
        result = "Audio-Jack";
      }
      if (str.indexOf("hdmi") >= 0) {
        result = "HDMI";
      }
      if (str.indexOf("displayport") >= 0) {
        result = "Display-Port";
      }
      if (str.indexOf("usb") >= 0) {
        result = "USB";
      }
      if (str.indexOf("pci") >= 0) {
        result = "PCIe";
      }
      return result;
    }
    function parseDarwinAudio(audioObject, id) {
      const result = {};
      const channelStr = ((audioObject.coreaudio_device_transport || "") + " " + (audioObject._name || "")).toLowerCase();
      result.id = id;
      result.name = audioObject._name;
      result.manufacturer = audioObject.coreaudio_device_manufacturer;
      result.revision = null;
      result.driver = null;
      result.default = !!(audioObject.coreaudio_default_audio_input_device || "") || !!(audioObject.coreaudio_default_audio_output_device || "");
      result.channel = parseDarwinChannel(channelStr);
      result.type = parseAudioType(result.name, !!(audioObject.coreaudio_device_input || ""), !!(audioObject.coreaudio_device_output || ""));
      result.in = !!(audioObject.coreaudio_device_input || "");
      result.out = !!(audioObject.coreaudio_device_output || "");
      result.status = "online";
      return result;
    }
    function parseWindowsAudio(lines) {
      const result = {};
      const status = util.getValue(lines, "StatusInfo", ":");
      result.id = util.getValue(lines, "DeviceID", ":");
      result.name = util.getValue(lines, "name", ":");
      result.manufacturer = util.getValue(lines, "manufacturer", ":");
      result.revision = null;
      result.driver = null;
      result.default = null;
      result.channel = null;
      result.type = parseAudioType(result.name, null, null);
      result.in = null;
      result.out = null;
      result.status = status;
      return result;
    }
    function audio(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = [];
          if (_linux || _freebsd || _openbsd || _netbsd) {
            let cmd = "lspci -vmm 2>/dev/null";
            exec2(cmd, function(error, stdout) {
              if (!error) {
                const audioPCI = getLinuxAudioPci();
                const parts = stdout.toString().split("\n\n");
                parts.forEach((element) => {
                  const lines = element.split("\n");
                  if (util.getValue(lines, "class", ":", true).toLowerCase().indexOf("audio") >= 0) {
                    const audio2 = parseLinuxAudioPciMM(lines, audioPCI);
                    result.push(audio2);
                  }
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_darwin) {
            let cmd = "system_profiler SPAudioDataType -json";
            exec2(cmd, function(error, stdout) {
              if (!error) {
                try {
                  const outObj = JSON.parse(stdout.toString());
                  if (outObj.SPAudioDataType && outObj.SPAudioDataType.length && outObj.SPAudioDataType[0] && outObj.SPAudioDataType[0]["_items"] && outObj.SPAudioDataType[0]["_items"].length) {
                    for (let i = 0; i < outObj.SPAudioDataType[0]["_items"].length; i++) {
                      const audio2 = parseDarwinAudio(outObj.SPAudioDataType[0]["_items"][i], i);
                      result.push(audio2);
                    }
                  }
                } catch (e) {
                  util.noop();
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_windows) {
            util.powerShell("Get-CimInstance Win32_SoundDevice | select DeviceID,StatusInfo,Name,Manufacturer | fl").then((stdout, error) => {
              if (!error) {
                const parts = stdout.toString().split(/\n\s*\n/);
                parts.forEach((element) => {
                  const lines = element.split("\n");
                  if (util.getValue(lines, "name", ":")) {
                    result.push(parseWindowsAudio(lines));
                  }
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_sunos) {
            resolve(null);
          }
        });
      });
    }
    exports.audio = audio;
  }
});

// node_modules/systeminformation/lib/bluetooth.js
var require_bluetooth = __commonJS({
  "node_modules/systeminformation/lib/bluetooth.js"(exports) {
    "use strict";
    var exec2 = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var path = require("path");
    var util = require_util2();
    var fs = require("fs");
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function parseBluetoothType(str) {
      let result = "";
      if (str.indexOf("keyboard") >= 0) {
        result = "Keyboard";
      }
      if (str.indexOf("mouse") >= 0) {
        result = "Mouse";
      }
      if (str.indexOf("trackpad") >= 0) {
        result = "Trackpad";
      }
      if (str.indexOf("speaker") >= 0) {
        result = "Speaker";
      }
      if (str.indexOf("headset") >= 0) {
        result = "Headset";
      }
      if (str.indexOf("phone") >= 0) {
        result = "Phone";
      }
      if (str.indexOf("macbook") >= 0) {
        result = "Computer";
      }
      if (str.indexOf("imac") >= 0) {
        result = "Computer";
      }
      if (str.indexOf("ipad") >= 0) {
        result = "Tablet";
      }
      if (str.indexOf("watch") >= 0) {
        result = "Watch";
      }
      if (str.indexOf("headphone") >= 0) {
        result = "Headset";
      }
      return result;
    }
    function parseBluetoothManufacturer(str) {
      let result = str.split(" ")[0];
      str = str.toLowerCase();
      if (str.indexOf("apple") >= 0) {
        result = "Apple";
      }
      if (str.indexOf("ipad") >= 0) {
        result = "Apple";
      }
      if (str.indexOf("imac") >= 0) {
        result = "Apple";
      }
      if (str.indexOf("iphone") >= 0) {
        result = "Apple";
      }
      if (str.indexOf("magic mouse") >= 0) {
        result = "Apple";
      }
      if (str.indexOf("magic track") >= 0) {
        result = "Apple";
      }
      if (str.indexOf("macbook") >= 0) {
        result = "Apple";
      }
      return result;
    }
    function parseLinuxBluetoothInfo(lines, macAddr1, macAddr2) {
      const result = {};
      result.device = null;
      result.name = util.getValue(lines, "name", "=");
      result.manufacturer = null;
      result.macDevice = macAddr1;
      result.macHost = macAddr2;
      result.batteryPercent = null;
      result.type = parseBluetoothType(result.name.toLowerCase());
      result.connected = false;
      return result;
    }
    function parseDarwinBluetoothDevices(bluetoothObject, macAddr2) {
      const result = {};
      const typeStr = ((bluetoothObject.device_minorClassOfDevice_string || bluetoothObject.device_majorClassOfDevice_string || bluetoothObject.device_minorType || "") + (bluetoothObject.device_name || "")).toLowerCase();
      result.device = bluetoothObject.device_services || "";
      result.name = bluetoothObject.device_name || "";
      result.manufacturer = bluetoothObject.device_manufacturer || parseBluetoothManufacturer(bluetoothObject.device_name || "") || "";
      result.macDevice = (bluetoothObject.device_addr || bluetoothObject.device_address || "").toLowerCase().replace(/-/g, ":");
      result.macHost = macAddr2;
      result.batteryPercent = bluetoothObject.device_batteryPercent || null;
      result.type = parseBluetoothType(typeStr);
      result.connected = bluetoothObject.device_isconnected === "attrib_Yes" || false;
      return result;
    }
    function parseWindowsBluetooth(lines) {
      const result = {};
      result.device = null;
      result.name = util.getValue(lines, "name", ":");
      result.manufacturer = util.getValue(lines, "manufacturer", ":");
      result.macDevice = null;
      result.macHost = null;
      result.batteryPercent = null;
      result.type = parseBluetoothType(result.name.toLowerCase());
      result.connected = null;
      return result;
    }
    function bluetoothDevices(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let result = [];
          if (_linux) {
            const btFiles = util.getFilesInPath("/var/lib/bluetooth/");
            btFiles.forEach((element) => {
              const filename = path.basename(element);
              const pathParts = element.split("/");
              const macAddr1 = pathParts.length >= 6 ? pathParts[pathParts.length - 2] : null;
              const macAddr2 = pathParts.length >= 7 ? pathParts[pathParts.length - 3] : null;
              if (filename === "info") {
                const infoFile = fs.readFileSync(element, { encoding: "utf8" }).split("\n");
                result.push(parseLinuxBluetoothInfo(infoFile, macAddr1, macAddr2));
              }
            });
            try {
              const hdicon = execSync("hcitool con", util.execOptsLinux).toString().toLowerCase();
              for (let i = 0; i < result.length; i++) {
                if (result[i].macDevice && result[i].macDevice.length > 10 && hdicon.indexOf(result[i].macDevice.toLowerCase()) >= 0) {
                  result[i].connected = true;
                }
              }
            } catch (e) {
              util.noop();
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          }
          if (_darwin) {
            let cmd = "system_profiler SPBluetoothDataType -json";
            exec2(cmd, function(error, stdout) {
              if (!error) {
                try {
                  const outObj = JSON.parse(stdout.toString());
                  if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_title"] && outObj.SPBluetoothDataType[0]["device_title"].length) {
                    let macAddr2 = null;
                    if (outObj.SPBluetoothDataType[0]["local_device_title"] && outObj.SPBluetoothDataType[0].local_device_title.general_address) {
                      macAddr2 = outObj.SPBluetoothDataType[0].local_device_title.general_address.toLowerCase().replace(/-/g, ":");
                    }
                    outObj.SPBluetoothDataType[0]["device_title"].forEach((element) => {
                      const obj = element;
                      const objKey = Object.keys(obj);
                      if (objKey && objKey.length === 1) {
                        const innerObject = obj[objKey[0]];
                        innerObject.device_name = objKey[0];
                        const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                        result.push(bluetoothDevice);
                      }
                    });
                  }
                  if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_connected"] && outObj.SPBluetoothDataType[0]["device_connected"].length) {
                    const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ":") : null;
                    outObj.SPBluetoothDataType[0]["device_connected"].forEach((element) => {
                      const obj = element;
                      const objKey = Object.keys(obj);
                      if (objKey && objKey.length === 1) {
                        const innerObject = obj[objKey[0]];
                        innerObject.device_name = objKey[0];
                        innerObject.device_isconnected = "attrib_Yes";
                        const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                        result.push(bluetoothDevice);
                      }
                    });
                  }
                  if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_not_connected"] && outObj.SPBluetoothDataType[0]["device_not_connected"].length) {
                    const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ":") : null;
                    outObj.SPBluetoothDataType[0]["device_not_connected"].forEach((element) => {
                      const obj = element;
                      const objKey = Object.keys(obj);
                      if (objKey && objKey.length === 1) {
                        const innerObject = obj[objKey[0]];
                        innerObject.device_name = objKey[0];
                        innerObject.device_isconnected = "attrib_No";
                        const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                        result.push(bluetoothDevice);
                      }
                    });
                  }
                } catch (e) {
                  util.noop();
                }
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_windows) {
            util.powerShell("Get-CimInstance Win32_PNPEntity | select PNPClass, Name, Manufacturer | fl").then((stdout, error) => {
              if (!error) {
                const parts = stdout.toString().split(/\n\s*\n/);
                parts.forEach((part) => {
                  if (util.getValue(part.split("\n"), "PNPClass", ":") === "Bluetooth") {
                    result.push(parseWindowsBluetooth(part.split("\n")));
                  }
                });
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
          if (_freebsd || _netbsd || _openbsd || _sunos) {
            resolve(null);
          }
        });
      });
    }
    exports.bluetoothDevices = bluetoothDevices;
  }
});

// node_modules/systeminformation/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/systeminformation/lib/index.js"(exports) {
    "use strict";
    var lib_version = require_package2().version;
    var util = require_util2();
    var system = require_system();
    var osInfo = require_osinfo();
    var cpu = require_cpu();
    var memory = require_memory();
    var battery = require_battery();
    var graphics = require_graphics();
    var filesystem = require_filesystem();
    var network = require_network();
    var wifi = require_wifi();
    var processes = require_processes();
    var users = require_users();
    var internet = require_internet();
    var docker = require_docker();
    var vbox = require_virtualbox();
    var printer = require_printer();
    var usb = require_usb();
    var audio = require_audio();
    var bluetooth = require_bluetooth();
    var _platform = process.platform;
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    if (_windows) {
      util.getCodepage();
    }
    function version() {
      return lib_version;
    }
    function getStaticData(callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let data = {};
          data.version = version();
          Promise.all([
            system.system(),
            system.bios(),
            system.baseboard(),
            system.chassis(),
            osInfo.osInfo(),
            osInfo.uuid(),
            osInfo.versions(),
            cpu.cpu(),
            cpu.cpuFlags(),
            graphics.graphics(),
            network.networkInterfaces(),
            memory.memLayout(),
            filesystem.diskLayout()
          ]).then((res) => {
            data.system = res[0];
            data.bios = res[1];
            data.baseboard = res[2];
            data.chassis = res[3];
            data.os = res[4];
            data.uuid = res[5];
            data.versions = res[6];
            data.cpu = res[7];
            data.cpu.flags = res[8];
            data.graphics = res[9];
            data.net = res[10];
            data.memLayout = res[11];
            data.diskLayout = res[12];
            if (callback) {
              callback(data);
            }
            resolve(data);
          });
        });
      });
    }
    function getDynamicData(srv, iface, callback) {
      if (util.isFunction(iface)) {
        callback = iface;
        iface = "";
      }
      if (util.isFunction(srv)) {
        callback = srv;
        srv = "";
      }
      return new Promise((resolve) => {
        process.nextTick(() => {
          iface = iface || network.getDefaultNetworkInterface();
          srv = srv || "";
          let functionProcessed = function() {
            let totalFunctions = 15;
            if (_windows) {
              totalFunctions = 13;
            }
            if (_freebsd || _openbsd || _netbsd) {
              totalFunctions = 11;
            }
            if (_sunos) {
              totalFunctions = 6;
            }
            return function() {
              if (--totalFunctions === 0) {
                if (callback) {
                  callback(data);
                }
                resolve(data);
              }
            };
          }();
          let data = {};
          data.time = osInfo.time();
          data.node = process.versions.node;
          data.v8 = process.versions.v8;
          cpu.cpuCurrentSpeed().then((res) => {
            data.cpuCurrentSpeed = res;
            functionProcessed();
          });
          users.users().then((res) => {
            data.users = res;
            functionProcessed();
          });
          processes.processes().then((res) => {
            data.processes = res;
            functionProcessed();
          });
          cpu.currentLoad().then((res) => {
            data.currentLoad = res;
            functionProcessed();
          });
          if (!_sunos) {
            cpu.cpuTemperature().then((res) => {
              data.temp = res;
              functionProcessed();
            });
          }
          if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {
            network.networkStats(iface).then((res) => {
              data.networkStats = res;
              functionProcessed();
            });
          }
          if (!_sunos) {
            network.networkConnections().then((res) => {
              data.networkConnections = res;
              functionProcessed();
            });
          }
          memory.mem().then((res) => {
            data.mem = res;
            functionProcessed();
          });
          if (!_sunos) {
            battery().then((res) => {
              data.battery = res;
              functionProcessed();
            });
          }
          if (!_sunos) {
            processes.services(srv).then((res) => {
              data.services = res;
              functionProcessed();
            });
          }
          if (!_sunos) {
            filesystem.fsSize().then((res) => {
              data.fsSize = res;
              functionProcessed();
            });
          }
          if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {
            filesystem.fsStats().then((res) => {
              data.fsStats = res;
              functionProcessed();
            });
          }
          if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {
            filesystem.disksIO().then((res) => {
              data.disksIO = res;
              functionProcessed();
            });
          }
          if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {
            wifi.wifiNetworks().then((res) => {
              data.wifiNetworks = res;
              functionProcessed();
            });
          }
          internet.inetLatency().then((res) => {
            data.inetLatency = res;
            functionProcessed();
          });
        });
      });
    }
    function getAllData(srv, iface, callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          let data = {};
          if (iface && util.isFunction(iface) && !callback) {
            callback = iface;
            iface = "";
          }
          if (srv && util.isFunction(srv) && !iface && !callback) {
            callback = srv;
            srv = "";
            iface = "";
          }
          getStaticData().then((res) => {
            data = res;
            getDynamicData(srv, iface).then((res2) => {
              for (let key in res2) {
                if ({}.hasOwnProperty.call(res2, key)) {
                  data[key] = res2[key];
                }
              }
              if (callback) {
                callback(data);
              }
              resolve(data);
            });
          });
        });
      });
    }
    function get(valueObject, callback) {
      return new Promise((resolve) => {
        process.nextTick(() => {
          const allPromises = Object.keys(valueObject).filter((func) => ({}).hasOwnProperty.call(exports, func)).map((func) => {
            const params = valueObject[func].substring(valueObject[func].lastIndexOf("(") + 1, valueObject[func].lastIndexOf(")"));
            let funcWithoutParams = func.indexOf(")") >= 0 ? func.split(")")[1].trim() : func;
            funcWithoutParams = func.indexOf("|") >= 0 ? func.split("|")[0].trim() : funcWithoutParams;
            if (params) {
              return exports[funcWithoutParams](params);
            } else {
              return exports[funcWithoutParams]("");
            }
          });
          Promise.all(allPromises).then((data) => {
            const result = {};
            let i = 0;
            for (let key in valueObject) {
              if ({}.hasOwnProperty.call(valueObject, key) && {}.hasOwnProperty.call(exports, key) && data.length > i) {
                if (valueObject[key] === "*" || valueObject[key] === "all") {
                  result[key] = data[i];
                } else {
                  let keys = valueObject[key];
                  let filter = "";
                  let filterParts = [];
                  if (keys.indexOf(")") >= 0) {
                    keys = keys.split(")")[1].trim();
                  }
                  if (keys.indexOf("|") >= 0) {
                    filter = keys.split("|")[1].trim();
                    filterParts = filter.split(":");
                    keys = keys.split("|")[0].trim();
                  }
                  keys = keys.replace(/,/g, " ").replace(/ +/g, " ").split(" ");
                  if (data[i]) {
                    if (Array.isArray(data[i])) {
                      const partialArray = [];
                      data[i].forEach((element) => {
                        let partialRes = {};
                        if (keys.length === 1 && (keys[0] === "*" || keys[0] === "all")) {
                          partialRes = element;
                        } else {
                          keys.forEach((k) => {
                            if ({}.hasOwnProperty.call(element, k)) {
                              partialRes[k] = element[k];
                            }
                          });
                        }
                        if (filter && filterParts.length === 2) {
                          if ({}.hasOwnProperty.call(partialRes, filterParts[0].trim())) {
                            const val = partialRes[filterParts[0].trim()];
                            if (typeof val == "number") {
                              if (val === parseFloat(filterParts[1].trim())) {
                                partialArray.push(partialRes);
                              }
                            } else if (typeof val == "string") {
                              if (val.toLowerCase() === filterParts[1].trim().toLowerCase()) {
                                partialArray.push(partialRes);
                              }
                            }
                          }
                        } else {
                          partialArray.push(partialRes);
                        }
                      });
                      result[key] = partialArray;
                    } else {
                      const partialRes = {};
                      keys.forEach((k) => {
                        if ({}.hasOwnProperty.call(data[i], k)) {
                          partialRes[k] = data[i][k];
                        }
                      });
                      result[key] = partialRes;
                    }
                  } else {
                    result[key] = {};
                  }
                }
                i++;
              }
            }
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
        });
      });
    }
    function observe(valueObject, interval, callback) {
      let _data = null;
      const result = setInterval(() => {
        get(valueObject).then((data) => {
          if (JSON.stringify(_data) !== JSON.stringify(data)) {
            _data = Object.assign({}, data);
            callback(data);
          }
        });
      }, interval);
      return result;
    }
    exports.version = version;
    exports.system = system.system;
    exports.bios = system.bios;
    exports.baseboard = system.baseboard;
    exports.chassis = system.chassis;
    exports.time = osInfo.time;
    exports.osInfo = osInfo.osInfo;
    exports.versions = osInfo.versions;
    exports.shell = osInfo.shell;
    exports.uuid = osInfo.uuid;
    exports.cpu = cpu.cpu;
    exports.cpuFlags = cpu.cpuFlags;
    exports.cpuCache = cpu.cpuCache;
    exports.cpuCurrentSpeed = cpu.cpuCurrentSpeed;
    exports.cpuTemperature = cpu.cpuTemperature;
    exports.currentLoad = cpu.currentLoad;
    exports.fullLoad = cpu.fullLoad;
    exports.mem = memory.mem;
    exports.memLayout = memory.memLayout;
    exports.battery = battery;
    exports.graphics = graphics.graphics;
    exports.fsSize = filesystem.fsSize;
    exports.fsOpenFiles = filesystem.fsOpenFiles;
    exports.blockDevices = filesystem.blockDevices;
    exports.fsStats = filesystem.fsStats;
    exports.disksIO = filesystem.disksIO;
    exports.diskLayout = filesystem.diskLayout;
    exports.networkInterfaceDefault = network.networkInterfaceDefault;
    exports.networkGatewayDefault = network.networkGatewayDefault;
    exports.networkInterfaces = network.networkInterfaces;
    exports.networkStats = network.networkStats;
    exports.networkConnections = network.networkConnections;
    exports.wifiNetworks = wifi.wifiNetworks;
    exports.wifiInterfaces = wifi.wifiInterfaces;
    exports.wifiConnections = wifi.wifiConnections;
    exports.services = processes.services;
    exports.processes = processes.processes;
    exports.processLoad = processes.processLoad;
    exports.users = users.users;
    exports.inetChecksite = internet.inetChecksite;
    exports.inetLatency = internet.inetLatency;
    exports.dockerInfo = docker.dockerInfo;
    exports.dockerImages = docker.dockerImages;
    exports.dockerContainers = docker.dockerContainers;
    exports.dockerContainerStats = docker.dockerContainerStats;
    exports.dockerContainerProcesses = docker.dockerContainerProcesses;
    exports.dockerVolumes = docker.dockerVolumes;
    exports.dockerAll = docker.dockerAll;
    exports.vboxInfo = vbox.vboxInfo;
    exports.printer = printer.printer;
    exports.usb = usb.usb;
    exports.audio = audio.audio;
    exports.bluetoothDevices = bluetooth.bluetoothDevices;
    exports.getStaticData = getStaticData;
    exports.getDynamicData = getDynamicData;
    exports.getAllData = getAllData;
    exports.get = get;
    exports.observe = observe;
    exports.powerShellStart = util.powerShellStart;
    exports.powerShellRelease = util.powerShellRelease;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EditInNeovim
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_neovim2 = __toESM(require_lib());

// src/Neovim.ts
var import_obsidian = require("obsidian");
var import_neovim = __toESM(require_lib());
var child_process = __toESM(require("child_process"));
var os = __toESM(require("os"));

// src/utils.ts
var import_systeminformation = __toESM(require_lib2());
async function isPortInUse(port) {
  const networkConnections = await import_systeminformation.default.networkConnections();
  return networkConnections.find((networkConnection) => {
    return networkConnection.localPort === String(port);
  }) !== void 0;
}

// src/Neovim.ts
var Neovim = class {
  constructor(settings) {
    this.getBuffers = async () => {
      if (!this.instance)
        return Promise.resolve([]);
      return this.instance.buffers;
    };
    this.openFile = async (file) => {
      if (!file)
        return;
      if (!this.settings.supportedFileTypes.includes(file.extension))
        return;
      if (!this.instance) {
        const port = this.settings.listenOn.split(":").at(-1);
        console.log(port);
        if (!port)
          return;
        if (!await isPortInUse(port))
          return;
      }
      ;
      console.log("asdasd");
      child_process.exec(
        `${this.nvimBinary.path} --server ${this.settings.listenOn} --remote '${file.path}'`
      );
    };
    this.close = () => {
      var _a, _b;
      (_a = this.process) == null ? void 0 : _a.kill();
      (_b = this.instance) == null ? void 0 : _b.quit();
    };
    this.settings = settings;
    if (this.settings.pathToBinary)
      this.nvimBinary = { path: this.settings.pathToBinary };
    else
      this.nvimBinary = (0, import_neovim.findNvim)({ orderBy: "desc" }).matches[0];
  }
  async newInstance(adapter, file) {
    var _a, _b, _c, _d;
    if (this.process) {
      new import_obsidian.Notice("Linked Neovim instance already running", 5e3);
      return;
    }
    this.process = child_process.spawn(
      this.settings.terminal,
      ["-e", this.nvimBinary.path, "--listen", this.settings.listenOn],
      { cwd: adapter.getBasePath(), shell: os.userInfo().shell || void 0 }
    );
    (_a = this.process) == null ? void 0 : _a.on("error", (err) => {
      this.process = void 0;
      this.instance = void 0;
    });
    (_b = this.process) == null ? void 0 : _b.on("close", (code) => {
      this.process = void 0;
      this.instance = void 0;
    });
    (_c = this.process) == null ? void 0 : _c.on("disconnect", () => {
      this.process = void 0;
      this.instance = void 0;
    });
    (_d = this.process) == null ? void 0 : _d.on("exit", (code) => {
      this.process = void 0;
      this.instance = void 0;
    });
    this.instance = (0, import_neovim.attach)({ proc: this.process });
  }
};

// src/Settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  terminal: process.env.TERMINAL || "alacritty",
  listenOn: "127.0.0.1:2006",
  openNeovimOnLoad: true,
  supportedFileTypes: ["txt", "md", "css", "js", "ts", "tsx", "jsx", "json"],
  pathToBinary: ""
};
var EditInNeovimSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Terminal").setDesc(
      "Which terminal emulator should I try and use for the neovim instance?"
    ).addText(
      (text) => text.setPlaceholder("E.g. alacritty, kitty, wezterm...").setValue(this.plugin.settings.terminal).onChange(async (value) => {
        this.plugin.settings.terminal = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Neovim server location").setDesc(
      "The Neovim instance will be spawned using --listen and needs a socket or IP:PORT (not sure if sockets work so use at your own risk)"
    ).addText(
      (text) => text.setPlaceholder("127.0.0.1:2006").setValue(this.plugin.settings.listenOn).onChange(async (value) => {
        this.plugin.settings.listenOn = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Path to Neovim binary").setDesc(
      "Manual override for detecting nvim binary. It's recommended you add nvim to your PATH instead. (requires reload)"
    ).addText(
      (text) => text.setPlaceholder("/path/to/nvim-bin/nvim").setValue(this.plugin.settings.pathToBinary).onChange(async (value) => {
        this.plugin.settings.pathToBinary = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Open on startup").setDesc("Open the Neovim instance when Obsidian opens").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.openNeovimOnLoad).onChange(async (value) => {
        this.plugin.settings.openNeovimOnLoad = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Supported file types").setDesc(
      "Which file extensions do you want this extension to try and open?"
    ).addText(
      (text) => text.setPlaceholder(
        "Filetypes should be separated by spaces and not include the '.', E.g. 'txt md css html'"
      ).setValue(this.plugin.settings.supportedFileTypes.join(" ")).onChange(async (value) => {
        this.plugin.settings.supportedFileTypes = value.split(" ");
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/main.ts
var EditInNeovim = class extends import_obsidian3.Plugin {
  async onload() {
    var _a;
    await this.loadSettings();
    this.pluginChecks();
    console.log("Edit in Neovim loaded! :D");
    this.neovim = new Neovim(this.settings);
    const adapter = this.app.vault.adapter;
    if (this.settings.openNeovimOnLoad)
      this.neovim.newInstance(adapter);
    this.registerEvent(
      this.app.workspace.on("file-open", this.neovim.openFile)
    );
    this.registerEvent(
      this.app.workspace.on("quit", (_a = this.neovim) == null ? void 0 : _a.close)
    );
    this.addSettingTab(new EditInNeovimSettingsTab(this.app, this));
    this.addCommand({
      id: "edit-in-neovim-new-instance",
      name: "Open Neovim",
      callback: async () => await this.neovim.newInstance(adapter).then(() => setTimeout(() => this.neovim.openFile(this.app.workspace.getActiveFile()), 1e3))
    });
  }
  onunload() {
    var _a;
    (_a = this.neovim) == null ? void 0 : _a.close();
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  pluginChecks() {
    const found = (0, import_neovim2.findNvim)({ orderBy: "desc" });
    if (found.matches.length === 0) {
      new import_obsidian3.Notice("Edit In Neovim: No Valid nvim binary found T_T \n\n make sure neovim is installed and on your PATH", 5e3);
    }
    if (!(this.app.vault.adapter instanceof import_obsidian3.FileSystemAdapter)) {
      new import_obsidian3.Notice("Edit In Neovim: unknown adapter, unable to access vault files", 5e3);
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
