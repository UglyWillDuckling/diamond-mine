<!-- This HTML file has been created by texi2html 1.30
     from /mit/gnu/src/make-3.72/make.texinfo on 6 November 1994 -->

<TITLE>GNU Make - An Introduction to Makefiles</TITLE>
<P>Go to the <A HREF="make_1.html">previous</A>, <A HREF="make_3.html">next</A> section.<P>
<H1><A NAME="SEC4" HREF="make_toc.html#SEC4">An Introduction to Makefiles</A></H1>
<P>
You need a file called a <DFN>makefile</DFN> to tell <CODE>make</CODE> what to do.
Most often, the makefile tells <CODE>make</CODE> how to compile and link a
program.
<A NAME="IDX7"></A>
<P>
In this chapter, we will discuss a simple makefile that describes how to
compile and link a text editor which consists of eight C source files
and three header files.  The makefile can also tell <CODE>make</CODE> how to
run miscellaneous commands when explicitly asked (for example, to remove
certain files as a clean-up operation).  To see a more complex example
of a makefile, see section <A HREF="make_16.html#SEC116">Complex Makefile Example</A>.
<P>
When <CODE>make</CODE> recompiles the editor, each changed C source file
must be recompiled.  If a header file has changed, each C source file
that includes the header file must be recompiled to be safe.  Each
compilation produces an object file corresponding to the source file.
Finally, if any source file has been recompiled, all the object files,
whether newly made or saved from previous compilations, must be linked
together to produce the new executable editor.
<A NAME="IDX9"></A>
<A NAME="IDX8"></A>
<P>
<A NAME="IDX10"></A>
<A NAME="IDX11"></A>
<A NAME="IDX12"></A>
<H2><A NAME="SEC5" HREF="make_toc.html#SEC5">What a Rule Looks Like</A></H2>
<P>
A simple makefile consists of "rules" with the following shape:
<A NAME="IDX13"></A>
<A NAME="IDX14"></A>
<A NAME="IDX15"></A>
<P>
<PRE>
<VAR>target</VAR> ... : <VAR>dependencies</VAR> ...
        <VAR>command</VAR>
        ...
        ...
</PRE>
<P>
A <DFN>target</DFN> is usually the name of a file that is generated by a
program; examples of targets are executable or object files.  A target
can also be the name of an action to carry out, such as <SAMP>`clean'</SAMP>
(see section <A HREF="make_4.html#SEC31">Phony Targets</A>).
<P>
A <DFN>dependency</DFN> is a file that is used as input to create the
target.  A target often depends on several files.  
<A NAME="IDX16"></A>
<P>
A <DFN>command</DFN> is an action that <CODE>make</CODE> carries out.
A rule may have more than one command, each on its own line.
<STRONG>Please note:</STRONG> you need to put a tab character at the beginning of
every command line!  This is an obscurity that catches the unwary.
<P>
Usually a command is in a rule with dependencies and serves to create a
target file if any of the dependencies change.  However, the rule that
specifies commands for the target need not have dependencies.  For
example, the rule containing the delete command associated with the
target <SAMP>`clean'</SAMP> does not have dependencies.
<P>
A <DFN>rule</DFN>, then, explains how and when to remake certain files
which are the targets of the particular rule.  <CODE>make</CODE> carries out
the commands on the dependencies to create or update the target.  A
rule can also explain how and when to carry out an action.
See section <A HREF="make_4.html#SEC19">Writing Rules</A>.
<P>
A makefile may contain other text besides rules, but a simple makefile
need only contain rules.  Rules may look somewhat more complicated
than shown in this template, but all fit the pattern more or less.
<P>
<A NAME="IDX17"></A>
<A NAME="IDX18"></A>
<H2><A NAME="SEC6" HREF="make_toc.html#SEC6">A Simple Makefile</A></H2>
<P>
Here is a straightforward makefile that describes the way an
executable file called <CODE>edit</CODE> depends on eight object files
which, in turn, depend on eight C source and three header files.
<P>
In this example, all the C files include <TT>`defs.h'</TT>, but only those
defining editing commands include <TT>`command.h'</TT>, and only low
level files that change the editor buffer include <TT>`buffer.h'</TT>.
<P>
<PRE>
edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o

main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o
</PRE>
<P>
We split each long line into two lines using backslash-newline; this is
like using one long line, but is easier to read.
<A NAME="IDX20"></A>
<A NAME="IDX21"></A>
<A NAME="IDX22"></A>
<A NAME="IDX23"></A>
<A NAME="IDX19"></A>
<P>
To use this makefile to create the executable file called <TT>`edit'</TT>,
type:
<P>
<PRE>
make
</PRE>
<P>
To use this makefile to delete the executable file and all the object
files from the directory, type:
<P>
<PRE>
make clean
</PRE>
<P>
In the example makefile, the targets include the executable file
<SAMP>`edit'</SAMP>, and the object files <SAMP>`main.o'</SAMP> and <SAMP>`kbd.o'</SAMP>.  The
dependencies are files such as <SAMP>`main.c'</SAMP> and <SAMP>`defs.h'</SAMP>.
In fact, each <SAMP>`.o'</SAMP> file is both a target and a dependency.
Commands include <SAMP>`cc -c main.c'</SAMP> and <SAMP>`cc -c kbd.c'</SAMP>.
<P>
When a target is a file, it needs to be recompiled or relinked if any
of its dependencies change.  In addition, any dependencies that are
themselves automatically generated should be updated first.  In this
example, <TT>`edit'</TT> depends on each of the eight object files; the
object file <TT>`main.o'</TT> depends on the source file <TT>`main.c'</TT> and
on the header file <TT>`defs.h'</TT>.  
<P>
A shell command follows each line that contains a target and
dependencies.  These shell commands say how to update the target file.
A tab character must come at the beginning of every command line to
distinguish commands lines from other lines in the makefile.  (Bear in
mind that <CODE>make</CODE> does not know anything about how the commands
work.  It is up to you to supply commands that will update the target
file properly.  All <CODE>make</CODE> does is execute the commands in the rule
you have specified when the target file needs to be updated.)
<A NAME="IDX24"></A>
<P>
The target <SAMP>`clean'</SAMP> is not a file, but merely the name of an
action.  Since you 
normally
do not want to carry out the actions in this rule, <SAMP>`clean'</SAMP> is not a dependency of any other rule.
Consequently, <CODE>make</CODE> never does anything with it unless you tell
it specifically.  Note that this rule not only is not a dependency, it
also does not have any dependencies, so the only purpose of the rule
is to run the specified commands.  Targets that do not refer to files
but are just actions are called <DFN>phony targets</DFN>.  See section <A HREF="make_4.html#SEC31">Phony Targets</A>, for information about this kind of target.  See section <A HREF="make_5.html#SEC46">Errors in Commands</A>, to see how to cause <CODE>make</CODE> to ignore errors
from <CODE>rm</CODE> or any other command.
<A NAME="IDX26"></A>
<A NAME="IDX25"></A>
<P>
<A NAME="IDX27"></A>
<A NAME="IDX28"></A>
<H2><A NAME="SEC7" HREF="make_toc.html#SEC7">How <CODE>make</CODE> Processes a Makefile</A></H2>
<P>
By default, <CODE>make</CODE> starts with the first rule (not counting rules
whose target names start with <SAMP>`.'</SAMP>).  This is called the
<DFN>default goal</DFN>.  (<DFN>Goals</DFN> are the targets that <CODE>make</CODE>
strives ultimately to update.  See section <A HREF="make_9.html#SEC80">Arguments to Specify the Goals</A>.)
<A NAME="IDX30"></A>
<A NAME="IDX31"></A>
<A NAME="IDX29"></A>
<P>
In the simple example of the previous section, the default goal is to
update the executable program <TT>`edit'</TT>; therefore, we put that rule
first.
<P>
Thus, when you give the command:
<P>
<PRE>
make
</PRE>
<P>
<CODE>make</CODE> reads the makefile in the current directory and begins by
processing the first rule.  In the example, this rule is for relinking
<TT>`edit'</TT>; but before <CODE>make</CODE> can fully process this rule, it
must process the rules for the files that <TT>`edit'</TT> depends on,
which in this case are the object files.  Each of these files is
processed according to its own rule.  These rules say to update each
<SAMP>`.o'</SAMP> file by compiling its source file.  The recompilation must
be done if the source file, or any of the header files named as
dependencies, is more recent than the object file, or if the object
file does not exist.
<P>
The other rules are processed because their targets appear as
dependencies of the goal.  If some other rule is not depended on by the
goal (or anything it depends on, etc.), that rule is not processed,
unless you tell <CODE>make</CODE> to do so (with a command such as
<CODE>make clean</CODE>).
<P>
Before recompiling an object file, <CODE>make</CODE> considers updating its
dependencies, the source file and header files.  This makefile does not
specify anything to be done for them--the <SAMP>`.c'</SAMP> and <SAMP>`.h'</SAMP> files
are not the targets of any rules--so <CODE>make</CODE> does nothing for these
files.  But <CODE>make</CODE> would update automatically generated C programs,
such as those made by Bison or Yacc, by their own rules at this time.
<P>
After recompiling whichever object files need it, <CODE>make</CODE> decides
whether to relink <TT>`edit'</TT>.  This must be done if the file
<TT>`edit'</TT> does not exist, or if any of the object files are newer than
it.  If an object file was just recompiled, it is now newer than
<TT>`edit'</TT>, so <TT>`edit'</TT> is relinked.
<A NAME="IDX32"></A>
<P>
Thus, if we change the file <TT>`insert.c'</TT> and run <CODE>make</CODE>,
<CODE>make</CODE> will compile that file to update <TT>`insert.o'</TT>, and then
link <TT>`edit'</TT>.  If we change the file <TT>`command.h'</TT> and run
<CODE>make</CODE>, <CODE>make</CODE> will recompile the object files <TT>`kbd.o'</TT>,
<TT>`command.o'</TT> and <TT>`files.o'</TT> and then link the file <TT>`edit'</TT>.
<P>
<A NAME="IDX33"></A>
<A NAME="IDX34"></A>
<H2><A NAME="SEC8" HREF="make_toc.html#SEC8">Variables Make Makefiles Simpler</A></H2>
<P>
In our example, we had to list all the object files twice in the rule for
<TT>`edit'</TT> (repeated here):
<P>
<PRE>
edit : main.o kbd.o command.o display.o \
              insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
</PRE>
<A NAME="IDX35"></A>
<P>
Such duplication is error-prone; if a new object file is added to the
system, we might add it to one list and forget the other.  We can eliminate
the risk and simplify the makefile by using a variable.  <DFN>Variables</DFN>
allow a text string to be defined once and substituted in multiple places
later (see section <A HREF="make_6.html#SEC55">How to Use Variables</A>).
<A NAME="IDX36"></A>
<A NAME="IDX37"></A>
<A NAME="IDX38"></A>
<A NAME="IDX39"></A>
<A NAME="IDX40"></A>
<P>
It is standard practice for every makefile to have a variable named
<CODE>objects</CODE>, <CODE>OBJECTS</CODE>, <CODE>objs</CODE>, <CODE>OBJS</CODE>, <CODE>obj</CODE>,
or <CODE>OBJ</CODE> which is a list of all object file names.  We would
define such a variable <CODE>objects</CODE> with a line like this in the
makefile:<P>
<PRE>
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o
</PRE>
<P>
Then, each place we want to put a list of the object file names, we can
substitute the variable's value by writing <SAMP>`$(objects)'</SAMP>
(see section <A HREF="make_6.html#SEC55">How to Use Variables</A>).  
<P>
Here is how the complete simple makefile looks when you use a variable
for the object files:
<P>
<PRE>
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit $(objects)
</PRE>
<P>
<A NAME="IDX41"></A>
<A NAME="IDX42"></A>
<A NAME="IDX43"></A>
<H2><A NAME="SEC9" HREF="make_toc.html#SEC9">Letting <CODE>make</CODE> Deduce the Commands</A></H2>
<P>
It is not necessary to spell out the commands for compiling the individual
C source files, because <CODE>make</CODE> can figure them out: it has an
<DFN>implicit rule</DFN> for updating a <SAMP>`.o'</SAMP> file from a correspondingly
named <SAMP>`.c'</SAMP> file using a <SAMP>`cc -c'</SAMP> command.  For example, it will
use the command <SAMP>`cc -c main.c -o main.o'</SAMP> to compile <TT>`main.c'</TT> into
<TT>`main.o'</TT>.  We can therefore omit the commands from the rules for the
object files.  See section <A HREF="make_10.html#SEC86">Using Implicit Rules</A>.<P>
When a <SAMP>`.c'</SAMP> file is used automatically in this way, it is also
automatically added to the list of dependencies.  We can therefore omit
the <SAMP>`.c'</SAMP> files from the dependencies, provided we omit the commands.
<P>
Here is the entire example, with both of these changes, and a variable
<CODE>objects</CODE> as suggested above:
<P>
<PRE>
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
        -rm edit $(objects)
</PRE>
<P>
This is how we would write the makefile in actual practice.  (The
complications associated with <SAMP>`clean'</SAMP> are described elsewhere.
See section <A HREF="make_4.html#SEC31">Phony Targets</A>, and section <A HREF="make_5.html#SEC46">Errors in Commands</A>.)
<P>
Because implicit rules are so convenient, they are important.  You
will see them used frequently.<P>
<A NAME="IDX44"></A>
<H2><A NAME="SEC10" HREF="make_toc.html#SEC10">Another Style of Makefile</A></H2>
<P>
When the objects of a makefile are created only by implicit rules, an
alternative style of makefile is possible.  In this style of makefile,
you group entries by their dependencies instead of by their targets.
Here is what one looks like:
<P>
<PRE>
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
</PRE>
<P>
Here <TT>`defs.h'</TT> is given as a dependency of all the object files;
<TT>`command.h'</TT> and <TT>`buffer.h'</TT> are dependencies of the specific
object files listed for them.
<P>
Whether this is better is a matter of taste: it is more compact, but some
people dislike it because they find it clearer to put all the information
about each target in one place.
<P>
<A NAME="IDX45"></A>
<A NAME="IDX46"></A>
<H2><A NAME="SEC11" HREF="make_toc.html#SEC11">Rules for Cleaning the Directory</A></H2>
<P>
Compiling a program is not the only thing you might want to write rules
for.  Makefiles commonly tell how to do a few other things besides
compiling a program: for example, how to delete all the object files
and executables so that the directory is <SAMP>`clean'</SAMP>.
<A NAME="IDX47"></A>
<P>
Here is how we
could write a <CODE>make</CODE> rule for cleaning our example editor:
<P>
<PRE>
clean:
        rm edit $(objects)
</PRE>
<P>
In practice, we might want to write the rule in a somewhat more
complicated manner to handle unanticipated situations.  We would do this:
<P>
<PRE>
.PHONY : clean
clean :
        -rm edit $(objects)
</PRE>
<P>
This prevents <CODE>make</CODE> from getting confused by an actual file
called <TT>`clean'</TT> and causes it to continue in spite of errors from
<CODE>rm</CODE>.  (See section <A HREF="make_4.html#SEC31">Phony Targets</A>, and section <A HREF="make_5.html#SEC46">Errors in Commands</A>.)
<P>
A rule such as this should not be placed at the beginning of the
makefile, because we do not want it to run by default!  Thus, in the
example makefile, we want the rule for <CODE>edit</CODE>, which recompiles
the editor, to remain the default goal.
<P>
Since <CODE>clean</CODE> is not a dependency of <CODE>edit</CODE>, this rule will not
run at all if we give the command <SAMP>`make'</SAMP> with no arguments.  In
order to make the rule run, we have to type <SAMP>`make clean'</SAMP>.
See section <A HREF="make_9.html#SEC78">How to Run <CODE>make</CODE></A>.
<P>
<P>Go to the <A HREF="make_1.html">previous</A>, <A HREF="make_3.html">next</A> section.<P>
